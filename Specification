
Program = [FunctionDef]* fEOF
FunctionDef = fFn fIdentifier fLeftParen [Argument [, Argument]*] fRightParen [fNarrowRightArrow Type] Block
Type = PrimitiveType | fLeftBracket PrimitiveType fRightBracket
Argument = Type Identifier 
Block = fLeftBrace [Statement] fRightBrace
Statement = ConstDecl | VarDecl | IfStatement | WhileStatement | ForStatement | AssignStatement | ContinueStatement | BreakStatement

ConstDecl = fConst Type Identifier fAssign Expression fColon
VarDecl = fVar Type Identifier fAssign Expression fColon
IfStatement = fIf fLeftParen Expression fRightParen Block [ fElse [ fIf fLeftParen Expression fRightParen ] Block ]
WhileStatement = fWhile fLeftParen Expression fRightParen Block
ContinueStatement = fContinue fColon
BreakStatement = fBreak fColon
ForStatement = fFor fLeftParen Identifier fIn Identifier fRange Identifier fRightParen Block  // for i in 1..5
AssignStatement = Identifier fAssign Expression fColon

BooleanBinaryOps = fLogicalAnd | fLogicalOr
BooleanUnaryOps = fLogicalNot
CompareOps = fEqual | fGreat | fLess | fGreatEqual | fLessEqual | fNotEqual 
ArithOps1 = fAdd | fMul 
ArithOps2 = fMul | fDiv | fRem
ArithOps3 = fBitNot

Expression = Expression1 [BooleanBinaryOps Expression1]*
Expression1 = Expression2 [CompareOps Expression2]*
Expression2 = Expression3 [ArithOps1 Expression3]*
Expression3 = Expression4 [ArithOps2 Expression4]*
Expression4 = [ArithOps3 | BooleanUnaryOps] Expression4 
Expression5 = LeftParen Expression RightParen | fIdentifier | fLiteral