///! fff-lang
///!
///! lexical/seperator
///! Attention: contens are auto generated by token.py, do not modify this file

#[allow(non_snake_case)]
#[allow(non_upper_case_globals)]
pub mod SeperatorCategory {
    pub const       Additive: u16 = 0x0001;
    pub const         Assign: u16 = 0x0002;
    pub const         BitAnd: u16 = 0x0004;
    pub const          BitOr: u16 = 0x0008;
    pub const         BitXor: u16 = 0x0010;
    pub const       Equality: u16 = 0x0020;
    pub const     LogicalAnd: u16 = 0x0040;
    pub const      LogicalOr: u16 = 0x0080;
    pub const Multiplicative: u16 = 0x0100;
    pub const          Range: u16 = 0x0200;
    pub const     Relational: u16 = 0x0400;
    pub const       Reserved: u16 = 0x0800;
    pub const      Seperator: u16 = 0x1000;
    pub const          Shift: u16 = 0x2000;
    pub const          Unary: u16 = 0x4000;
}

#[derive(Eq, PartialEq, Copy, Clone)]
pub enum Seperator {
    LogicalNot,
    AttributeSign,
    Rem,
    BitAnd,
    LeftParenthenes,
    RightParenthenes,
    Mul,
    Add,
    Comma,
    Sub,
    Dot,
    Div,
    Colon,
    SemiColon,
    Less,
    Assign,
    Great,
    LeftBracket,
    RightBracket,
    BitXor,
    LeftBrace,
    BitOr,
    RightBrace,
    BitNot,
    NotEqual,
    RemAssign,
    LogicalAnd,
    BitAndAssign,
    MulAssign,
    AddAssign,
    SubAssign,
    NarrowRightArrow,
    Range,
    DivAssign,
    NamespaceSeperator,
    ShiftLeft,
    LessEqual,
    Equal,
    WideRightArrow,
    GreatEqual,
    ShiftRight,
    BitXorAssign,
    BitOrAssign,
    LogicalOr,
    ShiftLeftAssign,
    ShiftRightAssign,
}

const EMPTY_BUCKET: (u32, u32) = (0, 0);
const NAME_FROM_1_CHAR: &[(u32, u32)] = &[
    (37, 2), (38, 3), EMPTY_BUCKET, (40, 4), (41, 5), (42, 6), (43, 7), (44, 8), 
    (45, 9), (46, 10), (47, 11), EMPTY_BUCKET, (123, 20), (124, 21), (125, 22), (126, 23), 
    EMPTY_BUCKET, (91, 17), EMPTY_BUCKET, (93, 18), (94, 19), (58, 12), (59, 13), (60, 14), 
    (61, 15), (62, 16), EMPTY_BUCKET, EMPTY_BUCKET, EMPTY_BUCKET, EMPTY_BUCKET, EMPTY_BUCKET, EMPTY_BUCKET, 
    EMPTY_BUCKET, (33, 0), EMPTY_BUCKET, (35, 1), EMPTY_BUCKET, 
];
const NAME_FROM_2_CHAR: &[(u32, u32)] = &[
    (9766, 2), EMPTY_BUCKET, (15658, 4), (15659, 5), (11822, 8), (15661, 6), EMPTY_BUCKET, (15663, 9), 
    (15740, 18), EMPTY_BUCKET, (14906, 10), (15933, 14), (15934, 16), EMPTY_BUCKET, EMPTY_BUCKET, EMPTY_BUCKET, 
    (15710, 17), EMPTY_BUCKET, EMPTY_BUCKET, EMPTY_BUCKET, (15676, 12), (15677, 13), (15678, 15), EMPTY_BUCKET, 
    (31868, 19), EMPTY_BUCKET, EMPTY_BUCKET, EMPTY_BUCKET, EMPTY_BUCKET, EMPTY_BUCKET, (15420, 11), (15649, 0), 
    EMPTY_BUCKET, (15917, 7), EMPTY_BUCKET, (15653, 1), (15654, 3), EMPTY_BUCKET, 
];
impl Seperator {

    pub fn parse1(ch: char) -> Option<Seperator> {
        let hash = ch as u32;
        match NAME_FROM_1_CHAR[(hash % 37) as usize] {
            (key, _) if key != hash => None,
            (_, index) => unsafe { Some(::std::mem::transmute(index as u8)) },
        }
    }
    pub fn parse3(ch1: char, ch2: char, ch3: char) -> Option<(Seperator, usize)> {
        let hash2 = ch1 as u32 + ch2 as u32 *256;
        let hash1 = ch1 as u32;
        match &[ch1 as u8, ch2 as u8, ch3 as u8] {
            b"<<=" => unsafe { Some((::std::mem::transmute(44u8), 3)) },
            b">>=" => unsafe { Some((::std::mem::transmute(45u8), 3)) },
            _ => match NAME_FROM_2_CHAR[(hash2 % 38) as usize] {
                (key, _) if key != hash2 => match NAME_FROM_1_CHAR[(hash1 % 37) as usize] {
                    (key, _) if key != hash1 => None,
                    (_, index) => unsafe { Some((::std::mem::transmute(index as u8), 1)) },
                },
                (_, index) => unsafe { Some((::std::mem::transmute((index + 24) as u8), 2)) },
            },
        }
    }
}
impl ::std::fmt::Debug for Seperator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        const SEP_VALUES: &[&str] = &[
            "!", "#", "%", "&", "(", ")", "*", "+", ",", "-", ".", "/", 
            ":", ";", "<", "=", ">", "[", "]", "^", "{", "|", "}", "~", 
            "!=", "%=", "&&", "&=", "*=", "+=", "-=", "->", "..", "/=", "::", "<<", 
            "<=", "==", "=>", ">=", ">>", "^=", "|=", "||", "<<=", ">>="
        ];
        unsafe { write!(f, "{}",
            SEP_VALUES[::std::mem::transmute_copy::<Seperator, u8>(self) as usize]
        ) }
    }
}
impl Seperator {

    pub fn is_category(&self, cat: u16) -> bool {
        const SEP_CATS: &[u16] = &[
            16384, 2048, 256, 4, 4096, 4096, 256, 1, 4096, 16385, 4096, 256, 
            4096, 4096, 1024, 2, 1024, 4096, 4096, 16, 4096, 8, 4096, 16384, 
            32, 2, 64, 2, 2, 2, 2, 4096, 512, 2, 4096, 8192, 
            1024, 32, 2048, 1024, 8192, 2, 2, 128, 2, 2
        ];
        unsafe {
            (SEP_CATS[::std::mem::transmute_copy::<Seperator, u8>(self) as usize] & cat) == cat
        }
    }
}
#[cfg(test)] #[test]
fn seperator_debug() {

    assert_eq!{ format!("{:?}", Seperator::LogicalNot), "!" }
    assert_eq!{ format!("{:?}", Seperator::Dot), "." }
    assert_eq!{ format!("{:?}", Seperator::RemAssign), "%=" }
    assert_eq!{ format!("{:?}", Seperator::RemAssign), "%=" }
    assert_eq!{ format!("{:?}", Seperator::Equal), "==" }
    assert_eq!{ format!("{:?}", Seperator::Range), ".." }
    assert_eq!{ format!("{:?}", Seperator::GreatEqual), ">=" }
    assert_eq!{ format!("{:?}", Seperator::BitOrAssign), "|=" }
    assert_eq!{ format!("{:?}", Seperator::RemAssign), "%=" }
    assert_eq!{ format!("{:?}", Seperator::DivAssign), "/=" }
}
#[cfg(test)] #[test]
fn seperator_is_cat() {

    assert_eq!{ Seperator::LogicalNot.is_category(SeperatorCategory::Unary), true }
    assert_eq!{ Seperator::LogicalNot.is_category(SeperatorCategory::BitXor), false }
    assert_eq!{ Seperator::WideRightArrow.is_category(SeperatorCategory::Reserved), true }
    assert_eq!{ Seperator::WideRightArrow.is_category(SeperatorCategory::Additive), false }
    assert_eq!{ Seperator::Assign.is_category(SeperatorCategory::Assign), true }
    assert_eq!{ Seperator::Assign.is_category(SeperatorCategory::Range), false }
    assert_eq!{ Seperator::ShiftLeftAssign.is_category(SeperatorCategory::Assign), true }
    assert_eq!{ Seperator::ShiftLeftAssign.is_category(SeperatorCategory::Reserved), false }
    assert_eq!{ Seperator::Colon.is_category(SeperatorCategory::Seperator), true }
    assert_eq!{ Seperator::Colon.is_category(SeperatorCategory::Seperator), true }
    assert_eq!{ Seperator::Range.is_category(SeperatorCategory::Range), true }
    assert_eq!{ Seperator::Range.is_category(SeperatorCategory::Equality), false }
    assert_eq!{ Seperator::AttributeSign.is_category(SeperatorCategory::Reserved), true }
    assert_eq!{ Seperator::AttributeSign.is_category(SeperatorCategory::BitOr), false }
    assert_eq!{ Seperator::NamespaceSeperator.is_category(SeperatorCategory::Seperator), true }
    assert_eq!{ Seperator::NamespaceSeperator.is_category(SeperatorCategory::Seperator), true }
    assert_eq!{ Seperator::NotEqual.is_category(SeperatorCategory::Equality), true }
    assert_eq!{ Seperator::NotEqual.is_category(SeperatorCategory::Reserved), false }
    assert_eq!{ Seperator::NarrowRightArrow.is_category(SeperatorCategory::Seperator), true }
    assert_eq!{ Seperator::NarrowRightArrow.is_category(SeperatorCategory::Multiplicative), false }
}
#[cfg(test)] #[test]
fn seperator_use() {

    assert_eq!{ Seperator::parse3('<', '<', '='), Some((Seperator::ShiftLeftAssign, 3)) }
    assert_eq!{ Seperator::parse3('+', ' ', '1'), Some((Seperator::Add, 1)) }
    assert_eq!{ Seperator::parse3('{', ' ', 'a'), Some((Seperator::LeftBrace, 1)) }
    assert_eq!{ Seperator::parse3('&', '&', ' '), Some((Seperator::LogicalAnd, 2)) }
}
