///! ---------------------------------------------------------------------------------
///! This code is auto generated by a tool $repo/scripts/ast.py
///! Changes may cause incorrect behavior and will be lost if the code is regenerated.
///! ---------------------------------------------------------------------------------

use crate::source::{Span, IsId, IdSpan, FileId};
use crate::lexical::{Separator, Keyword, Numeric};
use crate::common::arena::{Arena, Index, Slice};

#[cfg(test)]
mod cmp;
mod new;
mod span;
mod ugly;
mod visit;
mod noauto;
mod pretty;
mod profile;

// put related methods in one module, because they are short
// and may conflict with other short names if included by ast::*, use like 
// ```
// use ...ast::*;
// ...
// asti::Eq::eq(actual, expect);
// (asti::debug(actual), asti::debug(expect));
// ```
pub mod asti {
    #[cfg(test)]
    pub use super::cmp::Eq;
    pub use super::ugly::debug;
    pub use super::pretty::{display, display1};
    pub use super::profile::MemoryProfiler;
}
pub use span::WithSpan;
// lit value can be regarded as a node type
pub use noauto::LitValue;
// natually extend to Arena when use ast::*
pub use new::EmplaceConcrete;

// AUTOGEN
pub struct ArrayExpr {
    pub span: Span,
    pub items: Slice<Expr>,
}

pub struct ArrayIndexExpr {
    pub span: Span,
    pub base: Expr,
    pub parameters: Slice<Expr>,
    pub quote_span: Span,
}

pub struct ArrayType {
    pub span: Span,
    pub base: TypeRef,
    pub size: Expr,
}

pub struct AssignExprStatement {
    pub span: Span,
    pub left: Expr,
    pub right: Expr,
    pub op: Separator,
    pub op_span: Span,
}

pub struct BinaryExpr {
    pub span: Span,
    pub left: Expr,
    pub right: Expr,
    pub op: Separator,
    pub op_span: Span,
}

pub struct Block {
    pub span: Span,
    pub items: Slice<Statement>,
}

pub struct BlockStatement {
    pub span: Span,
    pub label: Option<IdSpan>,
    pub body: Index<Block>,
}

pub struct BreakStatement {
    pub span: Span,
    pub label: Option<IdSpan>,
}

pub struct CallExpr {
    pub span: Span,
    pub base: Expr,
    pub quote_span: Span,
    pub parameters: Slice<Expr>,
}

pub struct CastSegment {
    pub span: Span,
    pub left: TypeRef,
    pub right: TypeRef,
}

pub struct ClassDef {
    pub span: Span,
    pub name: Index<GenericName>,
    pub quote_span: Span,
    pub items: Slice<Item>,
}

pub struct ContinueStatement {
    pub span: Span,
    pub label: Option<IdSpan>,
}

pub struct ElseClause {
    pub span: Span,
    pub body: Index<Block>,
}

pub struct EnumDef {
    pub span: Span,
    pub name: IdSpan,
    pub base_type: Option<Index<PrimitiveType>>,
    pub quote_span: Span,
    pub variants: Slice<Index<EnumDefVariant>>,
}

pub struct EnumDefVariant {
    pub span: Span,
    pub name: IdSpan,
    pub value: Option<Expr>,
}

#[derive(Clone, Copy)]
pub enum Expr {
    Lit(Index<LitExpr>),
    Path(Index<Path>),
    Paren(Index<ParenExpr>),
    Tuple(Index<TupleExpr>),
    Array(Index<ArrayExpr>),
    Call(Index<CallExpr>),
    ArrayIndex(Index<ArrayIndexExpr>),
    TupleIndex(Index<TupleIndexExpr>),
    Member(Index<MemberExpr>),
    Object(Index<ObjectExpr>),
    Unary(Index<UnaryExpr>),
    Binary(Index<BinaryExpr>),
    RangeBoth(Index<RangeBothExpr>),
    RangeFull(Index<RangeFullExpr>),
    RangeLeft(Index<RangeLeftExpr>),
    RangeRight(Index<RangeRightExpr>),
}

pub struct FieldDef {
    pub span: Span,
    pub name: IdSpan,
    pub colon_span: Span,
    pub r#type: TypeRef,
}

pub struct FnDef {
    pub span: Span,
    pub name: Index<GenericName>,
    pub quote_span: Span,
    pub parameters: Slice<Index<FnDefParameter>>,
    pub ret_type: Option<TypeRef>,
    pub wheres: Slice<Index<WhereClause>>,
    pub body: Option<Index<Block>>,
}

pub struct FnDefParameter {
    pub span: Span,
    pub name: IdSpan,
    pub r#type: TypeRef,
}

pub struct FnType {
    pub span: Span,
    pub quote_span: Span,
    pub parameters: Slice<Index<FnTypeParameter>>,
    pub ret_type: Option<TypeRef>,
}

pub struct FnTypeParameter {
    pub span: Span,
    pub name: Option<IdSpan>,
    pub r#type: TypeRef,
}

pub struct ForStatement {
    pub span: Span,
    pub label: Option<IdSpan>,
    pub iter_name: IdSpan,
    pub iter_expr: Expr,
    pub body: Index<Block>,
}

pub struct GenericName {
    pub span: Span,
    pub base: IdSpan,
    pub quote_span: Span,
    pub parameters: Slice<Index<GenericParameter>>,
}

pub struct GenericParameter {
    pub span: Span,
    pub name: IdSpan,
}

pub struct GenericSegment {
    pub span: Span,
    pub base: IdSpan,
    pub parameters: Index<TypeList>,
}

pub struct IfClause {
    pub span: Span,
    pub condition: Expr,
    pub body: Index<Block>,
}

pub struct IfStatement {
    pub span: Span,
    pub if_clause: Index<IfClause>,
    pub elseif_clauses: Slice<Index<IfClause>>,
    pub else_clause: Option<Index<ElseClause>>,
}

pub struct Implementation {
    pub span: Span,
    pub parameters: Slice<Index<GenericParameter>>,
    pub class: Option<TypeRef>,
    pub r#type: TypeRef,
    pub wheres: Slice<Index<WhereClause>>,
    pub quote_span: Span,
    pub items: Slice<Item>,
}

#[derive(Clone, Copy)]
pub enum Item {
    Struct(Index<StructDef>),
    Enum(Index<EnumDef>),
    Fn(Index<FnDef>),
    Impl(Index<Implementation>),
    Type(Index<TypeDef>),
    Class(Index<ClassDef>),
    Block(Index<BlockStatement>),
    SimpleExpr(Index<SimpleExprStatement>),
    AssignExpr(Index<AssignExprStatement>),
    For(Index<ForStatement>),
    If(Index<IfStatement>),
    Loop(Index<LoopStatement>),
    VarDecl(Index<VarDeclStatement>),
    While(Index<WhileStatement>),
    Use(Index<UseStatement>),
    Import(Index<ModuleStatement>),
}

pub struct LitExpr {
    pub span: Span,
    pub value: LitValue,
}

pub struct LoopStatement {
    pub span: Span,
    pub label: Option<IdSpan>,
    pub body: Index<Block>,
}

pub struct MemberExpr {
    pub span: Span,
    pub base: Expr,
    pub op_span: Span,
    pub name: IdSpan,
    pub parameters: Option<Index<TypeList>>,
}

pub struct Module {
    pub file: FileId,
    pub items: Slice<Item>,
}

pub struct ModuleStatement {
    pub span: Span,
    pub name: IdSpan,
    pub path: Option<IdSpan>,
}

pub struct ObjectExpr {
    pub span: Span,
    pub base: Expr,
    pub quote_span: Span,
    pub fields: Slice<Index<ObjectExprField>>,
}

pub struct ObjectExprField {
    pub span: Span,
    pub name: IdSpan,
    pub value: Expr,
}

pub struct ParenExpr {
    pub span: Span,
    pub base: Expr,
}

pub struct Path {
    pub span: Span,
    pub segments: Slice<PathSegment>,
}

#[derive(Clone, Copy)]
pub enum PathSegment {
    Global,
    Simple(Index<SimpleSegment>),
    Cast(Index<CastSegment>),
    Generic(Index<GenericSegment>),
}

pub struct PrimitiveType {
    pub span: Span,
    pub base: Keyword,
}

pub struct RangeBothExpr {
    pub span: Span,
    pub left: Expr,
    pub op_span: Span,
    pub right: Expr,
}

pub struct RangeFullExpr {
    pub span: Span,
}

pub struct RangeLeftExpr {
    pub span: Span,
    pub base: Expr,
}

pub struct RangeRightExpr {
    pub span: Span,
    pub base: Expr,
}

pub struct RefType {
    pub span: Span,
    pub base: TypeRef,
}

pub struct ReturnStatement {
    pub span: Span,
    pub value: Option<Expr>,
}

pub struct SimpleExprStatement {
    pub span: Span,
    pub expr: Expr,
}

pub struct SimpleSegment {
    pub span: Span,
    pub name: IsId,
}

#[derive(Clone, Copy)]
pub enum Statement {
    Struct(Index<StructDef>),
    Enum(Index<EnumDef>),
    Fn(Index<FnDef>),
    Impl(Index<Implementation>),
    Type(Index<TypeDef>),
    Class(Index<ClassDef>),
    Block(Index<BlockStatement>),
    Break(Index<BreakStatement>),
    Continue(Index<ContinueStatement>),
    SimpleExpr(Index<SimpleExprStatement>),
    AssignExpr(Index<AssignExprStatement>),
    For(Index<ForStatement>),
    If(Index<IfStatement>),
    Loop(Index<LoopStatement>),
    Return(Index<ReturnStatement>),
    VarDecl(Index<VarDeclStatement>),
    While(Index<WhileStatement>),
    Use(Index<UseStatement>),
}

pub struct StructDef {
    pub span: Span,
    pub name: Index<GenericName>,
    pub fields: Slice<Index<FieldDef>>,
}

pub struct TupleExpr {
    pub span: Span,
    pub items: Slice<Expr>,
}

pub struct TupleIndexExpr {
    pub span: Span,
    pub base: Expr,
    pub op_span: Span,
    pub value: i32,
    pub value_span: Span,
}

pub struct TupleType {
    pub span: Span,
    pub parameters: Slice<TypeRef>,
}

pub struct TypeDef {
    pub span: Span,
    pub name: Index<GenericName>,
    pub from: Option<TypeRef>,
}

pub struct TypeList {
    pub span: Span,
    pub items: Slice<TypeRef>,
}

#[derive(Clone, Copy)]
pub enum TypeRef {
    Array(Index<ArrayType>),
    Fn(Index<FnType>),
    Path(Index<Path>),
    Primitive(Index<PrimitiveType>),
    Ref(Index<RefType>),
    Tuple(Index<TupleType>),
}

pub struct UnaryExpr {
    pub span: Span,
    pub base: Expr,
    pub op: Separator,
    pub op_span: Span,
}

pub struct UseStatement {
    pub span: Span,
    pub path: Index<Path>,
    pub alias: Option<IdSpan>,
}

pub struct VarDeclStatement {
    pub span: Span,
    pub r#const: bool,
    pub name: IdSpan,
    pub r#type: Option<TypeRef>,
    pub init_value: Option<Expr>,
}

pub struct WhereClause {
    pub span: Span,
    pub name: IdSpan,
    pub constraints: Slice<TypeRef>,
}

pub struct WhileStatement {
    pub span: Span,
    pub label: Option<IdSpan>,
    pub condition: Expr,
    pub body: Index<Block>,
}
