///! ---------------------------------------------------------------------------------
///! This code is auto generated by a tool $repo/scripts/ast.py
///! Changes may cause incorrect behavior and will be lost if the code is regenerated.
///! ---------------------------------------------------------------------------------

///! visitor and visitable trait

// visitor visits node
// - each visit method visits specific node type and do different things 
//   to collect information (or change, by VisitorMut), after that, Visit::walk should be called to let
//   node itself guide visitor to child nodes, this decouples visitor implementation with tree structure
//   UPDATE: 
//   - eq is not using visitor because it is comparing a pair of node, not visiting one node
//   - ugly and pretty is not using walk because they need to display something between child nodes
//   - so currently only profile is actually using walk because it is a simple count(size_of)
// - on the other hand, Visit::accept implementation should call this node's matching visit method 
//   without dothing any other things, only then can methods accepting arbitrary V: Visit perform visit operation
// - according to this design
//   - default visit implementation walks self
//   - default walk implementation does nothing
//   - no default accept implementation
// return type is try for easily break from visiting process if any error happens or result already found, etc.

use std::ops::Try;
use crate::common::arena::{Arena, Index};
use super::ast::*;

pub trait Visit: Copy + Sized {

    fn walk<V: Visitor>(self, _arena: &Arena, _visitor: &mut V) -> V::Result {
        Default::default()
    }

    fn accept<V: Visitor>(self, _arena: &Arena, _visitor: &mut V) -> V::Result;
}

pub trait Visitor: Sized {
    // it is associate type not generic becuase
    // 1. it is not very reasonable to implement visitor for one type multiple times
    // 2. it is very not reasonable to distinguish different implementation by return type
    type Result: Default + Try;

    // AUTOGEN
    fn visit_array_expr(&mut self, node: Index<ArrayExpr>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_array_index_expr(&mut self, node: Index<ArrayIndexExpr>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_array_type(&mut self, node: Index<ArrayType>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_assign_expr_stmt(&mut self, node: Index<AssignExprStatement>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_binary_expr(&mut self, node: Index<BinaryExpr>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_block(&mut self, node: Index<Block>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_block_stmt(&mut self, node: Index<BlockStatement>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_break_stmt(&mut self, node: Index<BreakStatement>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_call_expr(&mut self, node: Index<CallExpr>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_cast_segment(&mut self, node: Index<CastSegment>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_class_def(&mut self, node: Index<ClassDef>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_continue_stmt(&mut self, node: Index<ContinueStatement>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_else_clause(&mut self, node: Index<ElseClause>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_enum_def(&mut self, node: Index<EnumDef>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_enum_def_variant(&mut self, node: Index<EnumDefVariant>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_expr(&mut self, node: Expr, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_field_def(&mut self, node: Index<FieldDef>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_fn_def(&mut self, node: Index<FnDef>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_fn_def_parameter(&mut self, node: Index<FnDefParameter>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_fn_type(&mut self, node: Index<FnType>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_fn_type_parameter(&mut self, node: Index<FnTypeParameter>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_for_stmt(&mut self, node: Index<ForStatement>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_generic_name(&mut self, node: Index<GenericName>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_generic_parameter(&mut self, node: Index<GenericParameter>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_generic_segment(&mut self, node: Index<GenericSegment>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_if_clause(&mut self, node: Index<IfClause>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_if_stmt(&mut self, node: Index<IfStatement>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_impl_block(&mut self, node: Index<Implementation>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_item(&mut self, node: Item, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_lit_expr(&mut self, node: Index<LitExpr>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_loop_stmt(&mut self, node: Index<LoopStatement>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_member_expr(&mut self, node: Index<MemberExpr>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_module(&mut self, node: Index<Module>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_module_stmt(&mut self, node: Index<ModuleStatement>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_object_expr(&mut self, node: Index<ObjectExpr>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_object_expr_field(&mut self, node: Index<ObjectExprField>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_paren_expr(&mut self, node: Index<ParenExpr>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_path(&mut self, node: Index<Path>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_path_segment(&mut self, node: PathSegment, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_primitive_type(&mut self, node: Index<PrimitiveType>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_range_both_expr(&mut self, node: Index<RangeBothExpr>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_range_full_expr(&mut self, node: Index<RangeFullExpr>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_range_left_expr(&mut self, node: Index<RangeLeftExpr>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_range_right_expr(&mut self, node: Index<RangeRightExpr>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_ref_type(&mut self, node: Index<RefType>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_ret_stmt(&mut self, node: Index<ReturnStatement>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_simple_expr_stmt(&mut self, node: Index<SimpleExprStatement>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_simple_segment(&mut self, node: Index<SimpleSegment>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_stmt(&mut self, node: Statement, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_struct_def(&mut self, node: Index<StructDef>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_tuple_expr(&mut self, node: Index<TupleExpr>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_tuple_index_expr(&mut self, node: Index<TupleIndexExpr>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_tuple_type(&mut self, node: Index<TupleType>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_type_def(&mut self, node: Index<TypeDef>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_type_list(&mut self, node: Index<TypeList>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_type_ref(&mut self, node: TypeRef, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_unary_expr(&mut self, node: Index<UnaryExpr>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_use_stmt(&mut self, node: Index<UseStatement>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_var_decl_stmt(&mut self, node: Index<VarDeclStatement>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_where_clause(&mut self, node: Index<WhereClause>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_while_stmt(&mut self, node: Index<WhileStatement>, arena: &Arena) -> Self::Result { node.walk(arena, self) }
}
