///! ---------------------------------------------------------------------------------
///! This code is auto generated by a tool $repo/scripts/ast.py
///! Changes may cause incorrect behavior and will be lost if the code is regenerated.
///! ---------------------------------------------------------------------------------

///! equality compare with arena

use super::*;

// this is not Visitor, because visitor visits one node, not *a pair of node*
pub trait Eq {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool;
}

impl<T> Eq for Option<T> where T: Eq {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.is_none() && rhs.is_none()
        || self.as_ref().zip(rhs.as_ref()).map(|(lhs, rhs)| Eq::eq(lhs, rhs, arena)).unwrap_or(false)
    }
}

impl<'a, T> Eq for Slice<'a, T> where T: Eq {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.len() == rhs.len() && std::iter::zip(arena.get_iter(&self), arena.get_iter(&rhs)).all(|(lhs, rhs)| Eq::eq(lhs, rhs, arena))
    }
}

impl<T> Eq for Vec<T> where T: Eq {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.len() == rhs.len() && std::iter::zip(self.iter(), rhs.iter()).all(|(lhs, rhs)| Eq::eq(lhs, rhs, arena))
    }
}

// AUTOGEN
impl<'a> Eq for Index<'a, ArrayExpr<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && Eq::eq(&lhs.items, &rhs.items, arena)
    }
}

impl<'a> Eq for Index<'a, ArrayIndexExpr<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && lhs.quote_span == rhs.quote_span
        && Eq::eq(&lhs.base, &rhs.base, arena)
        && Eq::eq(&lhs.parameters, &rhs.parameters, arena)
    }
}

impl<'a> Eq for Index<'a, ArrayType<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && Eq::eq(&lhs.base, &rhs.base, arena)
        && Eq::eq(&lhs.size, &rhs.size, arena)
    }
}

impl<'a> Eq for Index<'a, AssignExprStatement<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && lhs.op == rhs.op
        && lhs.op_span == rhs.op_span
        && Eq::eq(&lhs.left, &rhs.left, arena)
        && Eq::eq(&lhs.right, &rhs.right, arena)
    }
}

impl<'a> Eq for Index<'a, BinaryExpr<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && lhs.op == rhs.op
        && lhs.op_span == rhs.op_span
        && Eq::eq(&lhs.left, &rhs.left, arena)
        && Eq::eq(&lhs.right, &rhs.right, arena)
    }
}

impl<'a> Eq for Index<'a, Block<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && Eq::eq(&lhs.items, &rhs.items, arena)
    }
}

impl<'a> Eq for Index<'a, BlockStatement<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && lhs.label == rhs.label
        && Eq::eq(&lhs.body, &rhs.body, arena)
    }
}

impl<'a> Eq for Index<'a, BreakStatement> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && lhs.label == rhs.label
    }
}

impl<'a> Eq for Index<'a, CallExpr<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && lhs.quote_span == rhs.quote_span
        && Eq::eq(&lhs.base, &rhs.base, arena)
        && Eq::eq(&lhs.parameters, &rhs.parameters, arena)
    }
}

impl<'a> Eq for Index<'a, CastSegment<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && Eq::eq(&lhs.left, &rhs.left, arena)
        && Eq::eq(&lhs.right, &rhs.right, arena)
    }
}

impl<'a> Eq for Index<'a, ClassDef<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && lhs.quote_span == rhs.quote_span
        && Eq::eq(&lhs.name, &rhs.name, arena)
        && Eq::eq(&lhs.items, &rhs.items, arena)
    }
}

impl<'a> Eq for Index<'a, ContinueStatement> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && lhs.label == rhs.label
    }
}

impl<'a> Eq for Index<'a, ElseClause<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && Eq::eq(&lhs.body, &rhs.body, arena)
    }
}

impl<'a> Eq for Index<'a, EnumDef<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && lhs.name == rhs.name
        && lhs.quote_span == rhs.quote_span
        && Eq::eq(&lhs.base_type, &rhs.base_type, arena)
        && Eq::eq(&lhs.variants, &rhs.variants, arena)
    }
}

impl<'a> Eq for Index<'a, EnumDefVariant<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && lhs.name == rhs.name
        && Eq::eq(&lhs.value, &rhs.value, arena)
    }
}

impl<'a> Eq for Expr<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        match (self, rhs) {
            (Expr::Lit(lhs), Expr::Lit(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::Path(lhs), Expr::Path(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::Paren(lhs), Expr::Paren(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::Tuple(lhs), Expr::Tuple(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::Array(lhs), Expr::Array(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::Call(lhs), Expr::Call(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::ArrayIndex(lhs), Expr::ArrayIndex(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::TupleIndex(lhs), Expr::TupleIndex(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::Member(lhs), Expr::Member(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::Object(lhs), Expr::Object(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::Unary(lhs), Expr::Unary(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::Binary(lhs), Expr::Binary(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::RangeBoth(lhs), Expr::RangeBoth(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::RangeFull(lhs), Expr::RangeFull(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::RangeLeft(lhs), Expr::RangeLeft(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::RangeRight(lhs), Expr::RangeRight(rhs)) => Eq::eq(lhs, rhs, arena),
            _ => false,
        }
    }
}

impl<'a> Eq for Index<'a, FieldDef<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && lhs.name == rhs.name
        && lhs.colon_span == rhs.colon_span
        && Eq::eq(&lhs.r#type, &rhs.r#type, arena)
    }
}

impl<'a> Eq for Index<'a, FnDef<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && lhs.quote_span == rhs.quote_span
        && Eq::eq(&lhs.name, &rhs.name, arena)
        && Eq::eq(&lhs.parameters, &rhs.parameters, arena)
        && Eq::eq(&lhs.ret_type, &rhs.ret_type, arena)
        && Eq::eq(&lhs.wheres, &rhs.wheres, arena)
        && Eq::eq(&lhs.body, &rhs.body, arena)
    }
}

impl<'a> Eq for Index<'a, FnDefParameter<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && lhs.name == rhs.name
        && Eq::eq(&lhs.r#type, &rhs.r#type, arena)
    }
}

impl<'a> Eq for Index<'a, FnType<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && lhs.quote_span == rhs.quote_span
        && Eq::eq(&lhs.parameters, &rhs.parameters, arena)
        && Eq::eq(&lhs.ret_type, &rhs.ret_type, arena)
    }
}

impl<'a> Eq for Index<'a, FnTypeParameter<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && lhs.name == rhs.name
        && Eq::eq(&lhs.r#type, &rhs.r#type, arena)
    }
}

impl<'a> Eq for Index<'a, ForStatement<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && lhs.label == rhs.label
        && lhs.iter_name == rhs.iter_name
        && Eq::eq(&lhs.iter_expr, &rhs.iter_expr, arena)
        && Eq::eq(&lhs.body, &rhs.body, arena)
    }
}

impl<'a> Eq for Index<'a, GenericName<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && lhs.base == rhs.base
        && lhs.quote_span == rhs.quote_span
        && Eq::eq(&lhs.parameters, &rhs.parameters, arena)
    }
}

impl<'a> Eq for Index<'a, GenericParameter> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && lhs.name == rhs.name
    }
}

impl<'a> Eq for Index<'a, GenericSegment<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && lhs.base == rhs.base
        && Eq::eq(&lhs.parameters, &rhs.parameters, arena)
    }
}

impl<'a> Eq for Index<'a, IfClause<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && Eq::eq(&lhs.condition, &rhs.condition, arena)
        && Eq::eq(&lhs.body, &rhs.body, arena)
    }
}

impl<'a> Eq for Index<'a, IfStatement<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && Eq::eq(&lhs.if_clause, &rhs.if_clause, arena)
        && Eq::eq(&lhs.elseif_clauses, &rhs.elseif_clauses, arena)
        && Eq::eq(&lhs.else_clause, &rhs.else_clause, arena)
    }
}

impl<'a> Eq for Index<'a, Implementation<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && lhs.quote_span == rhs.quote_span
        && Eq::eq(&lhs.parameters, &rhs.parameters, arena)
        && Eq::eq(&lhs.class, &rhs.class, arena)
        && Eq::eq(&lhs.r#type, &rhs.r#type, arena)
        && Eq::eq(&lhs.wheres, &rhs.wheres, arena)
        && Eq::eq(&lhs.items, &rhs.items, arena)
    }
}

impl<'a> Eq for Item<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        match (self, rhs) {
            (Item::Struct(lhs), Item::Struct(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::Enum(lhs), Item::Enum(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::Fn(lhs), Item::Fn(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::Impl(lhs), Item::Impl(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::Type(lhs), Item::Type(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::Class(lhs), Item::Class(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::Block(lhs), Item::Block(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::SimpleExpr(lhs), Item::SimpleExpr(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::AssignExpr(lhs), Item::AssignExpr(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::For(lhs), Item::For(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::If(lhs), Item::If(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::Loop(lhs), Item::Loop(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::VarDecl(lhs), Item::VarDecl(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::While(lhs), Item::While(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::Use(lhs), Item::Use(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::Import(lhs), Item::Import(rhs)) => Eq::eq(lhs, rhs, arena),
            _ => false,
        }
    }
}

impl<'a> Eq for Index<'a, LitExpr> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && lhs.value == rhs.value
    }
}

impl<'a> Eq for Index<'a, LoopStatement<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && lhs.label == rhs.label
        && Eq::eq(&lhs.body, &rhs.body, arena)
    }
}

impl<'a> Eq for Index<'a, MemberExpr<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && lhs.op_span == rhs.op_span
        && lhs.name == rhs.name
        && Eq::eq(&lhs.base, &rhs.base, arena)
        && Eq::eq(&lhs.parameters, &rhs.parameters, arena)
    }
}

impl<'a> Eq for Index<'a, Module<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.file == rhs.file
        && Eq::eq(&lhs.items, &rhs.items, arena)
    }
}

impl<'a> Eq for Index<'a, ModuleStatement> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && lhs.name == rhs.name
        && lhs.path == rhs.path
    }
}

impl<'a> Eq for Index<'a, ObjectExpr<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && lhs.quote_span == rhs.quote_span
        && Eq::eq(&lhs.base, &rhs.base, arena)
        && Eq::eq(&lhs.fields, &rhs.fields, arena)
    }
}

impl<'a> Eq for Index<'a, ObjectExprField<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && lhs.name == rhs.name
        && Eq::eq(&lhs.value, &rhs.value, arena)
    }
}

impl<'a> Eq for Index<'a, ParenExpr<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && Eq::eq(&lhs.base, &rhs.base, arena)
    }
}

impl<'a> Eq for Index<'a, Path<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && Eq::eq(&lhs.segments, &rhs.segments, arena)
    }
}

impl<'a> Eq for PathSegment<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        match (self, rhs) {
            (PathSegment::Global, PathSegment::Global) => true,
            (PathSegment::Simple(lhs), PathSegment::Simple(rhs)) => Eq::eq(lhs, rhs, arena),
            (PathSegment::Cast(lhs), PathSegment::Cast(rhs)) => Eq::eq(lhs, rhs, arena),
            (PathSegment::Generic(lhs), PathSegment::Generic(rhs)) => Eq::eq(lhs, rhs, arena),
            _ => false,
        }
    }
}

impl<'a> Eq for Index<'a, PrimitiveType> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && lhs.base == rhs.base
    }
}

impl<'a> Eq for Index<'a, RangeBothExpr<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && lhs.op_span == rhs.op_span
        && Eq::eq(&lhs.left, &rhs.left, arena)
        && Eq::eq(&lhs.right, &rhs.right, arena)
    }
}

impl<'a> Eq for Index<'a, RangeFullExpr> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
    }
}

impl<'a> Eq for Index<'a, RangeLeftExpr<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && Eq::eq(&lhs.base, &rhs.base, arena)
    }
}

impl<'a> Eq for Index<'a, RangeRightExpr<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && Eq::eq(&lhs.base, &rhs.base, arena)
    }
}

impl<'a> Eq for Index<'a, RefType<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && Eq::eq(&lhs.base, &rhs.base, arena)
    }
}

impl<'a> Eq for Index<'a, ReturnStatement<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && Eq::eq(&lhs.value, &rhs.value, arena)
    }
}

impl<'a> Eq for Index<'a, SimpleExprStatement<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && Eq::eq(&lhs.expr, &rhs.expr, arena)
    }
}

impl<'a> Eq for Index<'a, SimpleSegment> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && lhs.name == rhs.name
    }
}

impl<'a> Eq for Statement<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        match (self, rhs) {
            (Statement::Struct(lhs), Statement::Struct(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::Enum(lhs), Statement::Enum(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::Fn(lhs), Statement::Fn(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::Impl(lhs), Statement::Impl(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::Type(lhs), Statement::Type(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::Class(lhs), Statement::Class(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::Block(lhs), Statement::Block(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::Break(lhs), Statement::Break(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::Continue(lhs), Statement::Continue(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::SimpleExpr(lhs), Statement::SimpleExpr(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::AssignExpr(lhs), Statement::AssignExpr(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::For(lhs), Statement::For(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::If(lhs), Statement::If(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::Loop(lhs), Statement::Loop(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::Return(lhs), Statement::Return(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::VarDecl(lhs), Statement::VarDecl(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::While(lhs), Statement::While(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::Use(lhs), Statement::Use(rhs)) => Eq::eq(lhs, rhs, arena),
            _ => false,
        }
    }
}

impl<'a> Eq for Index<'a, StructDef<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && Eq::eq(&lhs.name, &rhs.name, arena)
        && Eq::eq(&lhs.fields, &rhs.fields, arena)
    }
}

impl<'a> Eq for Index<'a, TupleExpr<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && Eq::eq(&lhs.items, &rhs.items, arena)
    }
}

impl<'a> Eq for Index<'a, TupleIndexExpr<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && lhs.op_span == rhs.op_span
        && lhs.value == rhs.value
        && lhs.value_span == rhs.value_span
        && Eq::eq(&lhs.base, &rhs.base, arena)
    }
}

impl<'a> Eq for Index<'a, TupleType<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && Eq::eq(&lhs.parameters, &rhs.parameters, arena)
    }
}

impl<'a> Eq for Index<'a, TypeDef<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && Eq::eq(&lhs.name, &rhs.name, arena)
        && Eq::eq(&lhs.from, &rhs.from, arena)
    }
}

impl<'a> Eq for Index<'a, TypeList<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && Eq::eq(&lhs.items, &rhs.items, arena)
    }
}

impl<'a> Eq for TypeRef<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        match (self, rhs) {
            (TypeRef::Array(lhs), TypeRef::Array(rhs)) => Eq::eq(lhs, rhs, arena),
            (TypeRef::Fn(lhs), TypeRef::Fn(rhs)) => Eq::eq(lhs, rhs, arena),
            (TypeRef::Path(lhs), TypeRef::Path(rhs)) => Eq::eq(lhs, rhs, arena),
            (TypeRef::Primitive(lhs), TypeRef::Primitive(rhs)) => Eq::eq(lhs, rhs, arena),
            (TypeRef::Ref(lhs), TypeRef::Ref(rhs)) => Eq::eq(lhs, rhs, arena),
            (TypeRef::Tuple(lhs), TypeRef::Tuple(rhs)) => Eq::eq(lhs, rhs, arena),
            _ => false,
        }
    }
}

impl<'a> Eq for Index<'a, UnaryExpr<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && lhs.op == rhs.op
        && lhs.op_span == rhs.op_span
        && Eq::eq(&lhs.base, &rhs.base, arena)
    }
}

impl<'a> Eq for Index<'a, UseStatement<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && lhs.alias == rhs.alias
        && Eq::eq(&lhs.path, &rhs.path, arena)
    }
}

impl<'a> Eq for Index<'a, VarDeclStatement<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && lhs.r#const == rhs.r#const
        && lhs.name == rhs.name
        && Eq::eq(&lhs.r#type, &rhs.r#type, arena)
        && Eq::eq(&lhs.init_value, &rhs.init_value, arena)
    }
}

impl<'a> Eq for Index<'a, WhereClause<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && lhs.name == rhs.name
        && Eq::eq(&lhs.constraints, &rhs.constraints, arena)
    }
}

impl<'a> Eq for Index<'a, WhileStatement<'a>> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(self), arena.get(rhs));
        lhs.span == rhs.span
        && lhs.label == rhs.label
        && Eq::eq(&lhs.condition, &rhs.condition, arena)
        && Eq::eq(&lhs.body, &rhs.body, arena)
    }
}
