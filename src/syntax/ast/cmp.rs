///! ---------------------------------------------------------------------------------
///! This code is auto generated by a tool $repo/scripts/ast.py
///! Changes may cause incorrect behavior and will be lost if the code is regenerated.
///! ---------------------------------------------------------------------------------

///! equality compare with arena

use super::*;

// this is not Visitor, because visitor visits one node, not *a pair of node*
pub trait Eq {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool;
}

impl<T> Eq for Option<T> where T: Eq {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.is_none() && rhs.is_none()
        || self.as_ref().zip(rhs.as_ref()).map(|(lhs, rhs)| Eq::eq(lhs, rhs, arena)).unwrap_or(false)
    }
}

impl<T> Eq for Slice<T> where T: Eq {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.len() == rhs.len() && std::iter::zip(arena.get_iter(*self), arena.get_iter(*rhs)).all(|(lhs, rhs)| Eq::eq(lhs, rhs, arena))
    }
}

impl<T> Eq for Vec<T> where T: Eq {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.len() == rhs.len() && std::iter::zip(self.iter(), rhs.iter()).all(|(lhs, rhs)| Eq::eq(lhs, rhs, arena))
    }
}

// AUTOGEN
impl Eq for Index<ArrayExpr> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && Eq::eq(&lhs.items, &rhs.items, arena)
    }
}

impl Eq for Index<ArrayIndexExpr> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && lhs.quote_span == rhs.quote_span
        && Eq::eq(&lhs.base, &rhs.base, arena)
        && Eq::eq(&lhs.parameters, &rhs.parameters, arena)
    }
}

impl Eq for Index<ArrayType> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && Eq::eq(&lhs.base, &rhs.base, arena)
        && Eq::eq(&lhs.size, &rhs.size, arena)
    }
}

impl Eq for Index<AssignExprStatement> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && lhs.op == rhs.op
        && lhs.op_span == rhs.op_span
        && Eq::eq(&lhs.left, &rhs.left, arena)
        && Eq::eq(&lhs.right, &rhs.right, arena)
    }
}

impl Eq for Index<BinaryExpr> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && lhs.op == rhs.op
        && lhs.op_span == rhs.op_span
        && Eq::eq(&lhs.left, &rhs.left, arena)
        && Eq::eq(&lhs.right, &rhs.right, arena)
    }
}

impl Eq for Index<Block> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && Eq::eq(&lhs.items, &rhs.items, arena)
    }
}

impl Eq for Index<BlockStatement> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && lhs.label == rhs.label
        && Eq::eq(&lhs.body, &rhs.body, arena)
    }
}

impl Eq for Index<BreakStatement> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && lhs.label == rhs.label
    }
}

impl Eq for Index<CallExpr> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && lhs.quote_span == rhs.quote_span
        && Eq::eq(&lhs.base, &rhs.base, arena)
        && Eq::eq(&lhs.parameters, &rhs.parameters, arena)
    }
}

impl Eq for Index<CastSegment> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && Eq::eq(&lhs.left, &rhs.left, arena)
        && Eq::eq(&lhs.right, &rhs.right, arena)
    }
}

impl Eq for Index<ClassDef> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && lhs.quote_span == rhs.quote_span
        && Eq::eq(&lhs.name, &rhs.name, arena)
        && Eq::eq(&lhs.items, &rhs.items, arena)
    }
}

impl Eq for Index<ContinueStatement> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && lhs.label == rhs.label
    }
}

impl Eq for Index<ElseClause> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && Eq::eq(&lhs.body, &rhs.body, arena)
    }
}

impl Eq for Index<EnumDef> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && lhs.name == rhs.name
        && lhs.quote_span == rhs.quote_span
        && Eq::eq(&lhs.base_type, &rhs.base_type, arena)
        && Eq::eq(&lhs.variants, &rhs.variants, arena)
    }
}

impl Eq for Index<EnumDefVariant> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && lhs.name == rhs.name
        && Eq::eq(&lhs.value, &rhs.value, arena)
    }
}

impl Eq for Expr {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        match (self, rhs) {
            (Expr::Lit(lhs), Expr::Lit(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::Path(lhs), Expr::Path(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::Paren(lhs), Expr::Paren(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::Tuple(lhs), Expr::Tuple(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::Array(lhs), Expr::Array(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::Call(lhs), Expr::Call(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::ArrayIndex(lhs), Expr::ArrayIndex(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::TupleIndex(lhs), Expr::TupleIndex(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::Member(lhs), Expr::Member(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::Object(lhs), Expr::Object(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::Unary(lhs), Expr::Unary(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::Binary(lhs), Expr::Binary(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::RangeBoth(lhs), Expr::RangeBoth(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::RangeFull(lhs), Expr::RangeFull(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::RangeLeft(lhs), Expr::RangeLeft(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::RangeRight(lhs), Expr::RangeRight(rhs)) => Eq::eq(lhs, rhs, arena),
            _ => false,
        }
    }
}

impl Eq for Index<FieldDef> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && lhs.name == rhs.name
        && lhs.colon_span == rhs.colon_span
        && Eq::eq(&lhs.r#type, &rhs.r#type, arena)
    }
}

impl Eq for Index<FnDef> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && lhs.quote_span == rhs.quote_span
        && Eq::eq(&lhs.name, &rhs.name, arena)
        && Eq::eq(&lhs.parameters, &rhs.parameters, arena)
        && Eq::eq(&lhs.ret_type, &rhs.ret_type, arena)
        && Eq::eq(&lhs.wheres, &rhs.wheres, arena)
        && Eq::eq(&lhs.body, &rhs.body, arena)
    }
}

impl Eq for Index<FnDefParameter> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && lhs.name == rhs.name
        && Eq::eq(&lhs.r#type, &rhs.r#type, arena)
    }
}

impl Eq for Index<FnType> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && lhs.quote_span == rhs.quote_span
        && Eq::eq(&lhs.parameters, &rhs.parameters, arena)
        && Eq::eq(&lhs.ret_type, &rhs.ret_type, arena)
    }
}

impl Eq for Index<FnTypeParameter> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && lhs.name == rhs.name
        && Eq::eq(&lhs.r#type, &rhs.r#type, arena)
    }
}

impl Eq for Index<ForStatement> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && lhs.label == rhs.label
        && lhs.iter_name == rhs.iter_name
        && Eq::eq(&lhs.iter_expr, &rhs.iter_expr, arena)
        && Eq::eq(&lhs.body, &rhs.body, arena)
    }
}

impl Eq for Index<GenericName> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && lhs.base == rhs.base
        && lhs.quote_span == rhs.quote_span
        && Eq::eq(&lhs.parameters, &rhs.parameters, arena)
    }
}

impl Eq for Index<GenericParameter> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && lhs.name == rhs.name
    }
}

impl Eq for Index<GenericSegment> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && lhs.base == rhs.base
        && Eq::eq(&lhs.parameters, &rhs.parameters, arena)
    }
}

impl Eq for Index<IfClause> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && Eq::eq(&lhs.condition, &rhs.condition, arena)
        && Eq::eq(&lhs.body, &rhs.body, arena)
    }
}

impl Eq for Index<IfStatement> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && Eq::eq(&lhs.if_clause, &rhs.if_clause, arena)
        && Eq::eq(&lhs.elseif_clauses, &rhs.elseif_clauses, arena)
        && Eq::eq(&lhs.else_clause, &rhs.else_clause, arena)
    }
}

impl Eq for Index<Implementation> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && lhs.quote_span == rhs.quote_span
        && Eq::eq(&lhs.parameters, &rhs.parameters, arena)
        && Eq::eq(&lhs.class, &rhs.class, arena)
        && Eq::eq(&lhs.r#type, &rhs.r#type, arena)
        && Eq::eq(&lhs.wheres, &rhs.wheres, arena)
        && Eq::eq(&lhs.items, &rhs.items, arena)
    }
}

impl Eq for Item {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        match (self, rhs) {
            (Item::Struct(lhs), Item::Struct(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::Enum(lhs), Item::Enum(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::Fn(lhs), Item::Fn(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::Impl(lhs), Item::Impl(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::Type(lhs), Item::Type(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::Class(lhs), Item::Class(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::Block(lhs), Item::Block(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::SimpleExpr(lhs), Item::SimpleExpr(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::AssignExpr(lhs), Item::AssignExpr(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::For(lhs), Item::For(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::If(lhs), Item::If(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::Loop(lhs), Item::Loop(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::VarDecl(lhs), Item::VarDecl(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::While(lhs), Item::While(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::Use(lhs), Item::Use(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::Import(lhs), Item::Import(rhs)) => Eq::eq(lhs, rhs, arena),
            _ => false,
        }
    }
}

impl Eq for Index<LitExpr> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && lhs.value == rhs.value
    }
}

impl Eq for Index<LoopStatement> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && lhs.label == rhs.label
        && Eq::eq(&lhs.body, &rhs.body, arena)
    }
}

impl Eq for Index<MemberExpr> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && lhs.op_span == rhs.op_span
        && lhs.name == rhs.name
        && Eq::eq(&lhs.base, &rhs.base, arena)
        && Eq::eq(&lhs.parameters, &rhs.parameters, arena)
    }
}

impl Eq for Index<Module> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.file == rhs.file
        && Eq::eq(&lhs.items, &rhs.items, arena)
    }
}

impl Eq for Index<ModuleStatement> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && lhs.name == rhs.name
        && lhs.path == rhs.path
    }
}

impl Eq for Index<ObjectExpr> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && lhs.quote_span == rhs.quote_span
        && Eq::eq(&lhs.base, &rhs.base, arena)
        && Eq::eq(&lhs.fields, &rhs.fields, arena)
    }
}

impl Eq for Index<ObjectExprField> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && lhs.name == rhs.name
        && Eq::eq(&lhs.value, &rhs.value, arena)
    }
}

impl Eq for Index<ParenExpr> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && Eq::eq(&lhs.base, &rhs.base, arena)
    }
}

impl Eq for Index<Path> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && Eq::eq(&lhs.segments, &rhs.segments, arena)
    }
}

impl Eq for PathSegment {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        match (self, rhs) {
            (PathSegment::Global, PathSegment::Global) => true,
            (PathSegment::Simple(lhs), PathSegment::Simple(rhs)) => Eq::eq(lhs, rhs, arena),
            (PathSegment::Cast(lhs), PathSegment::Cast(rhs)) => Eq::eq(lhs, rhs, arena),
            (PathSegment::Generic(lhs), PathSegment::Generic(rhs)) => Eq::eq(lhs, rhs, arena),
            _ => false,
        }
    }
}

impl Eq for Index<PrimitiveType> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && lhs.base == rhs.base
    }
}

impl Eq for Index<RangeBothExpr> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && lhs.op_span == rhs.op_span
        && Eq::eq(&lhs.left, &rhs.left, arena)
        && Eq::eq(&lhs.right, &rhs.right, arena)
    }
}

impl Eq for Index<RangeFullExpr> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
    }
}

impl Eq for Index<RangeLeftExpr> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && Eq::eq(&lhs.base, &rhs.base, arena)
    }
}

impl Eq for Index<RangeRightExpr> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && Eq::eq(&lhs.base, &rhs.base, arena)
    }
}

impl Eq for Index<RefType> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && Eq::eq(&lhs.base, &rhs.base, arena)
    }
}

impl Eq for Index<ReturnStatement> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && Eq::eq(&lhs.value, &rhs.value, arena)
    }
}

impl Eq for Index<SimpleExprStatement> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && Eq::eq(&lhs.expr, &rhs.expr, arena)
    }
}

impl Eq for Index<SimpleSegment> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && lhs.name == rhs.name
    }
}

impl Eq for Statement {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        match (self, rhs) {
            (Statement::Struct(lhs), Statement::Struct(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::Enum(lhs), Statement::Enum(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::Fn(lhs), Statement::Fn(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::Impl(lhs), Statement::Impl(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::Type(lhs), Statement::Type(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::Class(lhs), Statement::Class(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::Block(lhs), Statement::Block(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::Break(lhs), Statement::Break(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::Continue(lhs), Statement::Continue(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::SimpleExpr(lhs), Statement::SimpleExpr(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::AssignExpr(lhs), Statement::AssignExpr(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::For(lhs), Statement::For(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::If(lhs), Statement::If(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::Loop(lhs), Statement::Loop(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::Return(lhs), Statement::Return(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::VarDecl(lhs), Statement::VarDecl(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::While(lhs), Statement::While(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::Use(lhs), Statement::Use(rhs)) => Eq::eq(lhs, rhs, arena),
            _ => false,
        }
    }
}

impl Eq for Index<StructDef> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && Eq::eq(&lhs.name, &rhs.name, arena)
        && Eq::eq(&lhs.fields, &rhs.fields, arena)
    }
}

impl Eq for Index<TupleExpr> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && Eq::eq(&lhs.items, &rhs.items, arena)
    }
}

impl Eq for Index<TupleIndexExpr> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && lhs.op_span == rhs.op_span
        && lhs.value == rhs.value
        && lhs.value_span == rhs.value_span
        && Eq::eq(&lhs.base, &rhs.base, arena)
    }
}

impl Eq for Index<TupleType> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && Eq::eq(&lhs.parameters, &rhs.parameters, arena)
    }
}

impl Eq for Index<TypeDef> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && Eq::eq(&lhs.name, &rhs.name, arena)
        && Eq::eq(&lhs.from, &rhs.from, arena)
    }
}

impl Eq for Index<TypeList> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && Eq::eq(&lhs.items, &rhs.items, arena)
    }
}

impl Eq for TypeRef {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        match (self, rhs) {
            (TypeRef::Array(lhs), TypeRef::Array(rhs)) => Eq::eq(lhs, rhs, arena),
            (TypeRef::Fn(lhs), TypeRef::Fn(rhs)) => Eq::eq(lhs, rhs, arena),
            (TypeRef::Path(lhs), TypeRef::Path(rhs)) => Eq::eq(lhs, rhs, arena),
            (TypeRef::Primitive(lhs), TypeRef::Primitive(rhs)) => Eq::eq(lhs, rhs, arena),
            (TypeRef::Ref(lhs), TypeRef::Ref(rhs)) => Eq::eq(lhs, rhs, arena),
            (TypeRef::Tuple(lhs), TypeRef::Tuple(rhs)) => Eq::eq(lhs, rhs, arena),
            _ => false,
        }
    }
}

impl Eq for Index<UnaryExpr> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && lhs.op == rhs.op
        && lhs.op_span == rhs.op_span
        && Eq::eq(&lhs.base, &rhs.base, arena)
    }
}

impl Eq for Index<UseStatement> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && lhs.alias == rhs.alias
        && Eq::eq(&lhs.path, &rhs.path, arena)
    }
}

impl Eq for Index<VarDeclStatement> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && lhs.r#const == rhs.r#const
        && lhs.name == rhs.name
        && Eq::eq(&lhs.r#type, &rhs.r#type, arena)
        && Eq::eq(&lhs.init_value, &rhs.init_value, arena)
    }
}

impl Eq for Index<WhereClause> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && lhs.name == rhs.name
        && Eq::eq(&lhs.constraints, &rhs.constraints, arena)
    }
}

impl Eq for Index<WhileStatement> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        let (lhs, rhs) = (arena.get(*self), arena.get(*rhs));

        lhs.span == rhs.span
        && lhs.label == rhs.label
        && Eq::eq(&lhs.condition, &rhs.condition, arena)
        && Eq::eq(&lhs.body, &rhs.body, arena)
    }
}
