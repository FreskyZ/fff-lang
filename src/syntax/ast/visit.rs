///! ---------------------------------------------------------------------------------
///! This code is auto generated by a tool $repo/scripts/ast.py
///! Changes may cause incorrect behavior and will be lost if the code is regenerated.
///! ---------------------------------------------------------------------------------

///! impl Visit for each node

use super::super::visit::{Visit, Visitor};
use super::*;

impl Visit for Index<ArrayExpr> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_array_expr(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        for &item in arena.get_iter(this.items) {
            v.visit_expr(item, arena)?;
        }
        Default::default()
    }
}

impl Visit for Index<ArrayIndexExpr> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_array_index_expr(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_expr(this.base, arena)?;
        for &parameter in arena.get_iter(this.parameters) {
            v.visit_expr(parameter, arena)?;
        }
        Default::default()
    }
}

impl Visit for Index<ArrayType> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_array_type(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_type_ref(this.base, arena)?;
        v.visit_expr(this.size, arena)
    }
}

impl Visit for Index<AssignExprStatement> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_assign_expr_stmt(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_expr(this.left, arena)?;
        v.visit_expr(this.right, arena)
    }
}

impl Visit for Index<BinaryExpr> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_binary_expr(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_expr(this.left, arena)?;
        v.visit_expr(this.right, arena)
    }
}

impl Visit for Index<Block> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_block(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        for &item in arena.get_iter(this.items) {
            v.visit_stmt(item, arena)?;
        }
        Default::default()
    }
}

impl Visit for Index<BlockStatement> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_block_stmt(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_block(this.body, arena)
    }
}

impl Visit for Index<BreakStatement> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_break_stmt(self, arena)
    }
}

impl Visit for Index<CallExpr> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_call_expr(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_expr(this.base, arena)?;
        for &parameter in arena.get_iter(this.parameters) {
            v.visit_expr(parameter, arena)?;
        }
        Default::default()
    }
}

impl Visit for Index<CastSegment> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_cast_segment(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_type_ref(this.left, arena)?;
        v.visit_type_ref(this.right, arena)
    }
}

impl Visit for Index<ClassDef> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_class_def(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_generic_name(this.name, arena)?;
        for &item in arena.get_iter(this.items) {
            v.visit_item(item, arena)?;
        }
        Default::default()
    }
}

impl Visit for Index<ContinueStatement> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_continue_stmt(self, arena)
    }
}

impl Visit for Index<ElseClause> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_else_clause(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_block(this.body, arena)
    }
}

impl Visit for Index<EnumDef> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_enum_def(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        if let Some(base_type) = this.base_type {
            v.visit_primitive_type(base_type, arena)?;
        }
        for &variant in arena.get_iter(this.variants) {
            v.visit_enum_def_variant(variant, arena)?;
        }
        Default::default()
    }
}

impl Visit for Index<EnumDefVariant> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_enum_def_variant(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        if let Some(value) = this.value {
            v.visit_expr(value, arena)?;
        }
        Default::default()
    }
}

impl Visit for Expr {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_expr(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        match self {
            Expr::Lit(n) => v.visit_lit_expr(n, arena),
            Expr::Path(n) => v.visit_path(n, arena),
            Expr::Paren(n) => v.visit_paren_expr(n, arena),
            Expr::Tuple(n) => v.visit_tuple_expr(n, arena),
            Expr::Array(n) => v.visit_array_expr(n, arena),
            Expr::Call(n) => v.visit_call_expr(n, arena),
            Expr::ArrayIndex(n) => v.visit_array_index_expr(n, arena),
            Expr::TupleIndex(n) => v.visit_tuple_index_expr(n, arena),
            Expr::Member(n) => v.visit_member_expr(n, arena),
            Expr::Object(n) => v.visit_object_expr(n, arena),
            Expr::Unary(n) => v.visit_unary_expr(n, arena),
            Expr::Binary(n) => v.visit_binary_expr(n, arena),
            Expr::RangeBoth(n) => v.visit_range_both_expr(n, arena),
            Expr::RangeFull(n) => v.visit_range_full_expr(n, arena),
            Expr::RangeLeft(n) => v.visit_range_left_expr(n, arena),
            Expr::RangeRight(n) => v.visit_range_right_expr(n, arena),
        }
    }
}

impl Visit for Index<FieldDef> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_field_def(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_type_ref(this.r#type, arena)
    }
}

impl Visit for Index<FnDef> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_fn_def(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_generic_name(this.name, arena)?;
        for &parameter in arena.get_iter(this.parameters) {
            v.visit_fn_def_parameter(parameter, arena)?;
        }
        if let Some(ret_type) = this.ret_type {
            v.visit_type_ref(ret_type, arena)?;
        }
        for &r#where in arena.get_iter(this.wheres) {
            v.visit_where_clause(r#where, arena)?;
        }
        if let Some(body) = this.body {
            v.visit_block(body, arena)?;
        }
        Default::default()
    }
}

impl Visit for Index<FnDefParameter> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_fn_def_parameter(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_type_ref(this.r#type, arena)
    }
}

impl Visit for Index<FnType> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_fn_type(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        for &parameter in arena.get_iter(this.parameters) {
            v.visit_fn_type_parameter(parameter, arena)?;
        }
        if let Some(ret_type) = this.ret_type {
            v.visit_type_ref(ret_type, arena)?;
        }
        Default::default()
    }
}

impl Visit for Index<FnTypeParameter> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_fn_type_parameter(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_type_ref(this.r#type, arena)
    }
}

impl Visit for Index<ForStatement> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_for_stmt(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_expr(this.iter_expr, arena)?;
        v.visit_block(this.body, arena)
    }
}

impl Visit for Index<GenericName> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_generic_name(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        for &parameter in arena.get_iter(this.parameters) {
            v.visit_generic_parameter(parameter, arena)?;
        }
        Default::default()
    }
}

impl Visit for Index<GenericParameter> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_generic_parameter(self, arena)
    }
}

impl Visit for Index<GenericSegment> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_generic_segment(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_type_list(this.parameters, arena)
    }
}

impl Visit for Index<IfClause> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_if_clause(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_expr(this.condition, arena)?;
        v.visit_block(this.body, arena)
    }
}

impl Visit for Index<IfStatement> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_if_stmt(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_if_clause(this.if_clause, arena)?;
        for &elseif_clause in arena.get_iter(this.elseif_clauses) {
            v.visit_if_clause(elseif_clause, arena)?;
        }
        if let Some(else_clause) = this.else_clause {
            v.visit_else_clause(else_clause, arena)?;
        }
        Default::default()
    }
}

impl Visit for Index<Implementation> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_impl_block(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        for &parameter in arena.get_iter(this.parameters) {
            v.visit_generic_parameter(parameter, arena)?;
        }
        if let Some(class) = this.class {
            v.visit_type_ref(class, arena)?;
        }
        v.visit_type_ref(this.r#type, arena)?;
        for &r#where in arena.get_iter(this.wheres) {
            v.visit_where_clause(r#where, arena)?;
        }
        for &item in arena.get_iter(this.items) {
            v.visit_item(item, arena)?;
        }
        Default::default()
    }
}

impl Visit for Item {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_item(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        match self {
            Item::Struct(n) => v.visit_struct_def(n, arena),
            Item::Enum(n) => v.visit_enum_def(n, arena),
            Item::Fn(n) => v.visit_fn_def(n, arena),
            Item::Impl(n) => v.visit_impl_block(n, arena),
            Item::Type(n) => v.visit_type_def(n, arena),
            Item::Class(n) => v.visit_class_def(n, arena),
            Item::Block(n) => v.visit_block_stmt(n, arena),
            Item::SimpleExpr(n) => v.visit_simple_expr_stmt(n, arena),
            Item::AssignExpr(n) => v.visit_assign_expr_stmt(n, arena),
            Item::For(n) => v.visit_for_stmt(n, arena),
            Item::If(n) => v.visit_if_stmt(n, arena),
            Item::Loop(n) => v.visit_loop_stmt(n, arena),
            Item::VarDecl(n) => v.visit_var_decl_stmt(n, arena),
            Item::While(n) => v.visit_while_stmt(n, arena),
            Item::Use(n) => v.visit_use_stmt(n, arena),
            Item::Import(n) => v.visit_module_stmt(n, arena),
        }
    }
}

impl Visit for Index<LitExpr> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_lit_expr(self, arena)
    }
}

impl Visit for Index<LoopStatement> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_loop_stmt(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_block(this.body, arena)
    }
}

impl Visit for Index<MemberExpr> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_member_expr(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_expr(this.base, arena)?;
        if let Some(parameters) = this.parameters {
            v.visit_type_list(parameters, arena)?;
        }
        Default::default()
    }
}

impl Visit for Index<Module> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_module(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        for &item in arena.get_iter(this.items) {
            v.visit_item(item, arena)?;
        }
        Default::default()
    }
}

impl Visit for Index<ModuleStatement> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_module_stmt(self, arena)
    }
}

impl Visit for Index<ObjectExpr> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_object_expr(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_expr(this.base, arena)?;
        for &field in arena.get_iter(this.fields) {
            v.visit_object_expr_field(field, arena)?;
        }
        Default::default()
    }
}

impl Visit for Index<ObjectExprField> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_object_expr_field(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_expr(this.value, arena)
    }
}

impl Visit for Index<ParenExpr> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_paren_expr(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_expr(this.base, arena)
    }
}

impl Visit for Index<Path> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_path(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        for &segment in arena.get_iter(this.segments) {
            v.visit_path_segment(segment, arena)?;
        }
        Default::default()
    }
}

impl Visit for PathSegment {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_path_segment(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        match self {
            PathSegment::Global => Default::default(),
            PathSegment::Simple(n) => v.visit_simple_segment(n, arena),
            PathSegment::Cast(n) => v.visit_cast_segment(n, arena),
            PathSegment::Generic(n) => v.visit_generic_segment(n, arena),
        }
    }
}

impl Visit for Index<PrimitiveType> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_primitive_type(self, arena)
    }
}

impl Visit for Index<RangeBothExpr> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_range_both_expr(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_expr(this.left, arena)?;
        v.visit_expr(this.right, arena)
    }
}

impl Visit for Index<RangeFullExpr> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_range_full_expr(self, arena)
    }
}

impl Visit for Index<RangeLeftExpr> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_range_left_expr(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_expr(this.base, arena)
    }
}

impl Visit for Index<RangeRightExpr> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_range_right_expr(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_expr(this.base, arena)
    }
}

impl Visit for Index<RefType> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_ref_type(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_type_ref(this.base, arena)
    }
}

impl Visit for Index<ReturnStatement> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_ret_stmt(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        if let Some(value) = this.value {
            v.visit_expr(value, arena)?;
        }
        Default::default()
    }
}

impl Visit for Index<SimpleExprStatement> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_simple_expr_stmt(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_expr(this.expr, arena)
    }
}

impl Visit for Index<SimpleSegment> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_simple_segment(self, arena)
    }
}

impl Visit for Statement {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_stmt(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        match self {
            Statement::Struct(n) => v.visit_struct_def(n, arena),
            Statement::Enum(n) => v.visit_enum_def(n, arena),
            Statement::Fn(n) => v.visit_fn_def(n, arena),
            Statement::Impl(n) => v.visit_impl_block(n, arena),
            Statement::Type(n) => v.visit_type_def(n, arena),
            Statement::Class(n) => v.visit_class_def(n, arena),
            Statement::Block(n) => v.visit_block_stmt(n, arena),
            Statement::Break(n) => v.visit_break_stmt(n, arena),
            Statement::Continue(n) => v.visit_continue_stmt(n, arena),
            Statement::SimpleExpr(n) => v.visit_simple_expr_stmt(n, arena),
            Statement::AssignExpr(n) => v.visit_assign_expr_stmt(n, arena),
            Statement::For(n) => v.visit_for_stmt(n, arena),
            Statement::If(n) => v.visit_if_stmt(n, arena),
            Statement::Loop(n) => v.visit_loop_stmt(n, arena),
            Statement::Return(n) => v.visit_ret_stmt(n, arena),
            Statement::VarDecl(n) => v.visit_var_decl_stmt(n, arena),
            Statement::While(n) => v.visit_while_stmt(n, arena),
            Statement::Use(n) => v.visit_use_stmt(n, arena),
        }
    }
}

impl Visit for Index<StructDef> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_struct_def(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_generic_name(this.name, arena)?;
        for &field in arena.get_iter(this.fields) {
            v.visit_field_def(field, arena)?;
        }
        Default::default()
    }
}

impl Visit for Index<TupleExpr> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_tuple_expr(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        for &item in arena.get_iter(this.items) {
            v.visit_expr(item, arena)?;
        }
        Default::default()
    }
}

impl Visit for Index<TupleIndexExpr> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_tuple_index_expr(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_expr(this.base, arena)
    }
}

impl Visit for Index<TupleType> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_tuple_type(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        for &parameter in arena.get_iter(this.parameters) {
            v.visit_type_ref(parameter, arena)?;
        }
        Default::default()
    }
}

impl Visit for Index<TypeDef> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_type_def(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_generic_name(this.name, arena)?;
        if let Some(from) = this.from {
            v.visit_type_ref(from, arena)?;
        }
        Default::default()
    }
}

impl Visit for Index<TypeList> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_type_list(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        for &item in arena.get_iter(this.items) {
            v.visit_type_ref(item, arena)?;
        }
        Default::default()
    }
}

impl Visit for TypeRef {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_type_ref(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        match self {
            TypeRef::Array(n) => v.visit_array_type(n, arena),
            TypeRef::Fn(n) => v.visit_fn_type(n, arena),
            TypeRef::Path(n) => v.visit_path(n, arena),
            TypeRef::Primitive(n) => v.visit_primitive_type(n, arena),
            TypeRef::Ref(n) => v.visit_ref_type(n, arena),
            TypeRef::Tuple(n) => v.visit_tuple_type(n, arena),
        }
    }
}

impl Visit for Index<UnaryExpr> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_unary_expr(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_expr(this.base, arena)
    }
}

impl Visit for Index<UseStatement> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_use_stmt(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_path(this.path, arena)
    }
}

impl Visit for Index<VarDeclStatement> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_var_decl_stmt(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        if let Some(r#type) = this.r#type {
            v.visit_type_ref(r#type, arena)?;
        }
        if let Some(init_value) = this.init_value {
            v.visit_expr(init_value, arena)?;
        }
        Default::default()
    }
}

impl Visit for Index<WhereClause> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_where_clause(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        for &constraint in arena.get_iter(this.constraints) {
            v.visit_type_ref(constraint, arena)?;
        }
        Default::default()
    }
}

impl Visit for Index<WhileStatement> {
    fn accept<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_while_stmt(self, arena)
    }
    fn walk<V: Visitor>(self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_expr(this.condition, arena)?;
        v.visit_block(this.body, arena)
    }
}
