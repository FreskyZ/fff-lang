///! ---------------------------------------------------------------------------------
///! This code is auto generated by a tool $repo/scripts/ast.py
///! Changes may cause incorrect behavior and will be lost if the code is regenerated.
///! ---------------------------------------------------------------------------------

///! ast memory usage profiler

use std::mem::size_of;
use crate::common::arena::Arena;
use super::super::visit::{Visitor, Visit};
use super::noauto::EmptyResult;
use super::*;

#[derive(Clone, Copy)]
struct Entry {
    count: usize,
    size: usize,
}

impl Entry {

    fn count(&mut self, size: usize) {
        self.count += 1;
        self.size += size;
    }
}

impl MemoryProfiler {

    pub fn dump(&self, output: &mut impl std::io::Write) {

        let total_count: usize = self.v.iter().map(|e| e.count).sum();
        let total_size: usize = self.v.iter().map(|e| e.size).sum();
        writeln!(output, "[all({total_count})] {total_size}").unwrap();

        let mut ordered_items = self.v.iter()
            .enumerate().map(|(i, e)| (NAMES[i], e.count, e.size)).collect::<Vec<_>>();
        ordered_items.sort_unstable_by(|a, b| a.2.cmp(&b.2).then_with(|| a.0.cmp(&b.0)).reverse());
        for (key, count, size) in ordered_items {
            if count > 0 {
                let header = format!("[{key}({count})]");
                let size_percent = size as f64 * 100f64 / total_size as f64;
                writeln!(output, "{header} {size} ({size_percent:.2}%)").unwrap();
            }
        }
    }
}

// AUTOGEN
// use static name list because they are known at code generation time
static NAMES: &[&str] = &[
    "array-expr",
    "array-index-expr",
    "array-type",
    "assign-expr-stmt",
    "binary-expr",
    "block",
    "block-stmt",
    "break-stmt",
    "call-expr",
    "cast-segment",
    "class-def",
    "continue-stmt",
    "else-clause",
    "enum-def",
    "enum-def-variant",
    "field-def",
    "fn-def",
    "fn-def-parameter",
    "fn-type",
    "fn-type-parameter",
    "for-stmt",
    "generic-name",
    "generic-parameter",
    "generic-segment",
    "if-clause",
    "if-stmt",
    "impl-block",
    "lit-expr",
    "loop-stmt",
    "member-expr",
    "module",
    "module-stmt",
    "object-expr",
    "object-expr-field",
    "paren-expr",
    "path",
    "primitive-type",
    "range-both-expr",
    "range-full-expr",
    "range-left-expr",
    "range-right-expr",
    "ref-type",
    "ret-stmt",
    "simple-expr-stmt",
    "simple-segment",
    "struct-def",
    "tuple-expr",
    "tuple-index-expr",
    "tuple-type",
    "type-def",
    "type-list",
    "unary-expr",
    "use-stmt",
    "var-decl-stmt",
    "where-clause",
    "while-stmt",
];

pub struct MemoryProfiler {
    v: [Entry; 56],
}

impl MemoryProfiler {
    pub fn new() -> Self {
        Self{ v: [Entry{ count: 0, size: 0 }; 56] }
    }
    pub fn coverage(&self) -> (usize, usize, String) {
        (self.v.iter().filter(|e| e.count > 0).count(), self.v.len(),
            self.v.iter().enumerate().filter(|(_, e)| e.count == 0).map(|(i, _)| NAMES[i]).collect::<Vec<_>>().join(", "))
    }
}

impl Visitor for MemoryProfiler {
    type Result = EmptyResult;
    // enum types are all default here because they literal does not use any memory on its own in this arena refactor

    fn visit_array_expr(&mut self, node: Index<ArrayExpr>, arena: &Arena) -> Self::Result {
        self.v[0].count(size_of::<ArrayExpr>());
        node.walk(arena, self)
    }
    fn visit_array_index_expr(&mut self, node: Index<ArrayIndexExpr>, arena: &Arena) -> Self::Result {
        self.v[1].count(size_of::<ArrayIndexExpr>());
        node.walk(arena, self)
    }
    fn visit_array_type(&mut self, node: Index<ArrayType>, arena: &Arena) -> Self::Result {
        self.v[2].count(size_of::<ArrayType>());
        node.walk(arena, self)
    }
    fn visit_assign_expr_stmt(&mut self, node: Index<AssignExprStatement>, arena: &Arena) -> Self::Result {
        self.v[3].count(size_of::<AssignExprStatement>());
        node.walk(arena, self)
    }
    fn visit_binary_expr(&mut self, node: Index<BinaryExpr>, arena: &Arena) -> Self::Result {
        self.v[4].count(size_of::<BinaryExpr>());
        node.walk(arena, self)
    }
    fn visit_block(&mut self, node: Index<Block>, arena: &Arena) -> Self::Result {
        self.v[5].count(size_of::<Block>());
        node.walk(arena, self)
    }
    fn visit_block_stmt(&mut self, node: Index<BlockStatement>, arena: &Arena) -> Self::Result {
        self.v[6].count(size_of::<BlockStatement>());
        node.walk(arena, self)
    }
    fn visit_break_stmt(&mut self, node: Index<BreakStatement>, arena: &Arena) -> Self::Result {
        self.v[7].count(size_of::<BreakStatement>());
        node.walk(arena, self)
    }
    fn visit_call_expr(&mut self, node: Index<CallExpr>, arena: &Arena) -> Self::Result {
        self.v[8].count(size_of::<CallExpr>());
        node.walk(arena, self)
    }
    fn visit_cast_segment(&mut self, node: Index<CastSegment>, arena: &Arena) -> Self::Result {
        self.v[9].count(size_of::<CastSegment>());
        node.walk(arena, self)
    }
    fn visit_class_def(&mut self, node: Index<ClassDef>, arena: &Arena) -> Self::Result {
        self.v[10].count(size_of::<ClassDef>());
        node.walk(arena, self)
    }
    fn visit_continue_stmt(&mut self, node: Index<ContinueStatement>, arena: &Arena) -> Self::Result {
        self.v[11].count(size_of::<ContinueStatement>());
        node.walk(arena, self)
    }
    fn visit_else_clause(&mut self, node: Index<ElseClause>, arena: &Arena) -> Self::Result {
        self.v[12].count(size_of::<ElseClause>());
        node.walk(arena, self)
    }
    fn visit_enum_def(&mut self, node: Index<EnumDef>, arena: &Arena) -> Self::Result {
        self.v[13].count(size_of::<EnumDef>());
        node.walk(arena, self)
    }
    fn visit_enum_def_variant(&mut self, node: Index<EnumDefVariant>, arena: &Arena) -> Self::Result {
        self.v[14].count(size_of::<EnumDefVariant>());
        node.walk(arena, self)
    }
    fn visit_field_def(&mut self, node: Index<FieldDef>, arena: &Arena) -> Self::Result {
        self.v[15].count(size_of::<FieldDef>());
        node.walk(arena, self)
    }
    fn visit_fn_def(&mut self, node: Index<FnDef>, arena: &Arena) -> Self::Result {
        self.v[16].count(size_of::<FnDef>());
        node.walk(arena, self)
    }
    fn visit_fn_def_parameter(&mut self, node: Index<FnDefParameter>, arena: &Arena) -> Self::Result {
        self.v[17].count(size_of::<FnDefParameter>());
        node.walk(arena, self)
    }
    fn visit_fn_type(&mut self, node: Index<FnType>, arena: &Arena) -> Self::Result {
        self.v[18].count(size_of::<FnType>());
        node.walk(arena, self)
    }
    fn visit_fn_type_parameter(&mut self, node: Index<FnTypeParameter>, arena: &Arena) -> Self::Result {
        self.v[19].count(size_of::<FnTypeParameter>());
        node.walk(arena, self)
    }
    fn visit_for_stmt(&mut self, node: Index<ForStatement>, arena: &Arena) -> Self::Result {
        self.v[20].count(size_of::<ForStatement>());
        node.walk(arena, self)
    }
    fn visit_generic_name(&mut self, node: Index<GenericName>, arena: &Arena) -> Self::Result {
        self.v[21].count(size_of::<GenericName>());
        node.walk(arena, self)
    }
    fn visit_generic_parameter(&mut self, node: Index<GenericParameter>, arena: &Arena) -> Self::Result {
        self.v[22].count(size_of::<GenericParameter>());
        node.walk(arena, self)
    }
    fn visit_generic_segment(&mut self, node: Index<GenericSegment>, arena: &Arena) -> Self::Result {
        self.v[23].count(size_of::<GenericSegment>());
        node.walk(arena, self)
    }
    fn visit_if_clause(&mut self, node: Index<IfClause>, arena: &Arena) -> Self::Result {
        self.v[24].count(size_of::<IfClause>());
        node.walk(arena, self)
    }
    fn visit_if_stmt(&mut self, node: Index<IfStatement>, arena: &Arena) -> Self::Result {
        self.v[25].count(size_of::<IfStatement>());
        node.walk(arena, self)
    }
    fn visit_impl_block(&mut self, node: Index<Implementation>, arena: &Arena) -> Self::Result {
        self.v[26].count(size_of::<Implementation>());
        node.walk(arena, self)
    }
    fn visit_lit_expr(&mut self, node: Index<LitExpr>, arena: &Arena) -> Self::Result {
        self.v[27].count(size_of::<LitExpr>());
        node.walk(arena, self)
    }
    fn visit_loop_stmt(&mut self, node: Index<LoopStatement>, arena: &Arena) -> Self::Result {
        self.v[28].count(size_of::<LoopStatement>());
        node.walk(arena, self)
    }
    fn visit_member_expr(&mut self, node: Index<MemberExpr>, arena: &Arena) -> Self::Result {
        self.v[29].count(size_of::<MemberExpr>());
        node.walk(arena, self)
    }
    fn visit_module(&mut self, node: Index<Module>, arena: &Arena) -> Self::Result {
        self.v[30].count(size_of::<Module>());
        node.walk(arena, self)
    }
    fn visit_module_stmt(&mut self, node: Index<ModuleStatement>, arena: &Arena) -> Self::Result {
        self.v[31].count(size_of::<ModuleStatement>());
        node.walk(arena, self)
    }
    fn visit_object_expr(&mut self, node: Index<ObjectExpr>, arena: &Arena) -> Self::Result {
        self.v[32].count(size_of::<ObjectExpr>());
        node.walk(arena, self)
    }
    fn visit_object_expr_field(&mut self, node: Index<ObjectExprField>, arena: &Arena) -> Self::Result {
        self.v[33].count(size_of::<ObjectExprField>());
        node.walk(arena, self)
    }
    fn visit_paren_expr(&mut self, node: Index<ParenExpr>, arena: &Arena) -> Self::Result {
        self.v[34].count(size_of::<ParenExpr>());
        node.walk(arena, self)
    }
    fn visit_path(&mut self, node: Index<Path>, arena: &Arena) -> Self::Result {
        self.v[35].count(size_of::<Path>());
        node.walk(arena, self)
    }
    fn visit_primitive_type(&mut self, node: Index<PrimitiveType>, arena: &Arena) -> Self::Result {
        self.v[36].count(size_of::<PrimitiveType>());
        node.walk(arena, self)
    }
    fn visit_range_both_expr(&mut self, node: Index<RangeBothExpr>, arena: &Arena) -> Self::Result {
        self.v[37].count(size_of::<RangeBothExpr>());
        node.walk(arena, self)
    }
    fn visit_range_full_expr(&mut self, node: Index<RangeFullExpr>, arena: &Arena) -> Self::Result {
        self.v[38].count(size_of::<RangeFullExpr>());
        node.walk(arena, self)
    }
    fn visit_range_left_expr(&mut self, node: Index<RangeLeftExpr>, arena: &Arena) -> Self::Result {
        self.v[39].count(size_of::<RangeLeftExpr>());
        node.walk(arena, self)
    }
    fn visit_range_right_expr(&mut self, node: Index<RangeRightExpr>, arena: &Arena) -> Self::Result {
        self.v[40].count(size_of::<RangeRightExpr>());
        node.walk(arena, self)
    }
    fn visit_ref_type(&mut self, node: Index<RefType>, arena: &Arena) -> Self::Result {
        self.v[41].count(size_of::<RefType>());
        node.walk(arena, self)
    }
    fn visit_ret_stmt(&mut self, node: Index<ReturnStatement>, arena: &Arena) -> Self::Result {
        self.v[42].count(size_of::<ReturnStatement>());
        node.walk(arena, self)
    }
    fn visit_simple_expr_stmt(&mut self, node: Index<SimpleExprStatement>, arena: &Arena) -> Self::Result {
        self.v[43].count(size_of::<SimpleExprStatement>());
        node.walk(arena, self)
    }
    fn visit_simple_segment(&mut self, node: Index<SimpleSegment>, arena: &Arena) -> Self::Result {
        self.v[44].count(size_of::<SimpleSegment>());
        node.walk(arena, self)
    }
    fn visit_struct_def(&mut self, node: Index<StructDef>, arena: &Arena) -> Self::Result {
        self.v[45].count(size_of::<StructDef>());
        node.walk(arena, self)
    }
    fn visit_tuple_expr(&mut self, node: Index<TupleExpr>, arena: &Arena) -> Self::Result {
        self.v[46].count(size_of::<TupleExpr>());
        node.walk(arena, self)
    }
    fn visit_tuple_index_expr(&mut self, node: Index<TupleIndexExpr>, arena: &Arena) -> Self::Result {
        self.v[47].count(size_of::<TupleIndexExpr>());
        node.walk(arena, self)
    }
    fn visit_tuple_type(&mut self, node: Index<TupleType>, arena: &Arena) -> Self::Result {
        self.v[48].count(size_of::<TupleType>());
        node.walk(arena, self)
    }
    fn visit_type_def(&mut self, node: Index<TypeDef>, arena: &Arena) -> Self::Result {
        self.v[49].count(size_of::<TypeDef>());
        node.walk(arena, self)
    }
    fn visit_type_list(&mut self, node: Index<TypeList>, arena: &Arena) -> Self::Result {
        self.v[50].count(size_of::<TypeList>());
        node.walk(arena, self)
    }
    fn visit_unary_expr(&mut self, node: Index<UnaryExpr>, arena: &Arena) -> Self::Result {
        self.v[51].count(size_of::<UnaryExpr>());
        node.walk(arena, self)
    }
    fn visit_use_stmt(&mut self, node: Index<UseStatement>, arena: &Arena) -> Self::Result {
        self.v[52].count(size_of::<UseStatement>());
        node.walk(arena, self)
    }
    fn visit_var_decl_stmt(&mut self, node: Index<VarDeclStatement>, arena: &Arena) -> Self::Result {
        self.v[53].count(size_of::<VarDeclStatement>());
        node.walk(arena, self)
    }
    fn visit_where_clause(&mut self, node: Index<WhereClause>, arena: &Arena) -> Self::Result {
        self.v[54].count(size_of::<WhereClause>());
        node.walk(arena, self)
    }
    fn visit_while_stmt(&mut self, node: Index<WhileStatement>, arena: &Arena) -> Self::Result {
        self.v[55].count(size_of::<WhileStatement>());
        node.walk(arena, self)
    }
}
