///! ---------------------------------------------------------------------------------
///! This code is auto generated by a tool $repo/scripts/ast.py
///! Changes may cause incorrect behavior and will be lost if the code is regenerated.
///! ---------------------------------------------------------------------------------

///! debug format with arena, make index/slice transparent

use std::fmt::{self, Write};
use super::super::visit::{Visitor, Visit};
use super::noauto::EmptyResult;
use super::*;

pub struct Debug<'a, 'b, N>(&'a N, &'b Arena);

pub fn debug<'a, 'b, N: Visit>(node: &'a N, arena: &'b Arena) -> Debug<'a, 'b, N> {
    Debug(node, arena)
}

impl<'a, 'b, N> fmt::Debug for Debug<'a, 'b, N> where N: Visit {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = Formatter(f);
        self.0.accept(self.1, &mut formatter).into_result().map_err(|_| fmt::Error)
    }
}

struct LeaveGuard(u32);

impl Drop for LeaveGuard {
    fn drop(&mut self) {
        // assert balance in cfg(debug_assertions)
    }
}

struct Formatter<'f1, 'f2>(&'f1 mut fmt::Formatter<'f2>);

impl<'f1, 'f2> Formatter<'f1, 'f2> {

    // first call in visit implement, map index to object, also record to check circular reference
    fn enter<'a, N>(&self, node: Index<N>, arena: &'a Arena) -> (&'a N, LeaveGuard) {
        (arena.get(node), LeaveGuard(node.as_raw()))
    }

    fn start_struct(&mut self, name: &'static str) -> Result<&mut Self, fmt::Error> {
        self.0.write_str(name)?;
        self.0.write_str("{ ")?;
        Ok(self)
    }

    fn end_struct(&mut self) -> EmptyResult {
        self.0.write_char('}')?;
        EmptyResult(true)
    }

    // optional terminal is here
    fn field(&mut self, name: &'static str, value: impl fmt::Debug + Copy) -> Result<&mut Self, fmt::Error> {
        self.0.write_str(name)?;
        self.0.write_str(": ")?;
        write!(self.0, "{:?}", value)?;
        self.0.write_str(", ")?;
        Ok(self)
    }

    // LitValue is not Copy
    fn lit_value(&mut self, name: &'static str, value: &LitValue) -> Result<&mut Self, fmt::Error> {
        self.0.write_str(name)?;
        self.0.write_str(": ")?;
        write!(self.0, "{:?}", value)?;
        self.0.write_str(", ")?;
        Ok(self)
    }

    // NOTE: this visitor is also not walkable, because you need to insert ", field_name: " between 2 visit_* calls

    // index or enum
    fn forward<N: Visit>(&mut self, name: &'static str, value: N, arena: &Arena) -> Result<&mut Self, fmt::Error> {
        self.0.write_str(name)?;
        self.0.write_str(": ")?;
        value.accept(arena, self).into_result().map_err(|_| fmt::Error)?;
        self.0.write_str(", ")?;
        Ok(self)
    }

    // optiona index or enum
    fn optional<N: Visit>(&mut self, name: &'static str, value: Option<N>, arena: &Arena) -> Result<&mut Self, fmt::Error> {
        self.0.write_str(name)?;
        self.0.write_str(": ")?;
        if let Some(value) = value {
            value.accept(arena, self).into_result().map_err(|_| fmt::Error)?;
        } else {
            self.0.write_str("None")?;
        }
        self.0.write_str(", ")?;
        Ok(self)
    }

    fn slice<N: Visit>(&mut self, name: &'static str, slice: Slice<N>, arena: &Arena) -> Result<&mut Self, fmt::Error> {
        self.0.write_str(name)?;
        self.0.write_str(": [")?;
        for item in arena.get_iter(slice) {
            item.accept(arena, self).into_result().map_err(|_| fmt::Error)?;
            self.0.write_str(", ")?;
        }
        Ok(self)
    }

    fn variant<N>(&mut self, name: &'static str, index: Index<N>, arena: &Arena) -> EmptyResult where Index<N>: Visit {
        self.0.write_str(name)?;
        self.0.write_char('(')?;
        index.accept(arena, self).into_result().map_err(|_| fmt::Error)?;
        self.0.write_char(')')?;
        EmptyResult(true)
    }
}

impl<'f1, 'f2> Visitor for Formatter<'f1, 'f2> {
    type Result = EmptyResult;

    // AUTOGEN
    fn visit_array_expr(&mut self, node: Index<ArrayExpr>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("ArrayExpr")?
            .field("span", node.span)?
            .slice("items", node.items, arena)?
            .end_struct()
    }

    fn visit_array_index_expr(&mut self, node: Index<ArrayIndexExpr>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("ArrayIndexExpr")?
            .field("span", node.span)?
            .forward("base", node.base, arena)?
            .slice("parameters", node.parameters, arena)?
            .field("quote_span", node.quote_span)?
            .end_struct()
    }

    fn visit_array_type(&mut self, node: Index<ArrayType>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("ArrayType")?
            .field("span", node.span)?
            .forward("base", node.base, arena)?
            .forward("size", node.size, arena)?
            .end_struct()
    }

    fn visit_assign_expr_stmt(&mut self, node: Index<AssignExprStatement>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("AssignExprStatement")?
            .field("span", node.span)?
            .forward("left", node.left, arena)?
            .forward("right", node.right, arena)?
            .field("op", node.op)?
            .field("op_span", node.op_span)?
            .end_struct()
    }

    fn visit_binary_expr(&mut self, node: Index<BinaryExpr>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("BinaryExpr")?
            .field("span", node.span)?
            .forward("left", node.left, arena)?
            .forward("right", node.right, arena)?
            .field("op", node.op)?
            .field("op_span", node.op_span)?
            .end_struct()
    }

    fn visit_block(&mut self, node: Index<Block>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("Block")?
            .field("span", node.span)?
            .slice("items", node.items, arena)?
            .end_struct()
    }

    fn visit_block_stmt(&mut self, node: Index<BlockStatement>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("BlockStatement")?
            .field("span", node.span)?
            .field("label", node.label)?
            .forward("body", node.body, arena)?
            .end_struct()
    }

    fn visit_break_stmt(&mut self, node: Index<BreakStatement>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("BreakStatement")?
            .field("span", node.span)?
            .field("label", node.label)?
            .end_struct()
    }

    fn visit_call_expr(&mut self, node: Index<CallExpr>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("CallExpr")?
            .field("span", node.span)?
            .forward("base", node.base, arena)?
            .field("quote_span", node.quote_span)?
            .slice("parameters", node.parameters, arena)?
            .end_struct()
    }

    fn visit_cast_segment(&mut self, node: Index<CastSegment>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("CastSegment")?
            .field("span", node.span)?
            .forward("left", node.left, arena)?
            .forward("right", node.right, arena)?
            .end_struct()
    }

    fn visit_class_def(&mut self, node: Index<ClassDef>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("ClassDef")?
            .field("span", node.span)?
            .forward("name", node.name, arena)?
            .field("quote_span", node.quote_span)?
            .slice("items", node.items, arena)?
            .end_struct()
    }

    fn visit_continue_stmt(&mut self, node: Index<ContinueStatement>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("ContinueStatement")?
            .field("span", node.span)?
            .field("label", node.label)?
            .end_struct()
    }

    fn visit_else_clause(&mut self, node: Index<ElseClause>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("ElseClause")?
            .field("span", node.span)?
            .forward("body", node.body, arena)?
            .end_struct()
    }

    fn visit_enum_def(&mut self, node: Index<EnumDef>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("EnumDef")?
            .field("span", node.span)?
            .field("name", node.name)?
            .optional("base_type", node.base_type, arena)?
            .field("quote_span", node.quote_span)?
            .slice("variants", node.variants, arena)?
            .end_struct()
    }

    fn visit_enum_def_variant(&mut self, node: Index<EnumDefVariant>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("EnumDefVariant")?
            .field("span", node.span)?
            .field("name", node.name)?
            .optional("value", node.value, arena)?
            .end_struct()
    }

    fn visit_expr(&mut self, node: Expr, arena: &Arena) -> Self::Result {
        match node {
            Expr::Lit(n) => self.variant("Expr::Lit", n, arena),
            Expr::Path(n) => self.variant("Expr::Path", n, arena),
            Expr::Paren(n) => self.variant("Expr::Paren", n, arena),
            Expr::Tuple(n) => self.variant("Expr::Tuple", n, arena),
            Expr::Array(n) => self.variant("Expr::Array", n, arena),
            Expr::Call(n) => self.variant("Expr::Call", n, arena),
            Expr::ArrayIndex(n) => self.variant("Expr::ArrayIndex", n, arena),
            Expr::TupleIndex(n) => self.variant("Expr::TupleIndex", n, arena),
            Expr::Member(n) => self.variant("Expr::Member", n, arena),
            Expr::Object(n) => self.variant("Expr::Object", n, arena),
            Expr::Unary(n) => self.variant("Expr::Unary", n, arena),
            Expr::Binary(n) => self.variant("Expr::Binary", n, arena),
            Expr::RangeBoth(n) => self.variant("Expr::RangeBoth", n, arena),
            Expr::RangeFull(n) => self.variant("Expr::RangeFull", n, arena),
            Expr::RangeLeft(n) => self.variant("Expr::RangeLeft", n, arena),
            Expr::RangeRight(n) => self.variant("Expr::RangeRight", n, arena),
        }
    }

    fn visit_field_def(&mut self, node: Index<FieldDef>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("FieldDef")?
            .field("span", node.span)?
            .field("name", node.name)?
            .field("colon_span", node.colon_span)?
            .forward("r#type", node.r#type, arena)?
            .end_struct()
    }

    fn visit_fn_def(&mut self, node: Index<FnDef>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("FnDef")?
            .field("span", node.span)?
            .forward("name", node.name, arena)?
            .field("quote_span", node.quote_span)?
            .slice("parameters", node.parameters, arena)?
            .optional("ret_type", node.ret_type, arena)?
            .slice("wheres", node.wheres, arena)?
            .optional("body", node.body, arena)?
            .end_struct()
    }

    fn visit_fn_def_parameter(&mut self, node: Index<FnDefParameter>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("FnDefParameter")?
            .field("span", node.span)?
            .field("name", node.name)?
            .forward("r#type", node.r#type, arena)?
            .end_struct()
    }

    fn visit_fn_type(&mut self, node: Index<FnType>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("FnType")?
            .field("span", node.span)?
            .field("quote_span", node.quote_span)?
            .slice("parameters", node.parameters, arena)?
            .optional("ret_type", node.ret_type, arena)?
            .end_struct()
    }

    fn visit_fn_type_parameter(&mut self, node: Index<FnTypeParameter>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("FnTypeParameter")?
            .field("span", node.span)?
            .field("name", node.name)?
            .forward("r#type", node.r#type, arena)?
            .end_struct()
    }

    fn visit_for_stmt(&mut self, node: Index<ForStatement>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("ForStatement")?
            .field("span", node.span)?
            .field("label", node.label)?
            .field("iter_name", node.iter_name)?
            .forward("iter_expr", node.iter_expr, arena)?
            .forward("body", node.body, arena)?
            .end_struct()
    }

    fn visit_generic_name(&mut self, node: Index<GenericName>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("GenericName")?
            .field("span", node.span)?
            .field("base", node.base)?
            .field("quote_span", node.quote_span)?
            .slice("parameters", node.parameters, arena)?
            .end_struct()
    }

    fn visit_generic_parameter(&mut self, node: Index<GenericParameter>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("GenericParameter")?
            .field("span", node.span)?
            .field("name", node.name)?
            .end_struct()
    }

    fn visit_generic_segment(&mut self, node: Index<GenericSegment>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("GenericSegment")?
            .field("span", node.span)?
            .field("base", node.base)?
            .forward("parameters", node.parameters, arena)?
            .end_struct()
    }

    fn visit_if_clause(&mut self, node: Index<IfClause>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("IfClause")?
            .field("span", node.span)?
            .forward("condition", node.condition, arena)?
            .forward("body", node.body, arena)?
            .end_struct()
    }

    fn visit_if_stmt(&mut self, node: Index<IfStatement>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("IfStatement")?
            .field("span", node.span)?
            .forward("if_clause", node.if_clause, arena)?
            .slice("elseif_clauses", node.elseif_clauses, arena)?
            .optional("else_clause", node.else_clause, arena)?
            .end_struct()
    }

    fn visit_impl_block(&mut self, node: Index<Implementation>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("Implementation")?
            .field("span", node.span)?
            .slice("parameters", node.parameters, arena)?
            .optional("class", node.class, arena)?
            .forward("r#type", node.r#type, arena)?
            .slice("wheres", node.wheres, arena)?
            .field("quote_span", node.quote_span)?
            .slice("items", node.items, arena)?
            .end_struct()
    }

    fn visit_item(&mut self, node: Item, arena: &Arena) -> Self::Result {
        match node {
            Item::Struct(n) => self.variant("Item::Struct", n, arena),
            Item::Enum(n) => self.variant("Item::Enum", n, arena),
            Item::Fn(n) => self.variant("Item::Fn", n, arena),
            Item::Impl(n) => self.variant("Item::Impl", n, arena),
            Item::Type(n) => self.variant("Item::Type", n, arena),
            Item::Class(n) => self.variant("Item::Class", n, arena),
            Item::Block(n) => self.variant("Item::Block", n, arena),
            Item::SimpleExpr(n) => self.variant("Item::SimpleExpr", n, arena),
            Item::AssignExpr(n) => self.variant("Item::AssignExpr", n, arena),
            Item::For(n) => self.variant("Item::For", n, arena),
            Item::If(n) => self.variant("Item::If", n, arena),
            Item::Loop(n) => self.variant("Item::Loop", n, arena),
            Item::VarDecl(n) => self.variant("Item::VarDecl", n, arena),
            Item::While(n) => self.variant("Item::While", n, arena),
            Item::Use(n) => self.variant("Item::Use", n, arena),
            Item::Import(n) => self.variant("Item::Import", n, arena),
        }
    }

    fn visit_lit_expr(&mut self, node: Index<LitExpr>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("LitExpr")?
            .field("span", node.span)?
            .lit_value("value", &node.value)?
            .end_struct()
    }

    fn visit_loop_stmt(&mut self, node: Index<LoopStatement>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("LoopStatement")?
            .field("span", node.span)?
            .field("label", node.label)?
            .forward("body", node.body, arena)?
            .end_struct()
    }

    fn visit_member_expr(&mut self, node: Index<MemberExpr>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("MemberExpr")?
            .field("span", node.span)?
            .forward("base", node.base, arena)?
            .field("op_span", node.op_span)?
            .field("name", node.name)?
            .optional("parameters", node.parameters, arena)?
            .end_struct()
    }

    fn visit_module(&mut self, node: Index<Module>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("Module")?
            .field("file", node.file)?
            .slice("items", node.items, arena)?
            .end_struct()
    }

    fn visit_module_stmt(&mut self, node: Index<ModuleStatement>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("ModuleStatement")?
            .field("span", node.span)?
            .field("name", node.name)?
            .field("path", node.path)?
            .end_struct()
    }

    fn visit_object_expr(&mut self, node: Index<ObjectExpr>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("ObjectExpr")?
            .field("span", node.span)?
            .forward("base", node.base, arena)?
            .field("quote_span", node.quote_span)?
            .slice("fields", node.fields, arena)?
            .end_struct()
    }

    fn visit_object_expr_field(&mut self, node: Index<ObjectExprField>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("ObjectExprField")?
            .field("span", node.span)?
            .field("name", node.name)?
            .forward("value", node.value, arena)?
            .end_struct()
    }

    fn visit_paren_expr(&mut self, node: Index<ParenExpr>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("ParenExpr")?
            .field("span", node.span)?
            .forward("base", node.base, arena)?
            .end_struct()
    }

    fn visit_path(&mut self, node: Index<Path>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("Path")?
            .field("span", node.span)?
            .slice("segments", node.segments, arena)?
            .end_struct()
    }

    fn visit_path_segment(&mut self, node: PathSegment, arena: &Arena) -> Self::Result {
        match node {
            PathSegment::Global => EmptyResult(self.0.write_str("PathSegment::Global").is_ok()),
            PathSegment::Simple(n) => self.variant("PathSegment::Simple", n, arena),
            PathSegment::Cast(n) => self.variant("PathSegment::Cast", n, arena),
            PathSegment::Generic(n) => self.variant("PathSegment::Generic", n, arena),
        }
    }

    fn visit_primitive_type(&mut self, node: Index<PrimitiveType>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("PrimitiveType")?
            .field("span", node.span)?
            .field("base", node.base)?
            .end_struct()
    }

    fn visit_range_both_expr(&mut self, node: Index<RangeBothExpr>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("RangeBothExpr")?
            .field("span", node.span)?
            .forward("left", node.left, arena)?
            .field("op_span", node.op_span)?
            .forward("right", node.right, arena)?
            .end_struct()
    }

    fn visit_range_full_expr(&mut self, node: Index<RangeFullExpr>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("RangeFullExpr")?
            .field("span", node.span)?
            .end_struct()
    }

    fn visit_range_left_expr(&mut self, node: Index<RangeLeftExpr>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("RangeLeftExpr")?
            .field("span", node.span)?
            .forward("base", node.base, arena)?
            .end_struct()
    }

    fn visit_range_right_expr(&mut self, node: Index<RangeRightExpr>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("RangeRightExpr")?
            .field("span", node.span)?
            .forward("base", node.base, arena)?
            .end_struct()
    }

    fn visit_ref_type(&mut self, node: Index<RefType>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("RefType")?
            .field("span", node.span)?
            .forward("base", node.base, arena)?
            .end_struct()
    }

    fn visit_ret_stmt(&mut self, node: Index<ReturnStatement>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("ReturnStatement")?
            .field("span", node.span)?
            .optional("value", node.value, arena)?
            .end_struct()
    }

    fn visit_simple_expr_stmt(&mut self, node: Index<SimpleExprStatement>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("SimpleExprStatement")?
            .field("span", node.span)?
            .forward("expr", node.expr, arena)?
            .end_struct()
    }

    fn visit_simple_segment(&mut self, node: Index<SimpleSegment>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("SimpleSegment")?
            .field("span", node.span)?
            .field("name", node.name)?
            .end_struct()
    }

    fn visit_stmt(&mut self, node: Statement, arena: &Arena) -> Self::Result {
        match node {
            Statement::Struct(n) => self.variant("Statement::Struct", n, arena),
            Statement::Enum(n) => self.variant("Statement::Enum", n, arena),
            Statement::Fn(n) => self.variant("Statement::Fn", n, arena),
            Statement::Impl(n) => self.variant("Statement::Impl", n, arena),
            Statement::Type(n) => self.variant("Statement::Type", n, arena),
            Statement::Class(n) => self.variant("Statement::Class", n, arena),
            Statement::Block(n) => self.variant("Statement::Block", n, arena),
            Statement::Break(n) => self.variant("Statement::Break", n, arena),
            Statement::Continue(n) => self.variant("Statement::Continue", n, arena),
            Statement::SimpleExpr(n) => self.variant("Statement::SimpleExpr", n, arena),
            Statement::AssignExpr(n) => self.variant("Statement::AssignExpr", n, arena),
            Statement::For(n) => self.variant("Statement::For", n, arena),
            Statement::If(n) => self.variant("Statement::If", n, arena),
            Statement::Loop(n) => self.variant("Statement::Loop", n, arena),
            Statement::Return(n) => self.variant("Statement::Return", n, arena),
            Statement::VarDecl(n) => self.variant("Statement::VarDecl", n, arena),
            Statement::While(n) => self.variant("Statement::While", n, arena),
            Statement::Use(n) => self.variant("Statement::Use", n, arena),
        }
    }

    fn visit_struct_def(&mut self, node: Index<StructDef>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("StructDef")?
            .field("span", node.span)?
            .forward("name", node.name, arena)?
            .slice("fields", node.fields, arena)?
            .end_struct()
    }

    fn visit_tuple_expr(&mut self, node: Index<TupleExpr>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("TupleExpr")?
            .field("span", node.span)?
            .slice("items", node.items, arena)?
            .end_struct()
    }

    fn visit_tuple_index_expr(&mut self, node: Index<TupleIndexExpr>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("TupleIndexExpr")?
            .field("span", node.span)?
            .forward("base", node.base, arena)?
            .field("op_span", node.op_span)?
            .field("value", node.value)?
            .field("value_span", node.value_span)?
            .end_struct()
    }

    fn visit_tuple_type(&mut self, node: Index<TupleType>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("TupleType")?
            .field("span", node.span)?
            .slice("parameters", node.parameters, arena)?
            .end_struct()
    }

    fn visit_type_def(&mut self, node: Index<TypeDef>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("TypeDef")?
            .field("span", node.span)?
            .forward("name", node.name, arena)?
            .optional("from", node.from, arena)?
            .end_struct()
    }

    fn visit_type_list(&mut self, node: Index<TypeList>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("TypeList")?
            .field("span", node.span)?
            .slice("items", node.items, arena)?
            .end_struct()
    }

    fn visit_type_ref(&mut self, node: TypeRef, arena: &Arena) -> Self::Result {
        match node {
            TypeRef::Array(n) => self.variant("TypeRef::Array", n, arena),
            TypeRef::Fn(n) => self.variant("TypeRef::Fn", n, arena),
            TypeRef::Path(n) => self.variant("TypeRef::Path", n, arena),
            TypeRef::Primitive(n) => self.variant("TypeRef::Primitive", n, arena),
            TypeRef::Ref(n) => self.variant("TypeRef::Ref", n, arena),
            TypeRef::Tuple(n) => self.variant("TypeRef::Tuple", n, arena),
        }
    }

    fn visit_unary_expr(&mut self, node: Index<UnaryExpr>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("UnaryExpr")?
            .field("span", node.span)?
            .forward("base", node.base, arena)?
            .field("op", node.op)?
            .field("op_span", node.op_span)?
            .end_struct()
    }

    fn visit_use_stmt(&mut self, node: Index<UseStatement>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("UseStatement")?
            .field("span", node.span)?
            .forward("path", node.path, arena)?
            .field("alias", node.alias)?
            .end_struct()
    }

    fn visit_var_decl_stmt(&mut self, node: Index<VarDeclStatement>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("VarDeclStatement")?
            .field("span", node.span)?
            .field("r#const", node.r#const)?
            .field("name", node.name)?
            .optional("r#type", node.r#type, arena)?
            .optional("init_value", node.init_value, arena)?
            .end_struct()
    }

    fn visit_where_clause(&mut self, node: Index<WhereClause>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("WhereClause")?
            .field("span", node.span)?
            .field("name", node.name)?
            .slice("constraints", node.constraints, arena)?
            .end_struct()
    }

    fn visit_while_stmt(&mut self, node: Index<WhileStatement>, arena: &Arena) -> Self::Result {
        let (node, _guard) = self.enter(node, arena);
        self.start_struct("WhileStatement")?
            .field("span", node.span)?
            .field("label", node.label)?
            .forward("condition", node.condition, arena)?
            .forward("body", node.body, arena)?
            .end_struct()
    }
}
