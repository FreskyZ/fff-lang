///! ---------------------------------------------------------------------------------
///! This code is auto generated by a tool $repo/scripts/ast.py
///! Changes may cause incorrect behavior and will be lost if the code is regenerated.
///! ---------------------------------------------------------------------------------

// arena.emplace_* constructors
// this is THE actual SAFETY implementation described in Arena::emplace (not this <Arena as EmplaceConcreteHelper>::emplace)

use super::*;

// pub: rust require this to be pub if that pub trait "inherits" this, but does not require reexport in ast.rs
pub trait EmplaceConcreteHelper {
    fn emplace<T, F: FnOnce(&mut T)>(&self, init: F) -> Index<T> where T: Sized;
    fn build_slice<'a, T: 'a>(&'a self, indices: Vec<T>) -> Slice<T>;
}

impl EmplaceConcreteHelper for Arena {
    // // amazingly rustc correctly resolve this
    fn emplace<T, F: FnOnce(&mut T)>(&self, init: F) -> Index<T> where T: Sized {
        self.emplace(init)
    }
    fn build_slice<'a, T: 'a>(&'a self, indices: Vec<T>) -> Slice<T> {
        self.build_slice(indices)
    }
}

// AUTOGEN
impl From<Index<LitExpr>> for Expr {
    fn from(index: Index<LitExpr>) -> Self {
        Expr::Lit(index)
    }
}

impl From<Index<Path>> for Expr {
    fn from(index: Index<Path>) -> Self {
        Expr::Path(index)
    }
}

impl From<Index<ParenExpr>> for Expr {
    fn from(index: Index<ParenExpr>) -> Self {
        Expr::Paren(index)
    }
}

impl From<Index<TupleExpr>> for Expr {
    fn from(index: Index<TupleExpr>) -> Self {
        Expr::Tuple(index)
    }
}

impl From<Index<ArrayExpr>> for Expr {
    fn from(index: Index<ArrayExpr>) -> Self {
        Expr::Array(index)
    }
}

impl From<Index<CallExpr>> for Expr {
    fn from(index: Index<CallExpr>) -> Self {
        Expr::Call(index)
    }
}

impl From<Index<ArrayIndexExpr>> for Expr {
    fn from(index: Index<ArrayIndexExpr>) -> Self {
        Expr::ArrayIndex(index)
    }
}

impl From<Index<TupleIndexExpr>> for Expr {
    fn from(index: Index<TupleIndexExpr>) -> Self {
        Expr::TupleIndex(index)
    }
}

impl From<Index<MemberExpr>> for Expr {
    fn from(index: Index<MemberExpr>) -> Self {
        Expr::Member(index)
    }
}

impl From<Index<ObjectExpr>> for Expr {
    fn from(index: Index<ObjectExpr>) -> Self {
        Expr::Object(index)
    }
}

impl From<Index<UnaryExpr>> for Expr {
    fn from(index: Index<UnaryExpr>) -> Self {
        Expr::Unary(index)
    }
}

impl From<Index<BinaryExpr>> for Expr {
    fn from(index: Index<BinaryExpr>) -> Self {
        Expr::Binary(index)
    }
}

impl From<Index<RangeBothExpr>> for Expr {
    fn from(index: Index<RangeBothExpr>) -> Self {
        Expr::RangeBoth(index)
    }
}

impl From<Index<RangeFullExpr>> for Expr {
    fn from(index: Index<RangeFullExpr>) -> Self {
        Expr::RangeFull(index)
    }
}

impl From<Index<RangeLeftExpr>> for Expr {
    fn from(index: Index<RangeLeftExpr>) -> Self {
        Expr::RangeLeft(index)
    }
}

impl From<Index<RangeRightExpr>> for Expr {
    fn from(index: Index<RangeRightExpr>) -> Self {
        Expr::RangeRight(index)
    }
}

impl From<Index<StructDef>> for Item {
    fn from(index: Index<StructDef>) -> Self {
        Item::Struct(index)
    }
}

impl From<Index<EnumDef>> for Item {
    fn from(index: Index<EnumDef>) -> Self {
        Item::Enum(index)
    }
}

impl From<Index<FnDef>> for Item {
    fn from(index: Index<FnDef>) -> Self {
        Item::Fn(index)
    }
}

impl From<Index<Implementation>> for Item {
    fn from(index: Index<Implementation>) -> Self {
        Item::Impl(index)
    }
}

impl From<Index<TypeDef>> for Item {
    fn from(index: Index<TypeDef>) -> Self {
        Item::Type(index)
    }
}

impl From<Index<ClassDef>> for Item {
    fn from(index: Index<ClassDef>) -> Self {
        Item::Class(index)
    }
}

impl From<Index<BlockStatement>> for Item {
    fn from(index: Index<BlockStatement>) -> Self {
        Item::Block(index)
    }
}

impl From<Index<SimpleExprStatement>> for Item {
    fn from(index: Index<SimpleExprStatement>) -> Self {
        Item::SimpleExpr(index)
    }
}

impl From<Index<AssignExprStatement>> for Item {
    fn from(index: Index<AssignExprStatement>) -> Self {
        Item::AssignExpr(index)
    }
}

impl From<Index<ForStatement>> for Item {
    fn from(index: Index<ForStatement>) -> Self {
        Item::For(index)
    }
}

impl From<Index<IfStatement>> for Item {
    fn from(index: Index<IfStatement>) -> Self {
        Item::If(index)
    }
}

impl From<Index<LoopStatement>> for Item {
    fn from(index: Index<LoopStatement>) -> Self {
        Item::Loop(index)
    }
}

impl From<Index<VarDeclStatement>> for Item {
    fn from(index: Index<VarDeclStatement>) -> Self {
        Item::VarDecl(index)
    }
}

impl From<Index<WhileStatement>> for Item {
    fn from(index: Index<WhileStatement>) -> Self {
        Item::While(index)
    }
}

impl From<Index<UseStatement>> for Item {
    fn from(index: Index<UseStatement>) -> Self {
        Item::Use(index)
    }
}

impl From<Index<ModuleStatement>> for Item {
    fn from(index: Index<ModuleStatement>) -> Self {
        Item::Import(index)
    }
}

impl From<Index<SimpleSegment>> for PathSegment {
    fn from(index: Index<SimpleSegment>) -> Self {
        PathSegment::Simple(index)
    }
}

impl From<Index<CastSegment>> for PathSegment {
    fn from(index: Index<CastSegment>) -> Self {
        PathSegment::Cast(index)
    }
}

impl From<Index<GenericSegment>> for PathSegment {
    fn from(index: Index<GenericSegment>) -> Self {
        PathSegment::Generic(index)
    }
}

impl From<Index<StructDef>> for Statement {
    fn from(index: Index<StructDef>) -> Self {
        Statement::Struct(index)
    }
}

impl From<Index<EnumDef>> for Statement {
    fn from(index: Index<EnumDef>) -> Self {
        Statement::Enum(index)
    }
}

impl From<Index<FnDef>> for Statement {
    fn from(index: Index<FnDef>) -> Self {
        Statement::Fn(index)
    }
}

impl From<Index<Implementation>> for Statement {
    fn from(index: Index<Implementation>) -> Self {
        Statement::Impl(index)
    }
}

impl From<Index<TypeDef>> for Statement {
    fn from(index: Index<TypeDef>) -> Self {
        Statement::Type(index)
    }
}

impl From<Index<ClassDef>> for Statement {
    fn from(index: Index<ClassDef>) -> Self {
        Statement::Class(index)
    }
}

impl From<Index<BlockStatement>> for Statement {
    fn from(index: Index<BlockStatement>) -> Self {
        Statement::Block(index)
    }
}

impl From<Index<BreakStatement>> for Statement {
    fn from(index: Index<BreakStatement>) -> Self {
        Statement::Break(index)
    }
}

impl From<Index<ContinueStatement>> for Statement {
    fn from(index: Index<ContinueStatement>) -> Self {
        Statement::Continue(index)
    }
}

impl From<Index<SimpleExprStatement>> for Statement {
    fn from(index: Index<SimpleExprStatement>) -> Self {
        Statement::SimpleExpr(index)
    }
}

impl From<Index<AssignExprStatement>> for Statement {
    fn from(index: Index<AssignExprStatement>) -> Self {
        Statement::AssignExpr(index)
    }
}

impl From<Index<ForStatement>> for Statement {
    fn from(index: Index<ForStatement>) -> Self {
        Statement::For(index)
    }
}

impl From<Index<IfStatement>> for Statement {
    fn from(index: Index<IfStatement>) -> Self {
        Statement::If(index)
    }
}

impl From<Index<LoopStatement>> for Statement {
    fn from(index: Index<LoopStatement>) -> Self {
        Statement::Loop(index)
    }
}

impl From<Index<ReturnStatement>> for Statement {
    fn from(index: Index<ReturnStatement>) -> Self {
        Statement::Return(index)
    }
}

impl From<Index<VarDeclStatement>> for Statement {
    fn from(index: Index<VarDeclStatement>) -> Self {
        Statement::VarDecl(index)
    }
}

impl From<Index<WhileStatement>> for Statement {
    fn from(index: Index<WhileStatement>) -> Self {
        Statement::While(index)
    }
}

impl From<Index<UseStatement>> for Statement {
    fn from(index: Index<UseStatement>) -> Self {
        Statement::Use(index)
    }
}

impl From<Index<ArrayType>> for TypeRef {
    fn from(index: Index<ArrayType>) -> Self {
        TypeRef::Array(index)
    }
}

impl From<Index<FnType>> for TypeRef {
    fn from(index: Index<FnType>) -> Self {
        TypeRef::Fn(index)
    }
}

impl From<Index<Path>> for TypeRef {
    fn from(index: Index<Path>) -> Self {
        TypeRef::Path(index)
    }
}

impl From<Index<PrimitiveType>> for TypeRef {
    fn from(index: Index<PrimitiveType>) -> Self {
        TypeRef::Primitive(index)
    }
}

impl From<Index<RefType>> for TypeRef {
    fn from(index: Index<RefType>) -> Self {
        TypeRef::Ref(index)
    }
}

impl From<Index<TupleType>> for TypeRef {
    fn from(index: Index<TupleType>) -> Self {
        TypeRef::Tuple(index)
    }
}
pub trait EmplaceConcrete: EmplaceConcreteHelper {

    fn emplace_array_expr(
        &self,
        span: Span,
        items: Vec<Expr>,
    ) -> Index<ArrayExpr>;

    fn emplace_array_index_expr(
        &self,
        span: Span,
        base: Expr,
        parameters: Vec<Expr>,
        quote_span: Span,
    ) -> Index<ArrayIndexExpr>;

    fn emplace_array_type(
        &self,
        span: Span,
        base: TypeRef,
        size: Expr,
    ) -> Index<ArrayType>;

    fn emplace_assign_expr_stmt(
        &self,
        span: Span,
        left: Expr,
        right: Expr,
        op: Separator,
        op_span: Span,
    ) -> Index<AssignExprStatement>;

    fn emplace_binary_expr(
        &self,
        span: Span,
        left: Expr,
        right: Expr,
        op: Separator,
        op_span: Span,
    ) -> Index<BinaryExpr>;

    fn emplace_block(
        &self,
        span: Span,
        items: Vec<Statement>,
    ) -> Index<Block>;

    fn emplace_block_stmt(
        &self,
        span: Span,
        label: Option<IdSpan>,
        body: Index<Block>,
    ) -> Index<BlockStatement>;

    fn emplace_break_stmt(
        &self,
        span: Span,
        label: Option<IdSpan>,
    ) -> Index<BreakStatement>;

    fn emplace_call_expr(
        &self,
        span: Span,
        base: Expr,
        quote_span: Span,
        parameters: Vec<Expr>,
    ) -> Index<CallExpr>;

    fn emplace_cast_segment(
        &self,
        span: Span,
        left: TypeRef,
        right: TypeRef,
    ) -> Index<CastSegment>;

    fn emplace_class_def(
        &self,
        span: Span,
        name: Index<GenericName>,
        quote_span: Span,
        items: Vec<Item>,
    ) -> Index<ClassDef>;

    fn emplace_continue_stmt(
        &self,
        span: Span,
        label: Option<IdSpan>,
    ) -> Index<ContinueStatement>;

    fn emplace_else_clause(
        &self,
        span: Span,
        body: Index<Block>,
    ) -> Index<ElseClause>;

    fn emplace_enum_def(
        &self,
        span: Span,
        name: IdSpan,
        base_type: Option<Index<PrimitiveType>>,
        quote_span: Span,
        variants: Vec<Index<EnumDefVariant>>,
    ) -> Index<EnumDef>;

    fn emplace_enum_def_variant(
        &self,
        span: Span,
        name: IdSpan,
        value: Option<Expr>,
    ) -> Index<EnumDefVariant>;

    fn emplace_field_def(
        &self,
        span: Span,
        name: IdSpan,
        colon_span: Span,
        r#type: TypeRef,
    ) -> Index<FieldDef>;

    fn emplace_fn_def(
        &self,
        span: Span,
        name: Index<GenericName>,
        quote_span: Span,
        parameters: Vec<Index<FnDefParameter>>,
        ret_type: Option<TypeRef>,
        wheres: Vec<Index<WhereClause>>,
        body: Option<Index<Block>>,
    ) -> Index<FnDef>;

    fn emplace_fn_def_parameter(
        &self,
        span: Span,
        name: IdSpan,
        r#type: TypeRef,
    ) -> Index<FnDefParameter>;

    fn emplace_fn_type(
        &self,
        span: Span,
        quote_span: Span,
        parameters: Vec<Index<FnTypeParameter>>,
        ret_type: Option<TypeRef>,
    ) -> Index<FnType>;

    fn emplace_fn_type_parameter(
        &self,
        span: Span,
        name: Option<IdSpan>,
        r#type: TypeRef,
    ) -> Index<FnTypeParameter>;

    fn emplace_for_stmt(
        &self,
        span: Span,
        label: Option<IdSpan>,
        iter_name: IdSpan,
        iter_expr: Expr,
        body: Index<Block>,
    ) -> Index<ForStatement>;

    fn emplace_generic_name(
        &self,
        span: Span,
        base: IdSpan,
        quote_span: Span,
        parameters: Vec<Index<GenericParameter>>,
    ) -> Index<GenericName>;

    fn emplace_generic_parameter(
        &self,
        span: Span,
        name: IdSpan,
    ) -> Index<GenericParameter>;

    fn emplace_generic_segment(
        &self,
        span: Span,
        base: IdSpan,
        parameters: Index<TypeList>,
    ) -> Index<GenericSegment>;

    fn emplace_if_clause(
        &self,
        span: Span,
        condition: Expr,
        body: Index<Block>,
    ) -> Index<IfClause>;

    fn emplace_if_stmt(
        &self,
        span: Span,
        if_clause: Index<IfClause>,
        elseif_clauses: Vec<Index<IfClause>>,
        else_clause: Option<Index<ElseClause>>,
    ) -> Index<IfStatement>;

    fn emplace_impl_block(
        &self,
        span: Span,
        parameters: Vec<Index<GenericParameter>>,
        class: Option<TypeRef>,
        r#type: TypeRef,
        wheres: Vec<Index<WhereClause>>,
        quote_span: Span,
        items: Vec<Item>,
    ) -> Index<Implementation>;

    fn emplace_lit_expr(
        &self,
        span: Span,
        value: LitValue,
    ) -> Index<LitExpr>;

    fn emplace_loop_stmt(
        &self,
        span: Span,
        label: Option<IdSpan>,
        body: Index<Block>,
    ) -> Index<LoopStatement>;

    fn emplace_member_expr(
        &self,
        span: Span,
        base: Expr,
        op_span: Span,
        name: IdSpan,
        parameters: Option<Index<TypeList>>,
    ) -> Index<MemberExpr>;

    fn emplace_module(
        &self,
        file: FileId,
        items: Vec<Item>,
    ) -> Index<Module>;

    fn emplace_module_stmt(
        &self,
        span: Span,
        name: IdSpan,
        path: Option<IdSpan>,
    ) -> Index<ModuleStatement>;

    fn emplace_object_expr(
        &self,
        span: Span,
        base: Expr,
        quote_span: Span,
        fields: Vec<Index<ObjectExprField>>,
    ) -> Index<ObjectExpr>;

    fn emplace_object_expr_field(
        &self,
        span: Span,
        name: IdSpan,
        value: Expr,
    ) -> Index<ObjectExprField>;

    fn emplace_paren_expr(
        &self,
        span: Span,
        base: Expr,
    ) -> Index<ParenExpr>;

    fn emplace_path(
        &self,
        span: Span,
        segments: Vec<PathSegment>,
    ) -> Index<Path>;

    fn emplace_primitive_type(
        &self,
        span: Span,
        base: Keyword,
    ) -> Index<PrimitiveType>;

    fn emplace_range_both_expr(
        &self,
        span: Span,
        left: Expr,
        op_span: Span,
        right: Expr,
    ) -> Index<RangeBothExpr>;

    fn emplace_range_full_expr(
        &self,
        span: Span,
    ) -> Index<RangeFullExpr>;

    fn emplace_range_left_expr(
        &self,
        span: Span,
        base: Expr,
    ) -> Index<RangeLeftExpr>;

    fn emplace_range_right_expr(
        &self,
        span: Span,
        base: Expr,
    ) -> Index<RangeRightExpr>;

    fn emplace_ref_type(
        &self,
        span: Span,
        base: TypeRef,
    ) -> Index<RefType>;

    fn emplace_ret_stmt(
        &self,
        span: Span,
        value: Option<Expr>,
    ) -> Index<ReturnStatement>;

    fn emplace_simple_expr_stmt(
        &self,
        span: Span,
        expr: Expr,
    ) -> Index<SimpleExprStatement>;

    fn emplace_simple_segment(
        &self,
        span: Span,
        name: IsId,
    ) -> Index<SimpleSegment>;

    fn emplace_struct_def(
        &self,
        span: Span,
        name: Index<GenericName>,
        fields: Vec<Index<FieldDef>>,
    ) -> Index<StructDef>;

    fn emplace_tuple_expr(
        &self,
        span: Span,
        items: Vec<Expr>,
    ) -> Index<TupleExpr>;

    fn emplace_tuple_index_expr(
        &self,
        span: Span,
        base: Expr,
        op_span: Span,
        value: i32,
        value_span: Span,
    ) -> Index<TupleIndexExpr>;

    fn emplace_tuple_type(
        &self,
        span: Span,
        parameters: Vec<TypeRef>,
    ) -> Index<TupleType>;

    fn emplace_type_def(
        &self,
        span: Span,
        name: Index<GenericName>,
        from: Option<TypeRef>,
    ) -> Index<TypeDef>;

    fn emplace_type_list(
        &self,
        span: Span,
        items: Vec<TypeRef>,
    ) -> Index<TypeList>;

    fn emplace_unary_expr(
        &self,
        span: Span,
        base: Expr,
        op: Separator,
        op_span: Span,
    ) -> Index<UnaryExpr>;

    fn emplace_use_stmt(
        &self,
        span: Span,
        path: Index<Path>,
        alias: Option<IdSpan>,
    ) -> Index<UseStatement>;

    fn emplace_var_decl_stmt(
        &self,
        span: Span,
        r#const: bool,
        name: IdSpan,
        r#type: Option<TypeRef>,
        init_value: Option<Expr>,
    ) -> Index<VarDeclStatement>;

    fn emplace_where_clause(
        &self,
        span: Span,
        name: IdSpan,
        constraints: Vec<TypeRef>,
    ) -> Index<WhereClause>;

    fn emplace_while_stmt(
        &self,
        span: Span,
        label: Option<IdSpan>,
        condition: Expr,
        body: Index<Block>,
    ) -> Index<WhileStatement>;
}

impl EmplaceConcrete for Arena {

    #[inline]
    fn emplace_array_expr(
        &self,
        span: Span,
        items: Vec<Expr>,
    ) -> Index<ArrayExpr> {
        let items = self.build_slice(items);
        self.emplace(|n: &mut ArrayExpr| {
            n.span = span;
            n.items = items;
        })
    }

    #[inline]
    fn emplace_array_index_expr(
        &self,
        span: Span,
        base: Expr,
        parameters: Vec<Expr>,
        quote_span: Span,
    ) -> Index<ArrayIndexExpr> {
        let parameters = self.build_slice(parameters);
        self.emplace(|n: &mut ArrayIndexExpr| {
            n.span = span;
            n.base = base;
            n.parameters = parameters;
            n.quote_span = quote_span;
        })
    }

    #[inline]
    fn emplace_array_type(
        &self,
        span: Span,
        base: TypeRef,
        size: Expr,
    ) -> Index<ArrayType> {
        self.emplace(|n: &mut ArrayType| {
            n.span = span;
            n.base = base;
            n.size = size;
        })
    }

    #[inline]
    fn emplace_assign_expr_stmt(
        &self,
        span: Span,
        left: Expr,
        right: Expr,
        op: Separator,
        op_span: Span,
    ) -> Index<AssignExprStatement> {
        self.emplace(|n: &mut AssignExprStatement| {
            n.span = span;
            n.left = left;
            n.right = right;
            n.op = op;
            n.op_span = op_span;
        })
    }

    #[inline]
    fn emplace_binary_expr(
        &self,
        span: Span,
        left: Expr,
        right: Expr,
        op: Separator,
        op_span: Span,
    ) -> Index<BinaryExpr> {
        self.emplace(|n: &mut BinaryExpr| {
            n.span = span;
            n.left = left;
            n.right = right;
            n.op = op;
            n.op_span = op_span;
        })
    }

    #[inline]
    fn emplace_block(
        &self,
        span: Span,
        items: Vec<Statement>,
    ) -> Index<Block> {
        let items = self.build_slice(items);
        self.emplace(|n: &mut Block| {
            n.span = span;
            n.items = items;
        })
    }

    #[inline]
    fn emplace_block_stmt(
        &self,
        span: Span,
        label: Option<IdSpan>,
        body: Index<Block>,
    ) -> Index<BlockStatement> {
        self.emplace(|n: &mut BlockStatement| {
            n.span = span;
            n.label = label;
            n.body = body;
        })
    }

    #[inline]
    fn emplace_break_stmt(
        &self,
        span: Span,
        label: Option<IdSpan>,
    ) -> Index<BreakStatement> {
        self.emplace(|n: &mut BreakStatement| {
            n.span = span;
            n.label = label;
        })
    }

    #[inline]
    fn emplace_call_expr(
        &self,
        span: Span,
        base: Expr,
        quote_span: Span,
        parameters: Vec<Expr>,
    ) -> Index<CallExpr> {
        let parameters = self.build_slice(parameters);
        self.emplace(|n: &mut CallExpr| {
            n.span = span;
            n.base = base;
            n.quote_span = quote_span;
            n.parameters = parameters;
        })
    }

    #[inline]
    fn emplace_cast_segment(
        &self,
        span: Span,
        left: TypeRef,
        right: TypeRef,
    ) -> Index<CastSegment> {
        self.emplace(|n: &mut CastSegment| {
            n.span = span;
            n.left = left;
            n.right = right;
        })
    }

    #[inline]
    fn emplace_class_def(
        &self,
        span: Span,
        name: Index<GenericName>,
        quote_span: Span,
        items: Vec<Item>,
    ) -> Index<ClassDef> {
        let items = self.build_slice(items);
        self.emplace(|n: &mut ClassDef| {
            n.span = span;
            n.name = name;
            n.quote_span = quote_span;
            n.items = items;
        })
    }

    #[inline]
    fn emplace_continue_stmt(
        &self,
        span: Span,
        label: Option<IdSpan>,
    ) -> Index<ContinueStatement> {
        self.emplace(|n: &mut ContinueStatement| {
            n.span = span;
            n.label = label;
        })
    }

    #[inline]
    fn emplace_else_clause(
        &self,
        span: Span,
        body: Index<Block>,
    ) -> Index<ElseClause> {
        self.emplace(|n: &mut ElseClause| {
            n.span = span;
            n.body = body;
        })
    }

    #[inline]
    fn emplace_enum_def(
        &self,
        span: Span,
        name: IdSpan,
        base_type: Option<Index<PrimitiveType>>,
        quote_span: Span,
        variants: Vec<Index<EnumDefVariant>>,
    ) -> Index<EnumDef> {
        let variants = self.build_slice(variants);
        self.emplace(|n: &mut EnumDef| {
            n.span = span;
            n.name = name;
            n.base_type = base_type;
            n.quote_span = quote_span;
            n.variants = variants;
        })
    }

    #[inline]
    fn emplace_enum_def_variant(
        &self,
        span: Span,
        name: IdSpan,
        value: Option<Expr>,
    ) -> Index<EnumDefVariant> {
        self.emplace(|n: &mut EnumDefVariant| {
            n.span = span;
            n.name = name;
            n.value = value;
        })
    }

    #[inline]
    fn emplace_field_def(
        &self,
        span: Span,
        name: IdSpan,
        colon_span: Span,
        r#type: TypeRef,
    ) -> Index<FieldDef> {
        self.emplace(|n: &mut FieldDef| {
            n.span = span;
            n.name = name;
            n.colon_span = colon_span;
            n.r#type = r#type;
        })
    }

    #[inline]
    fn emplace_fn_def(
        &self,
        span: Span,
        name: Index<GenericName>,
        quote_span: Span,
        parameters: Vec<Index<FnDefParameter>>,
        ret_type: Option<TypeRef>,
        wheres: Vec<Index<WhereClause>>,
        body: Option<Index<Block>>,
    ) -> Index<FnDef> {
        let parameters = self.build_slice(parameters);
        let wheres = self.build_slice(wheres);
        self.emplace(|n: &mut FnDef| {
            n.span = span;
            n.name = name;
            n.quote_span = quote_span;
            n.parameters = parameters;
            n.ret_type = ret_type;
            n.wheres = wheres;
            n.body = body;
        })
    }

    #[inline]
    fn emplace_fn_def_parameter(
        &self,
        span: Span,
        name: IdSpan,
        r#type: TypeRef,
    ) -> Index<FnDefParameter> {
        self.emplace(|n: &mut FnDefParameter| {
            n.span = span;
            n.name = name;
            n.r#type = r#type;
        })
    }

    #[inline]
    fn emplace_fn_type(
        &self,
        span: Span,
        quote_span: Span,
        parameters: Vec<Index<FnTypeParameter>>,
        ret_type: Option<TypeRef>,
    ) -> Index<FnType> {
        let parameters = self.build_slice(parameters);
        self.emplace(|n: &mut FnType| {
            n.span = span;
            n.quote_span = quote_span;
            n.parameters = parameters;
            n.ret_type = ret_type;
        })
    }

    #[inline]
    fn emplace_fn_type_parameter(
        &self,
        span: Span,
        name: Option<IdSpan>,
        r#type: TypeRef,
    ) -> Index<FnTypeParameter> {
        self.emplace(|n: &mut FnTypeParameter| {
            n.span = span;
            n.name = name;
            n.r#type = r#type;
        })
    }

    #[inline]
    fn emplace_for_stmt(
        &self,
        span: Span,
        label: Option<IdSpan>,
        iter_name: IdSpan,
        iter_expr: Expr,
        body: Index<Block>,
    ) -> Index<ForStatement> {
        self.emplace(|n: &mut ForStatement| {
            n.span = span;
            n.label = label;
            n.iter_name = iter_name;
            n.iter_expr = iter_expr;
            n.body = body;
        })
    }

    #[inline]
    fn emplace_generic_name(
        &self,
        span: Span,
        base: IdSpan,
        quote_span: Span,
        parameters: Vec<Index<GenericParameter>>,
    ) -> Index<GenericName> {
        let parameters = self.build_slice(parameters);
        self.emplace(|n: &mut GenericName| {
            n.span = span;
            n.base = base;
            n.quote_span = quote_span;
            n.parameters = parameters;
        })
    }

    #[inline]
    fn emplace_generic_parameter(
        &self,
        span: Span,
        name: IdSpan,
    ) -> Index<GenericParameter> {
        self.emplace(|n: &mut GenericParameter| {
            n.span = span;
            n.name = name;
        })
    }

    #[inline]
    fn emplace_generic_segment(
        &self,
        span: Span,
        base: IdSpan,
        parameters: Index<TypeList>,
    ) -> Index<GenericSegment> {
        self.emplace(|n: &mut GenericSegment| {
            n.span = span;
            n.base = base;
            n.parameters = parameters;
        })
    }

    #[inline]
    fn emplace_if_clause(
        &self,
        span: Span,
        condition: Expr,
        body: Index<Block>,
    ) -> Index<IfClause> {
        self.emplace(|n: &mut IfClause| {
            n.span = span;
            n.condition = condition;
            n.body = body;
        })
    }

    #[inline]
    fn emplace_if_stmt(
        &self,
        span: Span,
        if_clause: Index<IfClause>,
        elseif_clauses: Vec<Index<IfClause>>,
        else_clause: Option<Index<ElseClause>>,
    ) -> Index<IfStatement> {
        let elseif_clauses = self.build_slice(elseif_clauses);
        self.emplace(|n: &mut IfStatement| {
            n.span = span;
            n.if_clause = if_clause;
            n.elseif_clauses = elseif_clauses;
            n.else_clause = else_clause;
        })
    }

    #[inline]
    fn emplace_impl_block(
        &self,
        span: Span,
        parameters: Vec<Index<GenericParameter>>,
        class: Option<TypeRef>,
        r#type: TypeRef,
        wheres: Vec<Index<WhereClause>>,
        quote_span: Span,
        items: Vec<Item>,
    ) -> Index<Implementation> {
        let parameters = self.build_slice(parameters);
        let wheres = self.build_slice(wheres);
        let items = self.build_slice(items);
        self.emplace(|n: &mut Implementation| {
            n.span = span;
            n.parameters = parameters;
            n.class = class;
            n.r#type = r#type;
            n.wheres = wheres;
            n.quote_span = quote_span;
            n.items = items;
        })
    }

    #[inline]
    fn emplace_lit_expr(
        &self,
        span: Span,
        value: LitValue,
    ) -> Index<LitExpr> {
        self.emplace(|n: &mut LitExpr| {
            n.span = span;
            n.value = value;
        })
    }

    #[inline]
    fn emplace_loop_stmt(
        &self,
        span: Span,
        label: Option<IdSpan>,
        body: Index<Block>,
    ) -> Index<LoopStatement> {
        self.emplace(|n: &mut LoopStatement| {
            n.span = span;
            n.label = label;
            n.body = body;
        })
    }

    #[inline]
    fn emplace_member_expr(
        &self,
        span: Span,
        base: Expr,
        op_span: Span,
        name: IdSpan,
        parameters: Option<Index<TypeList>>,
    ) -> Index<MemberExpr> {
        self.emplace(|n: &mut MemberExpr| {
            n.span = span;
            n.base = base;
            n.op_span = op_span;
            n.name = name;
            n.parameters = parameters;
        })
    }

    #[inline]
    fn emplace_module(
        &self,
        file: FileId,
        items: Vec<Item>,
    ) -> Index<Module> {
        let items = self.build_slice(items);
        self.emplace(|n: &mut Module| {
            n.file = file;
            n.items = items;
        })
    }

    #[inline]
    fn emplace_module_stmt(
        &self,
        span: Span,
        name: IdSpan,
        path: Option<IdSpan>,
    ) -> Index<ModuleStatement> {
        self.emplace(|n: &mut ModuleStatement| {
            n.span = span;
            n.name = name;
            n.path = path;
        })
    }

    #[inline]
    fn emplace_object_expr(
        &self,
        span: Span,
        base: Expr,
        quote_span: Span,
        fields: Vec<Index<ObjectExprField>>,
    ) -> Index<ObjectExpr> {
        let fields = self.build_slice(fields);
        self.emplace(|n: &mut ObjectExpr| {
            n.span = span;
            n.base = base;
            n.quote_span = quote_span;
            n.fields = fields;
        })
    }

    #[inline]
    fn emplace_object_expr_field(
        &self,
        span: Span,
        name: IdSpan,
        value: Expr,
    ) -> Index<ObjectExprField> {
        self.emplace(|n: &mut ObjectExprField| {
            n.span = span;
            n.name = name;
            n.value = value;
        })
    }

    #[inline]
    fn emplace_paren_expr(
        &self,
        span: Span,
        base: Expr,
    ) -> Index<ParenExpr> {
        self.emplace(|n: &mut ParenExpr| {
            n.span = span;
            n.base = base;
        })
    }

    #[inline]
    fn emplace_path(
        &self,
        span: Span,
        segments: Vec<PathSegment>,
    ) -> Index<Path> {
        let segments = self.build_slice(segments);
        self.emplace(|n: &mut Path| {
            n.span = span;
            n.segments = segments;
        })
    }

    #[inline]
    fn emplace_primitive_type(
        &self,
        span: Span,
        base: Keyword,
    ) -> Index<PrimitiveType> {
        self.emplace(|n: &mut PrimitiveType| {
            n.span = span;
            n.base = base;
        })
    }

    #[inline]
    fn emplace_range_both_expr(
        &self,
        span: Span,
        left: Expr,
        op_span: Span,
        right: Expr,
    ) -> Index<RangeBothExpr> {
        self.emplace(|n: &mut RangeBothExpr| {
            n.span = span;
            n.left = left;
            n.op_span = op_span;
            n.right = right;
        })
    }

    #[inline]
    fn emplace_range_full_expr(
        &self,
        span: Span,
    ) -> Index<RangeFullExpr> {
        self.emplace(|n: &mut RangeFullExpr| {
            n.span = span;
        })
    }

    #[inline]
    fn emplace_range_left_expr(
        &self,
        span: Span,
        base: Expr,
    ) -> Index<RangeLeftExpr> {
        self.emplace(|n: &mut RangeLeftExpr| {
            n.span = span;
            n.base = base;
        })
    }

    #[inline]
    fn emplace_range_right_expr(
        &self,
        span: Span,
        base: Expr,
    ) -> Index<RangeRightExpr> {
        self.emplace(|n: &mut RangeRightExpr| {
            n.span = span;
            n.base = base;
        })
    }

    #[inline]
    fn emplace_ref_type(
        &self,
        span: Span,
        base: TypeRef,
    ) -> Index<RefType> {
        self.emplace(|n: &mut RefType| {
            n.span = span;
            n.base = base;
        })
    }

    #[inline]
    fn emplace_ret_stmt(
        &self,
        span: Span,
        value: Option<Expr>,
    ) -> Index<ReturnStatement> {
        self.emplace(|n: &mut ReturnStatement| {
            n.span = span;
            n.value = value;
        })
    }

    #[inline]
    fn emplace_simple_expr_stmt(
        &self,
        span: Span,
        expr: Expr,
    ) -> Index<SimpleExprStatement> {
        self.emplace(|n: &mut SimpleExprStatement| {
            n.span = span;
            n.expr = expr;
        })
    }

    #[inline]
    fn emplace_simple_segment(
        &self,
        span: Span,
        name: IsId,
    ) -> Index<SimpleSegment> {
        self.emplace(|n: &mut SimpleSegment| {
            n.span = span;
            n.name = name;
        })
    }

    #[inline]
    fn emplace_struct_def(
        &self,
        span: Span,
        name: Index<GenericName>,
        fields: Vec<Index<FieldDef>>,
    ) -> Index<StructDef> {
        let fields = self.build_slice(fields);
        self.emplace(|n: &mut StructDef| {
            n.span = span;
            n.name = name;
            n.fields = fields;
        })
    }

    #[inline]
    fn emplace_tuple_expr(
        &self,
        span: Span,
        items: Vec<Expr>,
    ) -> Index<TupleExpr> {
        let items = self.build_slice(items);
        self.emplace(|n: &mut TupleExpr| {
            n.span = span;
            n.items = items;
        })
    }

    #[inline]
    fn emplace_tuple_index_expr(
        &self,
        span: Span,
        base: Expr,
        op_span: Span,
        value: i32,
        value_span: Span,
    ) -> Index<TupleIndexExpr> {
        self.emplace(|n: &mut TupleIndexExpr| {
            n.span = span;
            n.base = base;
            n.op_span = op_span;
            n.value = value;
            n.value_span = value_span;
        })
    }

    #[inline]
    fn emplace_tuple_type(
        &self,
        span: Span,
        parameters: Vec<TypeRef>,
    ) -> Index<TupleType> {
        let parameters = self.build_slice(parameters);
        self.emplace(|n: &mut TupleType| {
            n.span = span;
            n.parameters = parameters;
        })
    }

    #[inline]
    fn emplace_type_def(
        &self,
        span: Span,
        name: Index<GenericName>,
        from: Option<TypeRef>,
    ) -> Index<TypeDef> {
        self.emplace(|n: &mut TypeDef| {
            n.span = span;
            n.name = name;
            n.from = from;
        })
    }

    #[inline]
    fn emplace_type_list(
        &self,
        span: Span,
        items: Vec<TypeRef>,
    ) -> Index<TypeList> {
        let items = self.build_slice(items);
        self.emplace(|n: &mut TypeList| {
            n.span = span;
            n.items = items;
        })
    }

    #[inline]
    fn emplace_unary_expr(
        &self,
        span: Span,
        base: Expr,
        op: Separator,
        op_span: Span,
    ) -> Index<UnaryExpr> {
        self.emplace(|n: &mut UnaryExpr| {
            n.span = span;
            n.base = base;
            n.op = op;
            n.op_span = op_span;
        })
    }

    #[inline]
    fn emplace_use_stmt(
        &self,
        span: Span,
        path: Index<Path>,
        alias: Option<IdSpan>,
    ) -> Index<UseStatement> {
        self.emplace(|n: &mut UseStatement| {
            n.span = span;
            n.path = path;
            n.alias = alias;
        })
    }

    #[inline]
    fn emplace_var_decl_stmt(
        &self,
        span: Span,
        r#const: bool,
        name: IdSpan,
        r#type: Option<TypeRef>,
        init_value: Option<Expr>,
    ) -> Index<VarDeclStatement> {
        self.emplace(|n: &mut VarDeclStatement| {
            n.span = span;
            n.r#const = r#const;
            n.name = name;
            n.r#type = r#type;
            n.init_value = init_value;
        })
    }

    #[inline]
    fn emplace_where_clause(
        &self,
        span: Span,
        name: IdSpan,
        constraints: Vec<TypeRef>,
    ) -> Index<WhereClause> {
        let constraints = self.build_slice(constraints);
        self.emplace(|n: &mut WhereClause| {
            n.span = span;
            n.name = name;
            n.constraints = constraints;
        })
    }

    #[inline]
    fn emplace_while_stmt(
        &self,
        span: Span,
        label: Option<IdSpan>,
        condition: Expr,
        body: Index<Block>,
    ) -> Index<WhileStatement> {
        self.emplace(|n: &mut WhileStatement| {
            n.span = span;
            n.label = label;
            n.condition = condition;
            n.body = body;
        })
    }
}
