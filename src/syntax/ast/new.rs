///! ---------------------------------------------------------------------------------
///! This code is auto generated by a tool $repo/scripts/ast.py
///! Changes may cause incorrect behavior and will be lost if the code is regenerated.
///! ---------------------------------------------------------------------------------

// arena.emplace_* constructors
// this is THE actual SAFETY implementation described in Arena::emplace (not this <Arena as EmplaceConcreteHelper>::emplace)

use super::*;

// pub: rust require this to be pub if that pub trait "inherits" this, but does not require reexport in ast.rs
pub trait EmplaceConcreteHelper {
    fn emplace<'a, T: 'a, F: FnOnce(&'a mut T)>(&'a self, init: F) -> Index<'a, T> where T: Sized;
    fn build_slice<'a, T: 'a>(&'a self, indices: Vec<T>) -> Slice<'a, T>;
}

impl EmplaceConcreteHelper for Arena {
    // // amazingly rustc correctly resolve this
    fn emplace<'a, T: 'a, F: FnOnce(&'a mut T)>(&'a self, init: F) -> Index<'a, T> where T: Sized {
        self.emplace(init)
    }
    fn build_slice<'a, T: 'a>(&'a self, indices: Vec<T>) -> Slice<'a, T> {
        self.build_slice(indices)
    }
}

// AUTOGEN
impl<'a> From<Index<'a, LitExpr>> for Expr<'a> {
    fn from(index: Index<'a, LitExpr>) -> Self {
        Expr::Lit(index)
    }
}

impl<'a> From<Index<'a, Path<'a>>> for Expr<'a> {
    fn from(index: Index<'a, Path<'a>>) -> Self {
        Expr::Path(index)
    }
}

impl<'a> From<Index<'a, ParenExpr<'a>>> for Expr<'a> {
    fn from(index: Index<'a, ParenExpr<'a>>) -> Self {
        Expr::Paren(index)
    }
}

impl<'a> From<Index<'a, TupleExpr<'a>>> for Expr<'a> {
    fn from(index: Index<'a, TupleExpr<'a>>) -> Self {
        Expr::Tuple(index)
    }
}

impl<'a> From<Index<'a, ArrayExpr<'a>>> for Expr<'a> {
    fn from(index: Index<'a, ArrayExpr<'a>>) -> Self {
        Expr::Array(index)
    }
}

impl<'a> From<Index<'a, CallExpr<'a>>> for Expr<'a> {
    fn from(index: Index<'a, CallExpr<'a>>) -> Self {
        Expr::Call(index)
    }
}

impl<'a> From<Index<'a, ArrayIndexExpr<'a>>> for Expr<'a> {
    fn from(index: Index<'a, ArrayIndexExpr<'a>>) -> Self {
        Expr::ArrayIndex(index)
    }
}

impl<'a> From<Index<'a, TupleIndexExpr<'a>>> for Expr<'a> {
    fn from(index: Index<'a, TupleIndexExpr<'a>>) -> Self {
        Expr::TupleIndex(index)
    }
}

impl<'a> From<Index<'a, MemberExpr<'a>>> for Expr<'a> {
    fn from(index: Index<'a, MemberExpr<'a>>) -> Self {
        Expr::Member(index)
    }
}

impl<'a> From<Index<'a, ObjectExpr<'a>>> for Expr<'a> {
    fn from(index: Index<'a, ObjectExpr<'a>>) -> Self {
        Expr::Object(index)
    }
}

impl<'a> From<Index<'a, UnaryExpr<'a>>> for Expr<'a> {
    fn from(index: Index<'a, UnaryExpr<'a>>) -> Self {
        Expr::Unary(index)
    }
}

impl<'a> From<Index<'a, BinaryExpr<'a>>> for Expr<'a> {
    fn from(index: Index<'a, BinaryExpr<'a>>) -> Self {
        Expr::Binary(index)
    }
}

impl<'a> From<Index<'a, RangeBothExpr<'a>>> for Expr<'a> {
    fn from(index: Index<'a, RangeBothExpr<'a>>) -> Self {
        Expr::RangeBoth(index)
    }
}

impl<'a> From<Index<'a, RangeFullExpr>> for Expr<'a> {
    fn from(index: Index<'a, RangeFullExpr>) -> Self {
        Expr::RangeFull(index)
    }
}

impl<'a> From<Index<'a, RangeLeftExpr<'a>>> for Expr<'a> {
    fn from(index: Index<'a, RangeLeftExpr<'a>>) -> Self {
        Expr::RangeLeft(index)
    }
}

impl<'a> From<Index<'a, RangeRightExpr<'a>>> for Expr<'a> {
    fn from(index: Index<'a, RangeRightExpr<'a>>) -> Self {
        Expr::RangeRight(index)
    }
}

impl<'a> From<Index<'a, StructDef<'a>>> for Item<'a> {
    fn from(index: Index<'a, StructDef<'a>>) -> Self {
        Item::Struct(index)
    }
}

impl<'a> From<Index<'a, EnumDef<'a>>> for Item<'a> {
    fn from(index: Index<'a, EnumDef<'a>>) -> Self {
        Item::Enum(index)
    }
}

impl<'a> From<Index<'a, FnDef<'a>>> for Item<'a> {
    fn from(index: Index<'a, FnDef<'a>>) -> Self {
        Item::Fn(index)
    }
}

impl<'a> From<Index<'a, Implementation<'a>>> for Item<'a> {
    fn from(index: Index<'a, Implementation<'a>>) -> Self {
        Item::Impl(index)
    }
}

impl<'a> From<Index<'a, TypeDef<'a>>> for Item<'a> {
    fn from(index: Index<'a, TypeDef<'a>>) -> Self {
        Item::Type(index)
    }
}

impl<'a> From<Index<'a, ClassDef<'a>>> for Item<'a> {
    fn from(index: Index<'a, ClassDef<'a>>) -> Self {
        Item::Class(index)
    }
}

impl<'a> From<Index<'a, BlockStatement<'a>>> for Item<'a> {
    fn from(index: Index<'a, BlockStatement<'a>>) -> Self {
        Item::Block(index)
    }
}

impl<'a> From<Index<'a, SimpleExprStatement<'a>>> for Item<'a> {
    fn from(index: Index<'a, SimpleExprStatement<'a>>) -> Self {
        Item::SimpleExpr(index)
    }
}

impl<'a> From<Index<'a, AssignExprStatement<'a>>> for Item<'a> {
    fn from(index: Index<'a, AssignExprStatement<'a>>) -> Self {
        Item::AssignExpr(index)
    }
}

impl<'a> From<Index<'a, ForStatement<'a>>> for Item<'a> {
    fn from(index: Index<'a, ForStatement<'a>>) -> Self {
        Item::For(index)
    }
}

impl<'a> From<Index<'a, IfStatement<'a>>> for Item<'a> {
    fn from(index: Index<'a, IfStatement<'a>>) -> Self {
        Item::If(index)
    }
}

impl<'a> From<Index<'a, LoopStatement<'a>>> for Item<'a> {
    fn from(index: Index<'a, LoopStatement<'a>>) -> Self {
        Item::Loop(index)
    }
}

impl<'a> From<Index<'a, VarDeclStatement<'a>>> for Item<'a> {
    fn from(index: Index<'a, VarDeclStatement<'a>>) -> Self {
        Item::VarDecl(index)
    }
}

impl<'a> From<Index<'a, WhileStatement<'a>>> for Item<'a> {
    fn from(index: Index<'a, WhileStatement<'a>>) -> Self {
        Item::While(index)
    }
}

impl<'a> From<Index<'a, UseStatement<'a>>> for Item<'a> {
    fn from(index: Index<'a, UseStatement<'a>>) -> Self {
        Item::Use(index)
    }
}

impl<'a> From<Index<'a, ModuleStatement>> for Item<'a> {
    fn from(index: Index<'a, ModuleStatement>) -> Self {
        Item::Import(index)
    }
}

impl<'a> From<Index<'a, SimpleSegment>> for PathSegment<'a> {
    fn from(index: Index<'a, SimpleSegment>) -> Self {
        PathSegment::Simple(index)
    }
}

impl<'a> From<Index<'a, CastSegment<'a>>> for PathSegment<'a> {
    fn from(index: Index<'a, CastSegment<'a>>) -> Self {
        PathSegment::Cast(index)
    }
}

impl<'a> From<Index<'a, GenericSegment<'a>>> for PathSegment<'a> {
    fn from(index: Index<'a, GenericSegment<'a>>) -> Self {
        PathSegment::Generic(index)
    }
}

impl<'a> From<Index<'a, StructDef<'a>>> for Statement<'a> {
    fn from(index: Index<'a, StructDef<'a>>) -> Self {
        Statement::Struct(index)
    }
}

impl<'a> From<Index<'a, EnumDef<'a>>> for Statement<'a> {
    fn from(index: Index<'a, EnumDef<'a>>) -> Self {
        Statement::Enum(index)
    }
}

impl<'a> From<Index<'a, FnDef<'a>>> for Statement<'a> {
    fn from(index: Index<'a, FnDef<'a>>) -> Self {
        Statement::Fn(index)
    }
}

impl<'a> From<Index<'a, Implementation<'a>>> for Statement<'a> {
    fn from(index: Index<'a, Implementation<'a>>) -> Self {
        Statement::Impl(index)
    }
}

impl<'a> From<Index<'a, TypeDef<'a>>> for Statement<'a> {
    fn from(index: Index<'a, TypeDef<'a>>) -> Self {
        Statement::Type(index)
    }
}

impl<'a> From<Index<'a, ClassDef<'a>>> for Statement<'a> {
    fn from(index: Index<'a, ClassDef<'a>>) -> Self {
        Statement::Class(index)
    }
}

impl<'a> From<Index<'a, BlockStatement<'a>>> for Statement<'a> {
    fn from(index: Index<'a, BlockStatement<'a>>) -> Self {
        Statement::Block(index)
    }
}

impl<'a> From<Index<'a, BreakStatement>> for Statement<'a> {
    fn from(index: Index<'a, BreakStatement>) -> Self {
        Statement::Break(index)
    }
}

impl<'a> From<Index<'a, ContinueStatement>> for Statement<'a> {
    fn from(index: Index<'a, ContinueStatement>) -> Self {
        Statement::Continue(index)
    }
}

impl<'a> From<Index<'a, SimpleExprStatement<'a>>> for Statement<'a> {
    fn from(index: Index<'a, SimpleExprStatement<'a>>) -> Self {
        Statement::SimpleExpr(index)
    }
}

impl<'a> From<Index<'a, AssignExprStatement<'a>>> for Statement<'a> {
    fn from(index: Index<'a, AssignExprStatement<'a>>) -> Self {
        Statement::AssignExpr(index)
    }
}

impl<'a> From<Index<'a, ForStatement<'a>>> for Statement<'a> {
    fn from(index: Index<'a, ForStatement<'a>>) -> Self {
        Statement::For(index)
    }
}

impl<'a> From<Index<'a, IfStatement<'a>>> for Statement<'a> {
    fn from(index: Index<'a, IfStatement<'a>>) -> Self {
        Statement::If(index)
    }
}

impl<'a> From<Index<'a, LoopStatement<'a>>> for Statement<'a> {
    fn from(index: Index<'a, LoopStatement<'a>>) -> Self {
        Statement::Loop(index)
    }
}

impl<'a> From<Index<'a, ReturnStatement<'a>>> for Statement<'a> {
    fn from(index: Index<'a, ReturnStatement<'a>>) -> Self {
        Statement::Return(index)
    }
}

impl<'a> From<Index<'a, VarDeclStatement<'a>>> for Statement<'a> {
    fn from(index: Index<'a, VarDeclStatement<'a>>) -> Self {
        Statement::VarDecl(index)
    }
}

impl<'a> From<Index<'a, WhileStatement<'a>>> for Statement<'a> {
    fn from(index: Index<'a, WhileStatement<'a>>) -> Self {
        Statement::While(index)
    }
}

impl<'a> From<Index<'a, UseStatement<'a>>> for Statement<'a> {
    fn from(index: Index<'a, UseStatement<'a>>) -> Self {
        Statement::Use(index)
    }
}

impl<'a> From<Index<'a, ArrayType<'a>>> for TypeRef<'a> {
    fn from(index: Index<'a, ArrayType<'a>>) -> Self {
        TypeRef::Array(index)
    }
}

impl<'a> From<Index<'a, FnType<'a>>> for TypeRef<'a> {
    fn from(index: Index<'a, FnType<'a>>) -> Self {
        TypeRef::Fn(index)
    }
}

impl<'a> From<Index<'a, Path<'a>>> for TypeRef<'a> {
    fn from(index: Index<'a, Path<'a>>) -> Self {
        TypeRef::Path(index)
    }
}

impl<'a> From<Index<'a, PrimitiveType>> for TypeRef<'a> {
    fn from(index: Index<'a, PrimitiveType>) -> Self {
        TypeRef::Primitive(index)
    }
}

impl<'a> From<Index<'a, RefType<'a>>> for TypeRef<'a> {
    fn from(index: Index<'a, RefType<'a>>) -> Self {
        TypeRef::Ref(index)
    }
}

impl<'a> From<Index<'a, TupleType<'a>>> for TypeRef<'a> {
    fn from(index: Index<'a, TupleType<'a>>) -> Self {
        TypeRef::Tuple(index)
    }
}
pub trait EmplaceConcrete: EmplaceConcreteHelper {

    fn emplace_array_expr<'a>(
        &'a self,
        span: Span,
        items: Vec<Expr<'a>>,
    ) -> Index<'a, ArrayExpr<'a>>;

    fn emplace_array_index_expr<'a>(
        &'a self,
        span: Span,
        base: Expr<'a>,
        parameters: Vec<Expr<'a>>,
        quote_span: Span,
    ) -> Index<'a, ArrayIndexExpr<'a>>;

    fn emplace_array_type<'a>(
        &'a self,
        span: Span,
        base: TypeRef<'a>,
        size: Expr<'a>,
    ) -> Index<'a, ArrayType<'a>>;

    fn emplace_assign_expr_stmt<'a>(
        &'a self,
        span: Span,
        left: Expr<'a>,
        right: Expr<'a>,
        op: Separator,
        op_span: Span,
    ) -> Index<'a, AssignExprStatement<'a>>;

    fn emplace_binary_expr<'a>(
        &'a self,
        span: Span,
        left: Expr<'a>,
        right: Expr<'a>,
        op: Separator,
        op_span: Span,
    ) -> Index<'a, BinaryExpr<'a>>;

    fn emplace_block<'a>(
        &'a self,
        span: Span,
        items: Vec<Statement<'a>>,
    ) -> Index<'a, Block<'a>>;

    fn emplace_block_stmt<'a>(
        &'a self,
        span: Span,
        label: Option<IdSpan>,
        body: Index<'a, Block<'a>>,
    ) -> Index<'a, BlockStatement<'a>>;

    fn emplace_break_stmt<'a>(
        &'a self,
        span: Span,
        label: Option<IdSpan>,
    ) -> Index<'a, BreakStatement>;

    fn emplace_call_expr<'a>(
        &'a self,
        span: Span,
        base: Expr<'a>,
        quote_span: Span,
        parameters: Vec<Expr<'a>>,
    ) -> Index<'a, CallExpr<'a>>;

    fn emplace_cast_segment<'a>(
        &'a self,
        span: Span,
        left: TypeRef<'a>,
        right: TypeRef<'a>,
    ) -> Index<'a, CastSegment<'a>>;

    fn emplace_class_def<'a>(
        &'a self,
        span: Span,
        name: Index<'a, GenericName<'a>>,
        quote_span: Span,
        items: Vec<Item<'a>>,
    ) -> Index<'a, ClassDef<'a>>;

    fn emplace_continue_stmt<'a>(
        &'a self,
        span: Span,
        label: Option<IdSpan>,
    ) -> Index<'a, ContinueStatement>;

    fn emplace_else_clause<'a>(
        &'a self,
        span: Span,
        body: Index<'a, Block<'a>>,
    ) -> Index<'a, ElseClause<'a>>;

    fn emplace_enum_def<'a>(
        &'a self,
        span: Span,
        name: IdSpan,
        base_type: Option<Index<'a, PrimitiveType>>,
        quote_span: Span,
        variants: Vec<Index<'a, EnumDefVariant<'a>>>,
    ) -> Index<'a, EnumDef<'a>>;

    fn emplace_enum_def_variant<'a>(
        &'a self,
        span: Span,
        name: IdSpan,
        value: Option<Expr<'a>>,
    ) -> Index<'a, EnumDefVariant<'a>>;

    fn emplace_field_def<'a>(
        &'a self,
        span: Span,
        name: IdSpan,
        colon_span: Span,
        r#type: TypeRef<'a>,
    ) -> Index<'a, FieldDef<'a>>;

    fn emplace_fn_def<'a>(
        &'a self,
        span: Span,
        name: Index<'a, GenericName<'a>>,
        quote_span: Span,
        parameters: Vec<Index<'a, FnDefParameter<'a>>>,
        ret_type: Option<TypeRef<'a>>,
        wheres: Vec<Index<'a, WhereClause<'a>>>,
        body: Option<Index<'a, Block<'a>>>,
    ) -> Index<'a, FnDef<'a>>;

    fn emplace_fn_def_parameter<'a>(
        &'a self,
        span: Span,
        name: IdSpan,
        r#type: TypeRef<'a>,
    ) -> Index<'a, FnDefParameter<'a>>;

    fn emplace_fn_type<'a>(
        &'a self,
        span: Span,
        quote_span: Span,
        parameters: Vec<Index<'a, FnTypeParameter<'a>>>,
        ret_type: Option<TypeRef<'a>>,
    ) -> Index<'a, FnType<'a>>;

    fn emplace_fn_type_parameter<'a>(
        &'a self,
        span: Span,
        name: Option<IdSpan>,
        r#type: TypeRef<'a>,
    ) -> Index<'a, FnTypeParameter<'a>>;

    fn emplace_for_stmt<'a>(
        &'a self,
        span: Span,
        label: Option<IdSpan>,
        iter_name: IdSpan,
        iter_expr: Expr<'a>,
        body: Index<'a, Block<'a>>,
    ) -> Index<'a, ForStatement<'a>>;

    fn emplace_generic_name<'a>(
        &'a self,
        span: Span,
        base: IdSpan,
        quote_span: Span,
        parameters: Vec<Index<'a, GenericParameter>>,
    ) -> Index<'a, GenericName<'a>>;

    fn emplace_generic_parameter<'a>(
        &'a self,
        span: Span,
        name: IdSpan,
    ) -> Index<'a, GenericParameter>;

    fn emplace_generic_segment<'a>(
        &'a self,
        span: Span,
        base: IdSpan,
        parameters: Index<'a, TypeList<'a>>,
    ) -> Index<'a, GenericSegment<'a>>;

    fn emplace_if_clause<'a>(
        &'a self,
        span: Span,
        condition: Expr<'a>,
        body: Index<'a, Block<'a>>,
    ) -> Index<'a, IfClause<'a>>;

    fn emplace_if_stmt<'a>(
        &'a self,
        span: Span,
        if_clause: Index<'a, IfClause<'a>>,
        elseif_clauses: Vec<Index<'a, IfClause<'a>>>,
        else_clause: Option<Index<'a, ElseClause<'a>>>,
    ) -> Index<'a, IfStatement<'a>>;

    fn emplace_impl_block<'a>(
        &'a self,
        span: Span,
        parameters: Vec<Index<'a, GenericParameter>>,
        class: Option<TypeRef<'a>>,
        r#type: TypeRef<'a>,
        wheres: Vec<Index<'a, WhereClause<'a>>>,
        quote_span: Span,
        items: Vec<Item<'a>>,
    ) -> Index<'a, Implementation<'a>>;

    fn emplace_lit_expr<'a>(
        &'a self,
        span: Span,
        value: LitValue,
    ) -> Index<'a, LitExpr>;

    fn emplace_loop_stmt<'a>(
        &'a self,
        span: Span,
        label: Option<IdSpan>,
        body: Index<'a, Block<'a>>,
    ) -> Index<'a, LoopStatement<'a>>;

    fn emplace_member_expr<'a>(
        &'a self,
        span: Span,
        base: Expr<'a>,
        op_span: Span,
        name: IdSpan,
        parameters: Option<Index<'a, TypeList<'a>>>,
    ) -> Index<'a, MemberExpr<'a>>;

    fn emplace_module<'a>(
        &'a self,
        file: FileId,
        items: Vec<Item<'a>>,
    ) -> Index<'a, Module<'a>>;

    fn emplace_module_stmt<'a>(
        &'a self,
        span: Span,
        name: IdSpan,
        path: Option<IdSpan>,
    ) -> Index<'a, ModuleStatement>;

    fn emplace_object_expr<'a>(
        &'a self,
        span: Span,
        base: Expr<'a>,
        quote_span: Span,
        fields: Vec<Index<'a, ObjectExprField<'a>>>,
    ) -> Index<'a, ObjectExpr<'a>>;

    fn emplace_object_expr_field<'a>(
        &'a self,
        span: Span,
        name: IdSpan,
        value: Expr<'a>,
    ) -> Index<'a, ObjectExprField<'a>>;

    fn emplace_paren_expr<'a>(
        &'a self,
        span: Span,
        base: Expr<'a>,
    ) -> Index<'a, ParenExpr<'a>>;

    fn emplace_path<'a>(
        &'a self,
        span: Span,
        segments: Vec<PathSegment<'a>>,
    ) -> Index<'a, Path<'a>>;

    fn emplace_primitive_type<'a>(
        &'a self,
        span: Span,
        base: Keyword,
    ) -> Index<'a, PrimitiveType>;

    fn emplace_range_both_expr<'a>(
        &'a self,
        span: Span,
        left: Expr<'a>,
        op_span: Span,
        right: Expr<'a>,
    ) -> Index<'a, RangeBothExpr<'a>>;

    fn emplace_range_full_expr<'a>(
        &'a self,
        span: Span,
    ) -> Index<'a, RangeFullExpr>;

    fn emplace_range_left_expr<'a>(
        &'a self,
        span: Span,
        base: Expr<'a>,
    ) -> Index<'a, RangeLeftExpr<'a>>;

    fn emplace_range_right_expr<'a>(
        &'a self,
        span: Span,
        base: Expr<'a>,
    ) -> Index<'a, RangeRightExpr<'a>>;

    fn emplace_ref_type<'a>(
        &'a self,
        span: Span,
        base: TypeRef<'a>,
    ) -> Index<'a, RefType<'a>>;

    fn emplace_ret_stmt<'a>(
        &'a self,
        span: Span,
        value: Option<Expr<'a>>,
    ) -> Index<'a, ReturnStatement<'a>>;

    fn emplace_simple_expr_stmt<'a>(
        &'a self,
        span: Span,
        expr: Expr<'a>,
    ) -> Index<'a, SimpleExprStatement<'a>>;

    fn emplace_simple_segment<'a>(
        &'a self,
        span: Span,
        name: IsId,
    ) -> Index<'a, SimpleSegment>;

    fn emplace_struct_def<'a>(
        &'a self,
        span: Span,
        name: Index<'a, GenericName<'a>>,
        fields: Vec<Index<'a, FieldDef<'a>>>,
    ) -> Index<'a, StructDef<'a>>;

    fn emplace_tuple_expr<'a>(
        &'a self,
        span: Span,
        items: Vec<Expr<'a>>,
    ) -> Index<'a, TupleExpr<'a>>;

    fn emplace_tuple_index_expr<'a>(
        &'a self,
        span: Span,
        base: Expr<'a>,
        op_span: Span,
        value: i32,
        value_span: Span,
    ) -> Index<'a, TupleIndexExpr<'a>>;

    fn emplace_tuple_type<'a>(
        &'a self,
        span: Span,
        parameters: Vec<TypeRef<'a>>,
    ) -> Index<'a, TupleType<'a>>;

    fn emplace_type_def<'a>(
        &'a self,
        span: Span,
        name: Index<'a, GenericName<'a>>,
        from: Option<TypeRef<'a>>,
    ) -> Index<'a, TypeDef<'a>>;

    fn emplace_type_list<'a>(
        &'a self,
        span: Span,
        items: Vec<TypeRef<'a>>,
    ) -> Index<'a, TypeList<'a>>;

    fn emplace_unary_expr<'a>(
        &'a self,
        span: Span,
        base: Expr<'a>,
        op: Separator,
        op_span: Span,
    ) -> Index<'a, UnaryExpr<'a>>;

    fn emplace_use_stmt<'a>(
        &'a self,
        span: Span,
        path: Index<'a, Path<'a>>,
        alias: Option<IdSpan>,
    ) -> Index<'a, UseStatement<'a>>;

    fn emplace_var_decl_stmt<'a>(
        &'a self,
        span: Span,
        r#const: bool,
        name: IdSpan,
        r#type: Option<TypeRef<'a>>,
        init_value: Option<Expr<'a>>,
    ) -> Index<'a, VarDeclStatement<'a>>;

    fn emplace_where_clause<'a>(
        &'a self,
        span: Span,
        name: IdSpan,
        constraints: Vec<TypeRef<'a>>,
    ) -> Index<'a, WhereClause<'a>>;

    fn emplace_while_stmt<'a>(
        &'a self,
        span: Span,
        label: Option<IdSpan>,
        condition: Expr<'a>,
        body: Index<'a, Block<'a>>,
    ) -> Index<'a, WhileStatement<'a>>;
}

impl EmplaceConcrete for Arena {

    #[inline]
    fn emplace_array_expr<'a>(
        &'a self,
        span: Span,
        items: Vec<Expr<'a>>,
    ) -> Index<'a, ArrayExpr<'a>> {
        let items = self.build_slice(items);
        self.emplace(|n: &mut ArrayExpr| {
            n.span = span;
            n.items = items;
        })
    }

    #[inline]
    fn emplace_array_index_expr<'a>(
        &'a self,
        span: Span,
        base: Expr<'a>,
        parameters: Vec<Expr<'a>>,
        quote_span: Span,
    ) -> Index<'a, ArrayIndexExpr<'a>> {
        let parameters = self.build_slice(parameters);
        self.emplace(|n: &mut ArrayIndexExpr| {
            n.span = span;
            n.base = base;
            n.parameters = parameters;
            n.quote_span = quote_span;
        })
    }

    #[inline]
    fn emplace_array_type<'a>(
        &'a self,
        span: Span,
        base: TypeRef<'a>,
        size: Expr<'a>,
    ) -> Index<'a, ArrayType<'a>> {
        self.emplace(|n: &mut ArrayType| {
            n.span = span;
            n.base = base;
            n.size = size;
        })
    }

    #[inline]
    fn emplace_assign_expr_stmt<'a>(
        &'a self,
        span: Span,
        left: Expr<'a>,
        right: Expr<'a>,
        op: Separator,
        op_span: Span,
    ) -> Index<'a, AssignExprStatement<'a>> {
        self.emplace(|n: &mut AssignExprStatement| {
            n.span = span;
            n.left = left;
            n.right = right;
            n.op = op;
            n.op_span = op_span;
        })
    }

    #[inline]
    fn emplace_binary_expr<'a>(
        &'a self,
        span: Span,
        left: Expr<'a>,
        right: Expr<'a>,
        op: Separator,
        op_span: Span,
    ) -> Index<'a, BinaryExpr<'a>> {
        self.emplace(|n: &mut BinaryExpr| {
            n.span = span;
            n.left = left;
            n.right = right;
            n.op = op;
            n.op_span = op_span;
        })
    }

    #[inline]
    fn emplace_block<'a>(
        &'a self,
        span: Span,
        items: Vec<Statement<'a>>,
    ) -> Index<'a, Block<'a>> {
        let items = self.build_slice(items);
        self.emplace(|n: &mut Block| {
            n.span = span;
            n.items = items;
        })
    }

    #[inline]
    fn emplace_block_stmt<'a>(
        &'a self,
        span: Span,
        label: Option<IdSpan>,
        body: Index<'a, Block<'a>>,
    ) -> Index<'a, BlockStatement<'a>> {
        self.emplace(|n: &mut BlockStatement| {
            n.span = span;
            n.label = label;
            n.body = body;
        })
    }

    #[inline]
    fn emplace_break_stmt<'a>(
        &'a self,
        span: Span,
        label: Option<IdSpan>,
    ) -> Index<'a, BreakStatement> {
        self.emplace(|n: &mut BreakStatement| {
            n.span = span;
            n.label = label;
        })
    }

    #[inline]
    fn emplace_call_expr<'a>(
        &'a self,
        span: Span,
        base: Expr<'a>,
        quote_span: Span,
        parameters: Vec<Expr<'a>>,
    ) -> Index<'a, CallExpr<'a>> {
        let parameters = self.build_slice(parameters);
        self.emplace(|n: &mut CallExpr| {
            n.span = span;
            n.base = base;
            n.quote_span = quote_span;
            n.parameters = parameters;
        })
    }

    #[inline]
    fn emplace_cast_segment<'a>(
        &'a self,
        span: Span,
        left: TypeRef<'a>,
        right: TypeRef<'a>,
    ) -> Index<'a, CastSegment<'a>> {
        self.emplace(|n: &mut CastSegment| {
            n.span = span;
            n.left = left;
            n.right = right;
        })
    }

    #[inline]
    fn emplace_class_def<'a>(
        &'a self,
        span: Span,
        name: Index<'a, GenericName<'a>>,
        quote_span: Span,
        items: Vec<Item<'a>>,
    ) -> Index<'a, ClassDef<'a>> {
        let items = self.build_slice(items);
        self.emplace(|n: &mut ClassDef| {
            n.span = span;
            n.name = name;
            n.quote_span = quote_span;
            n.items = items;
        })
    }

    #[inline]
    fn emplace_continue_stmt<'a>(
        &'a self,
        span: Span,
        label: Option<IdSpan>,
    ) -> Index<'a, ContinueStatement> {
        self.emplace(|n: &mut ContinueStatement| {
            n.span = span;
            n.label = label;
        })
    }

    #[inline]
    fn emplace_else_clause<'a>(
        &'a self,
        span: Span,
        body: Index<'a, Block<'a>>,
    ) -> Index<'a, ElseClause<'a>> {
        self.emplace(|n: &mut ElseClause| {
            n.span = span;
            n.body = body;
        })
    }

    #[inline]
    fn emplace_enum_def<'a>(
        &'a self,
        span: Span,
        name: IdSpan,
        base_type: Option<Index<'a, PrimitiveType>>,
        quote_span: Span,
        variants: Vec<Index<'a, EnumDefVariant<'a>>>,
    ) -> Index<'a, EnumDef<'a>> {
        let variants = self.build_slice(variants);
        self.emplace(|n: &mut EnumDef| {
            n.span = span;
            n.name = name;
            n.base_type = base_type;
            n.quote_span = quote_span;
            n.variants = variants;
        })
    }

    #[inline]
    fn emplace_enum_def_variant<'a>(
        &'a self,
        span: Span,
        name: IdSpan,
        value: Option<Expr<'a>>,
    ) -> Index<'a, EnumDefVariant<'a>> {
        self.emplace(|n: &mut EnumDefVariant| {
            n.span = span;
            n.name = name;
            n.value = value;
        })
    }

    #[inline]
    fn emplace_field_def<'a>(
        &'a self,
        span: Span,
        name: IdSpan,
        colon_span: Span,
        r#type: TypeRef<'a>,
    ) -> Index<'a, FieldDef<'a>> {
        self.emplace(|n: &mut FieldDef| {
            n.span = span;
            n.name = name;
            n.colon_span = colon_span;
            n.r#type = r#type;
        })
    }

    #[inline]
    fn emplace_fn_def<'a>(
        &'a self,
        span: Span,
        name: Index<'a, GenericName<'a>>,
        quote_span: Span,
        parameters: Vec<Index<'a, FnDefParameter<'a>>>,
        ret_type: Option<TypeRef<'a>>,
        wheres: Vec<Index<'a, WhereClause<'a>>>,
        body: Option<Index<'a, Block<'a>>>,
    ) -> Index<'a, FnDef<'a>> {
        let parameters = self.build_slice(parameters);
        let wheres = self.build_slice(wheres);
        self.emplace(|n: &mut FnDef| {
            n.span = span;
            n.name = name;
            n.quote_span = quote_span;
            n.parameters = parameters;
            n.ret_type = ret_type;
            n.wheres = wheres;
            n.body = body;
        })
    }

    #[inline]
    fn emplace_fn_def_parameter<'a>(
        &'a self,
        span: Span,
        name: IdSpan,
        r#type: TypeRef<'a>,
    ) -> Index<'a, FnDefParameter<'a>> {
        self.emplace(|n: &mut FnDefParameter| {
            n.span = span;
            n.name = name;
            n.r#type = r#type;
        })
    }

    #[inline]
    fn emplace_fn_type<'a>(
        &'a self,
        span: Span,
        quote_span: Span,
        parameters: Vec<Index<'a, FnTypeParameter<'a>>>,
        ret_type: Option<TypeRef<'a>>,
    ) -> Index<'a, FnType<'a>> {
        let parameters = self.build_slice(parameters);
        self.emplace(|n: &mut FnType| {
            n.span = span;
            n.quote_span = quote_span;
            n.parameters = parameters;
            n.ret_type = ret_type;
        })
    }

    #[inline]
    fn emplace_fn_type_parameter<'a>(
        &'a self,
        span: Span,
        name: Option<IdSpan>,
        r#type: TypeRef<'a>,
    ) -> Index<'a, FnTypeParameter<'a>> {
        self.emplace(|n: &mut FnTypeParameter| {
            n.span = span;
            n.name = name;
            n.r#type = r#type;
        })
    }

    #[inline]
    fn emplace_for_stmt<'a>(
        &'a self,
        span: Span,
        label: Option<IdSpan>,
        iter_name: IdSpan,
        iter_expr: Expr<'a>,
        body: Index<'a, Block<'a>>,
    ) -> Index<'a, ForStatement<'a>> {
        self.emplace(|n: &mut ForStatement| {
            n.span = span;
            n.label = label;
            n.iter_name = iter_name;
            n.iter_expr = iter_expr;
            n.body = body;
        })
    }

    #[inline]
    fn emplace_generic_name<'a>(
        &'a self,
        span: Span,
        base: IdSpan,
        quote_span: Span,
        parameters: Vec<Index<'a, GenericParameter>>,
    ) -> Index<'a, GenericName<'a>> {
        let parameters = self.build_slice(parameters);
        self.emplace(|n: &mut GenericName| {
            n.span = span;
            n.base = base;
            n.quote_span = quote_span;
            n.parameters = parameters;
        })
    }

    #[inline]
    fn emplace_generic_parameter<'a>(
        &'a self,
        span: Span,
        name: IdSpan,
    ) -> Index<'a, GenericParameter> {
        self.emplace(|n: &mut GenericParameter| {
            n.span = span;
            n.name = name;
        })
    }

    #[inline]
    fn emplace_generic_segment<'a>(
        &'a self,
        span: Span,
        base: IdSpan,
        parameters: Index<'a, TypeList<'a>>,
    ) -> Index<'a, GenericSegment<'a>> {
        self.emplace(|n: &mut GenericSegment| {
            n.span = span;
            n.base = base;
            n.parameters = parameters;
        })
    }

    #[inline]
    fn emplace_if_clause<'a>(
        &'a self,
        span: Span,
        condition: Expr<'a>,
        body: Index<'a, Block<'a>>,
    ) -> Index<'a, IfClause<'a>> {
        self.emplace(|n: &mut IfClause| {
            n.span = span;
            n.condition = condition;
            n.body = body;
        })
    }

    #[inline]
    fn emplace_if_stmt<'a>(
        &'a self,
        span: Span,
        if_clause: Index<'a, IfClause<'a>>,
        elseif_clauses: Vec<Index<'a, IfClause<'a>>>,
        else_clause: Option<Index<'a, ElseClause<'a>>>,
    ) -> Index<'a, IfStatement<'a>> {
        let elseif_clauses = self.build_slice(elseif_clauses);
        self.emplace(|n: &mut IfStatement| {
            n.span = span;
            n.if_clause = if_clause;
            n.elseif_clauses = elseif_clauses;
            n.else_clause = else_clause;
        })
    }

    #[inline]
    fn emplace_impl_block<'a>(
        &'a self,
        span: Span,
        parameters: Vec<Index<'a, GenericParameter>>,
        class: Option<TypeRef<'a>>,
        r#type: TypeRef<'a>,
        wheres: Vec<Index<'a, WhereClause<'a>>>,
        quote_span: Span,
        items: Vec<Item<'a>>,
    ) -> Index<'a, Implementation<'a>> {
        let parameters = self.build_slice(parameters);
        let wheres = self.build_slice(wheres);
        let items = self.build_slice(items);
        self.emplace(|n: &mut Implementation| {
            n.span = span;
            n.parameters = parameters;
            n.class = class;
            n.r#type = r#type;
            n.wheres = wheres;
            n.quote_span = quote_span;
            n.items = items;
        })
    }

    #[inline]
    fn emplace_lit_expr<'a>(
        &'a self,
        span: Span,
        value: LitValue,
    ) -> Index<'a, LitExpr> {
        self.emplace(|n: &mut LitExpr| {
            n.span = span;
            n.value = value;
        })
    }

    #[inline]
    fn emplace_loop_stmt<'a>(
        &'a self,
        span: Span,
        label: Option<IdSpan>,
        body: Index<'a, Block<'a>>,
    ) -> Index<'a, LoopStatement<'a>> {
        self.emplace(|n: &mut LoopStatement| {
            n.span = span;
            n.label = label;
            n.body = body;
        })
    }

    #[inline]
    fn emplace_member_expr<'a>(
        &'a self,
        span: Span,
        base: Expr<'a>,
        op_span: Span,
        name: IdSpan,
        parameters: Option<Index<'a, TypeList<'a>>>,
    ) -> Index<'a, MemberExpr<'a>> {
        self.emplace(|n: &mut MemberExpr| {
            n.span = span;
            n.base = base;
            n.op_span = op_span;
            n.name = name;
            n.parameters = parameters;
        })
    }

    #[inline]
    fn emplace_module<'a>(
        &'a self,
        file: FileId,
        items: Vec<Item<'a>>,
    ) -> Index<'a, Module<'a>> {
        let items = self.build_slice(items);
        self.emplace(|n: &mut Module| {
            n.file = file;
            n.items = items;
        })
    }

    #[inline]
    fn emplace_module_stmt<'a>(
        &'a self,
        span: Span,
        name: IdSpan,
        path: Option<IdSpan>,
    ) -> Index<'a, ModuleStatement> {
        self.emplace(|n: &mut ModuleStatement| {
            n.span = span;
            n.name = name;
            n.path = path;
        })
    }

    #[inline]
    fn emplace_object_expr<'a>(
        &'a self,
        span: Span,
        base: Expr<'a>,
        quote_span: Span,
        fields: Vec<Index<'a, ObjectExprField<'a>>>,
    ) -> Index<'a, ObjectExpr<'a>> {
        let fields = self.build_slice(fields);
        self.emplace(|n: &mut ObjectExpr| {
            n.span = span;
            n.base = base;
            n.quote_span = quote_span;
            n.fields = fields;
        })
    }

    #[inline]
    fn emplace_object_expr_field<'a>(
        &'a self,
        span: Span,
        name: IdSpan,
        value: Expr<'a>,
    ) -> Index<'a, ObjectExprField<'a>> {
        self.emplace(|n: &mut ObjectExprField| {
            n.span = span;
            n.name = name;
            n.value = value;
        })
    }

    #[inline]
    fn emplace_paren_expr<'a>(
        &'a self,
        span: Span,
        base: Expr<'a>,
    ) -> Index<'a, ParenExpr<'a>> {
        self.emplace(|n: &mut ParenExpr| {
            n.span = span;
            n.base = base;
        })
    }

    #[inline]
    fn emplace_path<'a>(
        &'a self,
        span: Span,
        segments: Vec<PathSegment<'a>>,
    ) -> Index<'a, Path<'a>> {
        let segments = self.build_slice(segments);
        self.emplace(|n: &mut Path| {
            n.span = span;
            n.segments = segments;
        })
    }

    #[inline]
    fn emplace_primitive_type<'a>(
        &'a self,
        span: Span,
        base: Keyword,
    ) -> Index<'a, PrimitiveType> {
        self.emplace(|n: &mut PrimitiveType| {
            n.span = span;
            n.base = base;
        })
    }

    #[inline]
    fn emplace_range_both_expr<'a>(
        &'a self,
        span: Span,
        left: Expr<'a>,
        op_span: Span,
        right: Expr<'a>,
    ) -> Index<'a, RangeBothExpr<'a>> {
        self.emplace(|n: &mut RangeBothExpr| {
            n.span = span;
            n.left = left;
            n.op_span = op_span;
            n.right = right;
        })
    }

    #[inline]
    fn emplace_range_full_expr<'a>(
        &'a self,
        span: Span,
    ) -> Index<'a, RangeFullExpr> {
        self.emplace(|n: &mut RangeFullExpr| {
            n.span = span;
        })
    }

    #[inline]
    fn emplace_range_left_expr<'a>(
        &'a self,
        span: Span,
        base: Expr<'a>,
    ) -> Index<'a, RangeLeftExpr<'a>> {
        self.emplace(|n: &mut RangeLeftExpr| {
            n.span = span;
            n.base = base;
        })
    }

    #[inline]
    fn emplace_range_right_expr<'a>(
        &'a self,
        span: Span,
        base: Expr<'a>,
    ) -> Index<'a, RangeRightExpr<'a>> {
        self.emplace(|n: &mut RangeRightExpr| {
            n.span = span;
            n.base = base;
        })
    }

    #[inline]
    fn emplace_ref_type<'a>(
        &'a self,
        span: Span,
        base: TypeRef<'a>,
    ) -> Index<'a, RefType<'a>> {
        self.emplace(|n: &mut RefType| {
            n.span = span;
            n.base = base;
        })
    }

    #[inline]
    fn emplace_ret_stmt<'a>(
        &'a self,
        span: Span,
        value: Option<Expr<'a>>,
    ) -> Index<'a, ReturnStatement<'a>> {
        self.emplace(|n: &mut ReturnStatement| {
            n.span = span;
            n.value = value;
        })
    }

    #[inline]
    fn emplace_simple_expr_stmt<'a>(
        &'a self,
        span: Span,
        expr: Expr<'a>,
    ) -> Index<'a, SimpleExprStatement<'a>> {
        self.emplace(|n: &mut SimpleExprStatement| {
            n.span = span;
            n.expr = expr;
        })
    }

    #[inline]
    fn emplace_simple_segment<'a>(
        &'a self,
        span: Span,
        name: IsId,
    ) -> Index<'a, SimpleSegment> {
        self.emplace(|n: &mut SimpleSegment| {
            n.span = span;
            n.name = name;
        })
    }

    #[inline]
    fn emplace_struct_def<'a>(
        &'a self,
        span: Span,
        name: Index<'a, GenericName<'a>>,
        fields: Vec<Index<'a, FieldDef<'a>>>,
    ) -> Index<'a, StructDef<'a>> {
        let fields = self.build_slice(fields);
        self.emplace(|n: &mut StructDef| {
            n.span = span;
            n.name = name;
            n.fields = fields;
        })
    }

    #[inline]
    fn emplace_tuple_expr<'a>(
        &'a self,
        span: Span,
        items: Vec<Expr<'a>>,
    ) -> Index<'a, TupleExpr<'a>> {
        let items = self.build_slice(items);
        self.emplace(|n: &mut TupleExpr| {
            n.span = span;
            n.items = items;
        })
    }

    #[inline]
    fn emplace_tuple_index_expr<'a>(
        &'a self,
        span: Span,
        base: Expr<'a>,
        op_span: Span,
        value: i32,
        value_span: Span,
    ) -> Index<'a, TupleIndexExpr<'a>> {
        self.emplace(|n: &mut TupleIndexExpr| {
            n.span = span;
            n.base = base;
            n.op_span = op_span;
            n.value = value;
            n.value_span = value_span;
        })
    }

    #[inline]
    fn emplace_tuple_type<'a>(
        &'a self,
        span: Span,
        parameters: Vec<TypeRef<'a>>,
    ) -> Index<'a, TupleType<'a>> {
        let parameters = self.build_slice(parameters);
        self.emplace(|n: &mut TupleType| {
            n.span = span;
            n.parameters = parameters;
        })
    }

    #[inline]
    fn emplace_type_def<'a>(
        &'a self,
        span: Span,
        name: Index<'a, GenericName<'a>>,
        from: Option<TypeRef<'a>>,
    ) -> Index<'a, TypeDef<'a>> {
        self.emplace(|n: &mut TypeDef| {
            n.span = span;
            n.name = name;
            n.from = from;
        })
    }

    #[inline]
    fn emplace_type_list<'a>(
        &'a self,
        span: Span,
        items: Vec<TypeRef<'a>>,
    ) -> Index<'a, TypeList<'a>> {
        let items = self.build_slice(items);
        self.emplace(|n: &mut TypeList| {
            n.span = span;
            n.items = items;
        })
    }

    #[inline]
    fn emplace_unary_expr<'a>(
        &'a self,
        span: Span,
        base: Expr<'a>,
        op: Separator,
        op_span: Span,
    ) -> Index<'a, UnaryExpr<'a>> {
        self.emplace(|n: &mut UnaryExpr| {
            n.span = span;
            n.base = base;
            n.op = op;
            n.op_span = op_span;
        })
    }

    #[inline]
    fn emplace_use_stmt<'a>(
        &'a self,
        span: Span,
        path: Index<'a, Path<'a>>,
        alias: Option<IdSpan>,
    ) -> Index<'a, UseStatement<'a>> {
        self.emplace(|n: &mut UseStatement| {
            n.span = span;
            n.path = path;
            n.alias = alias;
        })
    }

    #[inline]
    fn emplace_var_decl_stmt<'a>(
        &'a self,
        span: Span,
        r#const: bool,
        name: IdSpan,
        r#type: Option<TypeRef<'a>>,
        init_value: Option<Expr<'a>>,
    ) -> Index<'a, VarDeclStatement<'a>> {
        self.emplace(|n: &mut VarDeclStatement| {
            n.span = span;
            n.r#const = r#const;
            n.name = name;
            n.r#type = r#type;
            n.init_value = init_value;
        })
    }

    #[inline]
    fn emplace_where_clause<'a>(
        &'a self,
        span: Span,
        name: IdSpan,
        constraints: Vec<TypeRef<'a>>,
    ) -> Index<'a, WhereClause<'a>> {
        let constraints = self.build_slice(constraints);
        self.emplace(|n: &mut WhereClause| {
            n.span = span;
            n.name = name;
            n.constraints = constraints;
        })
    }

    #[inline]
    fn emplace_while_stmt<'a>(
        &'a self,
        span: Span,
        label: Option<IdSpan>,
        condition: Expr<'a>,
        body: Index<'a, Block<'a>>,
    ) -> Index<'a, WhileStatement<'a>> {
        self.emplace(|n: &mut WhileStatement| {
            n.span = span;
            n.label = label;
            n.condition = condition;
            n.body = body;
        })
    }
}
