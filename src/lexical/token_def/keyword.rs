///! fff-lang
///!
///! lexical/keyword
///! Attention: contens are auto generated by token.py, do not modify this file

#[derive(Eq, PartialEq, Clone, Copy)]
pub enum Keyword {
    Underscore,
    Alias,
    And,
    Array,
    As,
    Async,
    Auto,
    Await,
    Base,
    Bits16,
    Bits32,
    Bits64,
    Bits8,
    Bool,
    Break,
    Catch,
    Char,
    Class,
    Closure,
    Concept,
    Const,
    ConstExpr,
    Continue,
    Def,
    Default,
    Delete,
    Else,
    Enum,
    Except,
    Explicit,
    Extern,
    F128,
    F32,
    F64,
    False,
    Final,
    Finally,
    Fn,
    For,
    Foreach,
    Function,
    Goto,
    I128,
    I16,
    I32,
    I64,
    I8,
    If,
    Impl,
    Implicit,
    Import,
    In,
    Interface,
    Internal,
    Is,
    Lambda,
    Let,
    Loop,
    Match,
    Mod,
    Module,
    Mut,
    Mutable,
    Namespace,
    New,
    Nil,
    None,
    Null,
    Nullptr,
    Object,
    Or,
    Out,
    Override,
    Params,
    Priv,
    Private,
    Protected,
    Pub,
    Public,
    R128,
    R32,
    R64,
    Ref,
    Ret,
    Return,
    Sealed,
    Select,
    SMSelf,
    Static,
    String,
    Struct,
    Super,
    Switch,
    Template,
    Then,
    This,
    Throw,
    Trait,
    True,
    Try,
    Tuple,
    Type,
    TypeDef,
    Typeof,
    U128,
    U16,
    U32,
    U64,
    U8,
    Undefined,
    Unsafe,
    Use,
    Using,
    Var,
    Virtual,
    Volatile,
    Where,
    While,
    Yield,
}

const KEYWORD_VALUES: &[&str] = &[
    "_", "alias", "and", "array", "as", "async", "auto", 
    "await", "base", "bits16", "bits32", "bits64", "bits8", "bool", 
    "break", "catch", "char", "class", "closure", "concept", "const", 
    "constexpr", "continue", "def", "default", "delete", "else", "enum", 
    "except", "explicit", "extern", "f128", "f32", "f64", "false", 
    "final", "finally", "fn", "for", "foreach", "function", "goto", 
    "i128", "i16", "i32", "i64", "i8", "if", "impl", 
    "implicit", "import", "in", "interface", "internal", "is", "lambda", 
    "let", "loop", "match", "mod", "module", "mut", "mutable", 
    "namespace", "new", "nil", "none", "null", "nullptr", "object", 
    "or", "out", "override", "params", "priv", "private", "protected", 
    "pub", "public", "r128", "r32", "r64", "ref", "ret", 
    "return", "sealed", "select", "self", "static", "string", "struct", 
    "super", "switch", "template", "then", "this", "throw", "trait", 
    "true", "try", "tuple", "type", "typedef", "typeof", "u128", 
    "u16", "u32", "u64", "u8", "undefined", "unsafe", "use", 
    "using", "var", "virtual", "volatile", "where", "while", "yield", 
];

const EMPTY: u8 = 255;
const HASH_MAGIC: u64 = 16557366432705;
const KEYWORD_BUCKET1: &[u8] = &[
    EMPTY, EMPTY, 68, 108, 11, 40, 15, 76, EMPTY, EMPTY, EMPTY, 84, EMPTY, 42, EMPTY, 117, 
    32, EMPTY, 16, 31, 55, 96, 18, EMPTY, 7, 22, EMPTY, 39, 26, 38, EMPTY, EMPTY, 
    EMPTY, 70, 106, EMPTY, 83, 59, 3, 71, 95, 101, 81, EMPTY, 51, 20, EMPTY, 44, 
    EMPTY, EMPTY, EMPTY, 6, 0, EMPTY, 110, 24, 19, EMPTY, 61, 10, EMPTY, 98, EMPTY, EMPTY, 
    EMPTY, 107, 27, 116, EMPTY, 86, EMPTY, 87, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, 14, EMPTY, EMPTY, 
    54, EMPTY, 90, EMPTY, EMPTY, 17, 92, 33, EMPTY, 111, 35, EMPTY, 97, 30, 9, EMPTY, 
    47, EMPTY, EMPTY, 63, 25, 64, 50, 23, 89, EMPTY, 13, EMPTY, 100, 72, 45, EMPTY, 
    29, 67, 12, EMPTY, EMPTY, 37, EMPTY, 43, 65, 46, EMPTY, EMPTY, 113, EMPTY, 104, 74, 
    57, 53, 73, EMPTY, 60, EMPTY, EMPTY, 34, 41, 
];
const KEYWORD_BUCKET2: &[u8] = &[
    EMPTY, EMPTY, 78, 80, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, 85, EMPTY, EMPTY, EMPTY, 5, 
    EMPTY, EMPTY, 28, EMPTY, 118, EMPTY, EMPTY, EMPTY, EMPTY, 94, EMPTY, EMPTY, 115, EMPTY, EMPTY, EMPTY, 
    EMPTY, 75, 88, EMPTY, EMPTY, EMPTY, 69, 93, 1, 2, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, 21, 
    EMPTY, EMPTY, EMPTY, EMPTY, 4, EMPTY, EMPTY, EMPTY, 58, EMPTY, EMPTY, 62, EMPTY, 82, EMPTY, EMPTY, 
    EMPTY, 52, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, 91, EMPTY, EMPTY, 
    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, 49, EMPTY, 105, 36, EMPTY, 103, EMPTY, EMPTY, EMPTY, 
    EMPTY, EMPTY, EMPTY, EMPTY, 48, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, 66, EMPTY, EMPTY, EMPTY, 8, EMPTY, 
    EMPTY, 102, 56, EMPTY, EMPTY, 77, EMPTY, EMPTY, EMPTY, 114, EMPTY, EMPTY, 99, EMPTY, EMPTY, 109, 
    EMPTY, EMPTY, 112, EMPTY, 79, EMPTY, EMPTY, EMPTY, EMPTY, 
];
impl Keyword {
    pub fn parse(v: &str) -> Option<Keyword> {
        let mut hash = 1u64;
        for ch in v.chars() {
            if ch as u32 <= 43 { return None; }
            hash = (hash * (ch as u32 - 43u32) as u64) % HASH_MAGIC;
        }
        match KEYWORD_BUCKET1[(hash % 137) as usize] {
            index if index != EMPTY && KEYWORD_VALUES[index as usize] == v
                => Some(unsafe{ ::std::mem::transmute(index) }),
            _empty_or_invalid_key => match KEYWORD_BUCKET2[(hash % 137) as usize] {
                EMPTY => None,
                index if KEYWORD_VALUES[index as usize] == v
                    => Some(unsafe { ::std::mem::transmute(index) }),
                _invalid_index => None,
            },
        }
    }
}
impl ::std::fmt::Debug for Keyword {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{}", unsafe{ KEYWORD_VALUES[::std::mem::transmute_copy::<Keyword, u8>(self) as usize] })
    }
}

const KEYWORD_CATS: &[u8] = &[
    1, 3, 3, 2, 1, 3, 3, 3, 3, 3, 3, 3, 3, 2, 1, 3, 
    2, 3, 3, 3, 1, 3, 1, 3, 3, 3, 1, 3, 3, 3, 3, 3, 
    2, 2, 1, 3, 3, 1, 1, 3, 3, 3, 3, 2, 2, 2, 2, 1, 
    3, 3, 1, 1, 3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3, 3, 
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
    3, 3, 3, 3, 1, 3, 3, 3, 3, 2, 3, 3, 3, 3, 3, 1, 
    3, 3, 1, 3, 3, 1, 3, 3, 3, 2, 2, 2, 2, 3, 3, 1, 
    3, 1, 3, 3, 3, 1, 3, 
];
impl Keyword {
    pub fn is_primitive(&self) -> bool {
        KEYWORD_CATS[unsafe{ ::std::mem::transmute_copy::<Keyword, u8>(self) as usize }] == 2
    }
    pub fn is_reserved(&self) -> bool {
        KEYWORD_CATS[unsafe{ ::std::mem::transmute_copy::<Keyword, u8>(self) as usize }] == 3
    }
}

#[cfg(test)] #[test]
fn keyword_format() {

    assert_eq!{ format!("{:?}", Keyword::TypeDef), "typedef" }
    assert_eq!{ format!("{:?}", Keyword::Where), "where" }
    assert_eq!{ format!("{:?}", Keyword::Let), "let" }
    assert_eq!{ format!("{:?}", Keyword::Namespace), "namespace" }
    assert_eq!{ format!("{:?}", Keyword::Volatile), "volatile" }
    assert_eq!{ format!("{:?}", Keyword::Out), "out" }
    assert_eq!{ format!("{:?}", Keyword::Private), "private" }
    assert_eq!{ format!("{:?}", Keyword::Break), "break" }
    assert_eq!{ format!("{:?}", Keyword::False), "false" }
    assert_eq!{ format!("{:?}", Keyword::Public), "public" }
}
#[cfg(test)] #[test]
fn keyword_cat() {

    assert_eq!{ Keyword::Virtual.is_primitive(), false }
    assert_eq!{ Keyword::I16.is_reserved(), false }
    assert_eq!{ Keyword::Use.is_reserved(), false }
    assert_eq!{ Keyword::Break.is_reserved(), false }
    assert_eq!{ Keyword::U16.is_reserved(), false }
    assert_eq!{ Keyword::While.is_primitive(), false }
    assert_eq!{ Keyword::Continue.is_primitive(), false }
    assert_eq!{ Keyword::Protected.is_reserved(), true }
    assert_eq!{ Keyword::I8.is_reserved(), false }
    assert_eq!{ Keyword::Continue.is_reserved(), false }
    assert_eq!{ Keyword::F64.is_reserved(), false }
    assert_eq!{ Keyword::Break.is_primitive(), false }
    assert_eq!{ Keyword::Use.is_primitive(), false }
    assert_eq!{ Keyword::While.is_reserved(), false }
}
#[cfg(test)] #[test]
fn keyword_parse() {

    assert_eq!{ Keyword::parse("fn"), Some(Keyword::Fn) }
    assert_eq!{ Keyword::parse("await"), Some(Keyword::Await) }
    assert_eq!{ Keyword::parse("一个chinese变量"), None }
    assert_eq!{ Keyword::parse("a_中文_var"), None }
    assert_eq!{ Keyword::parse("as"), Some(Keyword::As) }
}
