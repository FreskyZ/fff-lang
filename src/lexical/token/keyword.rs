///! --------------------------------------------------------------------------------
///! This code is auto generated by a tool
///! Changes may cause incorrect behavior and will be lost if the code is regenerated
///! --------------------------------------------------------------------------------

#[repr(u8)]
#[allow(dead_code)]
#[derive(Eq, PartialEq, Clone, Copy, Debug)]
pub enum KeywordKind {
    Normal = 1,
    Primitive = 2,
    Reserved = 3,
}

#[repr(u8)]
#[derive(Eq, PartialEq, Clone, Copy, Debug)]
pub enum Keyword {
    Underscore = 1,
    And = 2,
    As = 3,
    Async = 4,
    Await = 5,
    Bits16 = 6,
    Bits32 = 7,
    Bits64 = 8,
    Bits8 = 9,
    Bool = 10,
    Break = 11,
    Catch = 12,
    Char = 13,
    Class = 14,
    Const = 15,
    Continue = 16,
    Else = 17,
    Enum = 18,
    Extern = 19,
    F128 = 20,
    F32 = 21,
    F64 = 22,
    False = 23,
    Finally = 24,
    Fn = 25,
    For = 26,
    Goto = 27,
    I128 = 28,
    I16 = 29,
    I32 = 30,
    I64 = 31,
    I8 = 32,
    If = 33,
    Impl = 34,
    In = 35,
    Interface = 36,
    Internal = 37,
    Is = 38,
    Let = 39,
    Loop = 40,
    Match = 41,
    Module = 42,
    Mut = 43,
    Namespace = 44,
    Null = 45,
    Or = 46,
    Override = 47,
    Private = 48,
    Protected = 49,
    Pub = 50,
    Public = 51,
    R128 = 52,
    R32 = 53,
    R64 = 54,
    Ref = 55,
    Ret = 56,
    Return = 57,
    Self_ = 58,
    Static = 59,
    Struct = 60,
    Super = 61,
    Switch = 62,
    This = 63,
    Throw = 64,
    Trait = 65,
    True = 66,
    Try = 67,
    Type = 68,
    TypeDef = 69,
    Typeof = 70,
    U128 = 71,
    U16 = 72,
    U32 = 73,
    U64 = 74,
    U8 = 75,
    Unsafe = 76,
    Use = 77,
    Var = 78,
    Virtual = 79,
    Volatile = 80,
    While = 81,
    Yield = 82,
}

const VALUES: &[&str] = &[
    "", "_", "and", "as", "async", "await", "bits16", "bits32", "bits64", "bits8",
    "bool", "break", "catch", "char", "class", "const", "continue", "else", "enum",
    "extern", "f128", "f32", "f64", "false", "finally", "fn", "for", "goto", "i128",
    "i16", "i32", "i64", "i8", "if", "impl", "in", "interface", "internal", "is",
    "let", "loop", "match", "module", "mut", "namespace", "null", "or", "override",
    "private", "protected", "pub", "public", "r128", "r32", "r64", "ref", "ret",
    "return", "self", "static", "struct", "super", "switch", "this", "throw", "trait",
    "true", "try", "type", "typedef", "typeof", "u128", "u16", "u32", "u64", "u8",
    "unsafe", "use", "var", "virtual", "volatile", "while", "yield",
];
const KINDS: &[u8] = &[
    0, 1, 3, 1, 3, 3, 3, 3, 3, 3, 2, 1, 3, 2, 3, 1, 1, 1, 3, 3, 3, 2, 2, 1, 3, 1,
    1, 3, 3, 2, 2, 2, 2, 1, 3, 1, 3, 3, 3, 3, 1, 3, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 1, 1, 3, 3, 3, 3, 1, 3, 3, 1, 3, 1, 3, 3, 3, 2, 2, 2, 2, 3, 1,
    1, 3, 3, 1, 3,
];

impl Keyword {

    pub fn display(self) -> &'static str {
        VALUES[self as u8 as usize]
    }

    pub fn kind(self, kind: KeywordKind) -> bool {
        KINDS[self as u8 as usize] == kind as u8
    }
}

use Keyword::*;
const BUCKETS: &[&[&[Option<Keyword>]]] = &[&[], &[],
    /* 2 */ &[
        &[Some(I8), Some(Or), None, Some(As), Some(Fn), None, Some(If), None],
        &[Some(U8), None, None, Some(Is), None, None, Some(In), None],
    ],
    /* 3 */ &[
        &[
            Some(Use), Some(Let), None, None, Some(Var), Some(Mut), Some(F64), None,
            Some(I16), None, Some(And), Some(U16), None, Some(F32), None, Some(Pub),
            Some(R32), Some(For), None, None, Some(I64), Some(Ref), None,
        ],
        &[
            None, Some(Ret), None, None, Some(Try), None, None, None, Some(I32),
            None, None, Some(U32), None, None, None, None, None, Some(R64), None,
            None, Some(U64), None, None,
        ],
    ],
    /* 4 */ &[
        &[
            Some(Enum), None, None, Some(Impl), Some(Else), Some(Type), Some(True),
            None, None, None, Some(This), Some(Loop), Some(Null), Some(Self_), Some(Goto),
            None,
        ],
        &[
            Some(F128), None, None, Some(R128), None, Some(Bool), Some(Char), None,
            None, None, None, None, None, None, None, None,
        ],
        &[
            Some(I128), None, None, Some(U128), None, None, None, None, None, None,
            None, None, None, None, None, None,
        ],
    ],
    /* 5 */ &[
        &[
            Some(Bits8), Some(Super), None, Some(Async), Some(Catch), Some(Await),
            Some(While), None, None, Some(Throw), None, Some(Const), Some(Match),
            None, None, Some(False), None, None, None, None, Some(Trait), Some(Class),
            None, None, Some(Yield), Some(Break),
        ],
    ],
    /* 6 */ &[
        &[
            Some(Bits64), Some(Extern), None, Some(Bits16), Some(Module), None, None,
            Some(Typeof), Some(Unsafe), None, Some(Public), Some(Return),
        ],
        &[
            None, None, None, Some(Bits32), Some(Switch), None, None, None, None,
            None, Some(Static), Some(Struct),
        ],
    ],
    /* 7 */ &[
        &[
            None, None, Some(Finally), Some(Private), None, None, None, Some(TypeDef),
            Some(Virtual),
        ],
    ],
    /* 8 */ &[
        &[Some(Internal), Some(Volatile), Some(Override), None, Some(Continue)],
    ],
    /* 9 */ &[
        &[Some(Interface), Some(Protected), Some(Namespace), None],
    ],
];

impl Keyword {

    pub fn parse(v: &str) -> Option<Keyword> {
        debug_assert!(!v.is_empty(), "empty ident");
        if v == "_" { return Some(Underscore); }
        if v.len() < 2 || v.len() > 9 { return None; }
        let hash = v.as_bytes().iter().fold(1usize, |acc, &b| acc * if b > 96 { b as usize - 96 } else if b > 48 { b as usize - 48 } else { b as usize } % 173);
        let buckets = &BUCKETS[v.len()];
        let hash = hash as usize % buckets[0].len();
        buckets.iter().filter_map(|bucket| bucket[hash].map(|i| if i.display() == v { Some(i) } else { None }).flatten()).next()
    }
}
