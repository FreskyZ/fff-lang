///! ---------------------------------------------------------------------------------
///! This code is auto generated by a tool $repo/scripts/ast.py
///! Changes may cause incorrect behavior and will be lost if the code is regenerated.
///! ---------------------------------------------------------------------------------

///! ast memory usage profiler

use std::mem::size_of;
use crate::common::arena::Arena;
use super::super::visit::{Visitor, Visit};
use super::noauto::EmptyResult;
use super::*;

pub fn profile<N: Visit>(node: &N, arena: &Arena) -> MemoryProfiler {
    let mut profiler = MemoryProfiler::new();
    node.accept(arena, &mut profiler);
    profiler
}

#[derive(Clone, Copy)]
struct Entry {
    count: usize,
    size: usize,
}

impl Entry {

    fn count(&mut self, size: usize) {
        self.count += 1;
        self.size += size;
    }
}

impl MemoryProfiler {

    pub fn dump(&self, output: &mut impl std::io::Write) {

        let total_count: usize = self.v.iter().map(|e| e.count).sum();
        let total_size: usize = self.v.iter().map(|e| e.size).sum();
        writeln!(output, "[all({total_count})]        {total_size}").unwrap();

        let mut ordered_items = self.v.iter()
            .enumerate().map(|(i, e)| (NAMES[i], e.count, e.size)).collect::<Vec<_>>();
        ordered_items.sort_unstable_by(|a, b| a.2.cmp(&b.2).then_with(|| a.0.cmp(&b.0)).reverse());
        for (key, count, size) in ordered_items {
            let header = format!("[{key}({count})]");
            let size_percent = size as f64 * 100f64 / total_size as f64;
            writeln!(output, "{header:>28} > {size} ({size_percent:.2}%)").unwrap();
        }
    }
}

// AUTOGEN
// use static name list because they are known at code generation time
static NAMES: &[&str] = &[
    "array-expr",
    "array-index-expr",
    "array-type",
    "assign-expr-stmt",
    "binary-expr",
    "block",
    "block-stmt",
    "break-stmt",
    "call-expr",
    "cast-segment",
    "class-def",
    "continue-stmt",
    "else-clause",
    "enum-def",
    "enum-def-variant",
    "field-def",
    "fn-def",
    "fn-def-parameter",
    "fn-type",
    "fn-type-parameter",
    "for-stmt",
    "generic-name",
    "generic-parameter",
    "generic-segment",
    "if-clause",
    "if-stmt",
    "impl-block",
    "lit-expr",
    "loop-stmt",
    "member-expr",
    "module",
    "module-stmt",
    "object-expr",
    "object-expr-field",
    "paren-expr",
    "path",
    "primitive-type",
    "range-both-expr",
    "range-full-expr",
    "range-left-expr",
    "range-right-expr",
    "ref-type",
    "ret-stmt",
    "simple-expr-stmt",
    "simple-segment",
    "struct-def",
    "tuple-expr",
    "tuple-index-expr",
    "tuple-type",
    "type-def",
    "type-list",
    "unary-expr",
    "use-stmt",
    "var-decl-stmt",
    "where-clause",
    "while-stmt",
];

pub struct MemoryProfiler {
    v: [Entry; 56],
}

impl MemoryProfiler {
    fn new() -> Self {
        Self{ v: [Entry{ count: 0, size: 0 }; 56] }
    }
    pub fn coverage(&self) -> (usize, usize, String) {
        (self.v.iter().filter(|e| e.count > 0).count(), self.v.len(),
            self.v.iter().enumerate().filter(|(_, e)| e.count == 0).map(|(i, _)| NAMES[i]).collect::<Vec<_>>().join(", "))
    }
}

impl Visitor for MemoryProfiler {
    type Result = EmptyResult;
    // enum types are all default here because they literal does not use any memory on its own in this arena refactor

    fn visit_array_expr<'a, 'b: 'a>(&mut self, node: &'b Index<'a, ArrayExpr<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[0].count(size_of::<ArrayExpr>());
        node.walk(arena, self)
    }
    fn visit_array_index_expr<'a, 'b: 'a>(&mut self, node: &'b Index<'a, ArrayIndexExpr<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[1].count(size_of::<ArrayIndexExpr>());
        node.walk(arena, self)
    }
    fn visit_array_type<'a, 'b: 'a>(&mut self, node: &'b Index<'a, ArrayType<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[2].count(size_of::<ArrayType>());
        node.walk(arena, self)
    }
    fn visit_assign_expr_stmt<'a, 'b: 'a>(&mut self, node: &'b Index<'a, AssignExprStatement<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[3].count(size_of::<AssignExprStatement>());
        node.walk(arena, self)
    }
    fn visit_binary_expr<'a, 'b: 'a>(&mut self, node: &'b Index<'a, BinaryExpr<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[4].count(size_of::<BinaryExpr>());
        node.walk(arena, self)
    }
    fn visit_block<'a, 'b: 'a>(&mut self, node: &'b Index<'a, Block<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[5].count(size_of::<Block>());
        node.walk(arena, self)
    }
    fn visit_block_stmt<'a, 'b: 'a>(&mut self, node: &'b Index<'a, BlockStatement<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[6].count(size_of::<BlockStatement>());
        node.walk(arena, self)
    }
    fn visit_break_stmt<'a, 'b: 'a>(&mut self, node: &'b Index<'a, BreakStatement>, arena: &'a Arena) -> Self::Result {
        self.v[7].count(size_of::<BreakStatement>());
        node.walk(arena, self)
    }
    fn visit_call_expr<'a, 'b: 'a>(&mut self, node: &'b Index<'a, CallExpr<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[8].count(size_of::<CallExpr>());
        node.walk(arena, self)
    }
    fn visit_cast_segment<'a, 'b: 'a>(&mut self, node: &'b Index<'a, CastSegment<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[9].count(size_of::<CastSegment>());
        node.walk(arena, self)
    }
    fn visit_class_def<'a, 'b: 'a>(&mut self, node: &'b Index<'a, ClassDef<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[10].count(size_of::<ClassDef>());
        node.walk(arena, self)
    }
    fn visit_continue_stmt<'a, 'b: 'a>(&mut self, node: &'b Index<'a, ContinueStatement>, arena: &'a Arena) -> Self::Result {
        self.v[11].count(size_of::<ContinueStatement>());
        node.walk(arena, self)
    }
    fn visit_else_clause<'a, 'b: 'a>(&mut self, node: &'b Index<'a, ElseClause<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[12].count(size_of::<ElseClause>());
        node.walk(arena, self)
    }
    fn visit_enum_def<'a, 'b: 'a>(&mut self, node: &'b Index<'a, EnumDef<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[13].count(size_of::<EnumDef>());
        node.walk(arena, self)
    }
    fn visit_enum_def_variant<'a, 'b: 'a>(&mut self, node: &'b Index<'a, EnumDefVariant<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[14].count(size_of::<EnumDefVariant>());
        node.walk(arena, self)
    }
    fn visit_field_def<'a, 'b: 'a>(&mut self, node: &'b Index<'a, FieldDef<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[15].count(size_of::<FieldDef>());
        node.walk(arena, self)
    }
    fn visit_fn_def<'a, 'b: 'a>(&mut self, node: &'b Index<'a, FnDef<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[16].count(size_of::<FnDef>());
        node.walk(arena, self)
    }
    fn visit_fn_def_parameter<'a, 'b: 'a>(&mut self, node: &'b Index<'a, FnDefParameter<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[17].count(size_of::<FnDefParameter>());
        node.walk(arena, self)
    }
    fn visit_fn_type<'a, 'b: 'a>(&mut self, node: &'b Index<'a, FnType<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[18].count(size_of::<FnType>());
        node.walk(arena, self)
    }
    fn visit_fn_type_parameter<'a, 'b: 'a>(&mut self, node: &'b Index<'a, FnTypeParameter<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[19].count(size_of::<FnTypeParameter>());
        node.walk(arena, self)
    }
    fn visit_for_stmt<'a, 'b: 'a>(&mut self, node: &'b Index<'a, ForStatement<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[20].count(size_of::<ForStatement>());
        node.walk(arena, self)
    }
    fn visit_generic_name<'a, 'b: 'a>(&mut self, node: &'b Index<'a, GenericName<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[21].count(size_of::<GenericName>());
        node.walk(arena, self)
    }
    fn visit_generic_parameter<'a, 'b: 'a>(&mut self, node: &'b Index<'a, GenericParameter>, arena: &'a Arena) -> Self::Result {
        self.v[22].count(size_of::<GenericParameter>());
        node.walk(arena, self)
    }
    fn visit_generic_segment<'a, 'b: 'a>(&mut self, node: &'b Index<'a, GenericSegment<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[23].count(size_of::<GenericSegment>());
        node.walk(arena, self)
    }
    fn visit_if_clause<'a, 'b: 'a>(&mut self, node: &'b Index<'a, IfClause<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[24].count(size_of::<IfClause>());
        node.walk(arena, self)
    }
    fn visit_if_stmt<'a, 'b: 'a>(&mut self, node: &'b Index<'a, IfStatement<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[25].count(size_of::<IfStatement>());
        node.walk(arena, self)
    }
    fn visit_impl_block<'a, 'b: 'a>(&mut self, node: &'b Index<'a, Implementation<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[26].count(size_of::<Implementation>());
        node.walk(arena, self)
    }
    fn visit_lit_expr<'a, 'b: 'a>(&mut self, node: &'b Index<'a, LitExpr>, arena: &'a Arena) -> Self::Result {
        self.v[27].count(size_of::<LitExpr>());
        node.walk(arena, self)
    }
    fn visit_loop_stmt<'a, 'b: 'a>(&mut self, node: &'b Index<'a, LoopStatement<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[28].count(size_of::<LoopStatement>());
        node.walk(arena, self)
    }
    fn visit_member_expr<'a, 'b: 'a>(&mut self, node: &'b Index<'a, MemberExpr<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[29].count(size_of::<MemberExpr>());
        node.walk(arena, self)
    }
    fn visit_module<'a, 'b: 'a>(&mut self, node: &'b Index<'a, Module<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[30].count(size_of::<Module>());
        node.walk(arena, self)
    }
    fn visit_module_stmt<'a, 'b: 'a>(&mut self, node: &'b Index<'a, ModuleStatement>, arena: &'a Arena) -> Self::Result {
        self.v[31].count(size_of::<ModuleStatement>());
        node.walk(arena, self)
    }
    fn visit_object_expr<'a, 'b: 'a>(&mut self, node: &'b Index<'a, ObjectExpr<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[32].count(size_of::<ObjectExpr>());
        node.walk(arena, self)
    }
    fn visit_object_expr_field<'a, 'b: 'a>(&mut self, node: &'b Index<'a, ObjectExprField<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[33].count(size_of::<ObjectExprField>());
        node.walk(arena, self)
    }
    fn visit_paren_expr<'a, 'b: 'a>(&mut self, node: &'b Index<'a, ParenExpr<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[34].count(size_of::<ParenExpr>());
        node.walk(arena, self)
    }
    fn visit_path<'a, 'b: 'a>(&mut self, node: &'b Index<'a, Path<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[35].count(size_of::<Path>());
        node.walk(arena, self)
    }
    fn visit_primitive_type<'a, 'b: 'a>(&mut self, node: &'b Index<'a, PrimitiveType>, arena: &'a Arena) -> Self::Result {
        self.v[36].count(size_of::<PrimitiveType>());
        node.walk(arena, self)
    }
    fn visit_range_both_expr<'a, 'b: 'a>(&mut self, node: &'b Index<'a, RangeBothExpr<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[37].count(size_of::<RangeBothExpr>());
        node.walk(arena, self)
    }
    fn visit_range_full_expr<'a, 'b: 'a>(&mut self, node: &'b Index<'a, RangeFullExpr>, arena: &'a Arena) -> Self::Result {
        self.v[38].count(size_of::<RangeFullExpr>());
        node.walk(arena, self)
    }
    fn visit_range_left_expr<'a, 'b: 'a>(&mut self, node: &'b Index<'a, RangeLeftExpr<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[39].count(size_of::<RangeLeftExpr>());
        node.walk(arena, self)
    }
    fn visit_range_right_expr<'a, 'b: 'a>(&mut self, node: &'b Index<'a, RangeRightExpr<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[40].count(size_of::<RangeRightExpr>());
        node.walk(arena, self)
    }
    fn visit_ref_type<'a, 'b: 'a>(&mut self, node: &'b Index<'a, RefType<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[41].count(size_of::<RefType>());
        node.walk(arena, self)
    }
    fn visit_ret_stmt<'a, 'b: 'a>(&mut self, node: &'b Index<'a, ReturnStatement<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[42].count(size_of::<ReturnStatement>());
        node.walk(arena, self)
    }
    fn visit_simple_expr_stmt<'a, 'b: 'a>(&mut self, node: &'b Index<'a, SimpleExprStatement<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[43].count(size_of::<SimpleExprStatement>());
        node.walk(arena, self)
    }
    fn visit_simple_segment<'a, 'b: 'a>(&mut self, node: &'b Index<'a, SimpleSegment>, arena: &'a Arena) -> Self::Result {
        self.v[44].count(size_of::<SimpleSegment>());
        node.walk(arena, self)
    }
    fn visit_struct_def<'a, 'b: 'a>(&mut self, node: &'b Index<'a, StructDef<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[45].count(size_of::<StructDef>());
        node.walk(arena, self)
    }
    fn visit_tuple_expr<'a, 'b: 'a>(&mut self, node: &'b Index<'a, TupleExpr<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[46].count(size_of::<TupleExpr>());
        node.walk(arena, self)
    }
    fn visit_tuple_index_expr<'a, 'b: 'a>(&mut self, node: &'b Index<'a, TupleIndexExpr<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[47].count(size_of::<TupleIndexExpr>());
        node.walk(arena, self)
    }
    fn visit_tuple_type<'a, 'b: 'a>(&mut self, node: &'b Index<'a, TupleType<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[48].count(size_of::<TupleType>());
        node.walk(arena, self)
    }
    fn visit_type_def<'a, 'b: 'a>(&mut self, node: &'b Index<'a, TypeDef<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[49].count(size_of::<TypeDef>());
        node.walk(arena, self)
    }
    fn visit_type_list<'a, 'b: 'a>(&mut self, node: &'b Index<'a, TypeList<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[50].count(size_of::<TypeList>());
        node.walk(arena, self)
    }
    fn visit_unary_expr<'a, 'b: 'a>(&mut self, node: &'b Index<'a, UnaryExpr<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[51].count(size_of::<UnaryExpr>());
        node.walk(arena, self)
    }
    fn visit_use_stmt<'a, 'b: 'a>(&mut self, node: &'b Index<'a, UseStatement<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[52].count(size_of::<UseStatement>());
        node.walk(arena, self)
    }
    fn visit_var_decl_stmt<'a, 'b: 'a>(&mut self, node: &'b Index<'a, VarDeclStatement<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[53].count(size_of::<VarDeclStatement>());
        node.walk(arena, self)
    }
    fn visit_where_clause<'a, 'b: 'a>(&mut self, node: &'b Index<'a, WhereClause<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[54].count(size_of::<WhereClause>());
        node.walk(arena, self)
    }
    fn visit_while_stmt<'a, 'b: 'a>(&mut self, node: &'b Index<'a, WhileStatement<'a>>, arena: &'a Arena) -> Self::Result {
        self.v[55].count(size_of::<WhileStatement>());
        node.walk(arena, self)
    }
}
