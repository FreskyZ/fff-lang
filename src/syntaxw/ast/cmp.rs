///! ---------------------------------------------------------------------------------
///! This code is auto generated by a tool $repo/scripts/ast.py
///! Changes may cause incorrect behavior and will be lost if the code is regenerated.
///! ---------------------------------------------------------------------------------

///! equality compare with arena

use super::*;

// this is not Visitor, because visitor visits one node, not *a pair of node*
pub trait Eq {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool;
}

impl<'a, T> Eq for Index<'a, T> where T: Eq {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        Eq::eq(arena.get(self), arena.get(rhs), arena)
    }
}

impl<'a, U> Eq for TagIndex<'a, U> where U: Eq {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        Eq::eq(self.as_repr().as_ref(), rhs.as_repr().as_ref(), arena)
    }
}

impl<'a, T> Eq for Slice<'a, T> where T: Eq {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.len() == rhs.len() && std::iter::zip(arena.get_iter(&self), arena.get_iter(&rhs)).all(|(lhs, rhs)| Eq::eq(lhs, rhs, arena))
    }
}

impl<T> Eq for Option<T> where T: Eq {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.as_ref().zip(rhs.as_ref()).map(|(lhs, rhs)| Eq::eq(lhs, rhs, arena)).unwrap_or(false)
    }
}

impl<T> Eq for Vec<T> where T: Eq {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.len() == rhs.len() && std::iter::zip(self.iter(), rhs.iter()).all(|(lhs, rhs)| Eq::eq(lhs, rhs, arena))
    }
}

// AUTOGEN
impl<'a> Eq for ArrayExpr<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && Eq::eq(&self.items, &rhs.items, arena)
    }
}

impl<'a> Eq for ArrayIndexExpr<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.quote_span == rhs.quote_span
        && Eq::eq(&self.base, &rhs.base, arena)
        && Eq::eq(&self.parameters, &rhs.parameters, arena)
    }
}

impl<'a> Eq for ArrayType<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && Eq::eq(&self.base, &rhs.base, arena)
        && Eq::eq(&self.size, &rhs.size, arena)
    }
}

impl<'a> Eq for AssignExprStatement<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.op == rhs.op
        && self.op_span == rhs.op_span
        && Eq::eq(&self.left, &rhs.left, arena)
        && Eq::eq(&self.right, &rhs.right, arena)
    }
}

impl<'a> Eq for BinaryExpr<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.op == rhs.op
        && self.op_span == rhs.op_span
        && Eq::eq(&self.left, &rhs.left, arena)
        && Eq::eq(&self.right, &rhs.right, arena)
    }
}

impl<'a> Eq for Block<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && Eq::eq(&self.items, &rhs.items, arena)
    }
}

impl<'a> Eq for BlockStatement<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.label == rhs.label
        && Eq::eq(&self.body, &rhs.body, arena)
    }
}

impl Eq for BreakStatement {
    fn eq(&self, rhs: &Self, _: &Arena) -> bool {
        self.span == rhs.span
        && self.label == rhs.label
    }
}

impl<'a> Eq for CallExpr<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.quote_span == rhs.quote_span
        && Eq::eq(&self.base, &rhs.base, arena)
        && Eq::eq(&self.parameters, &rhs.parameters, arena)
    }
}

impl<'a> Eq for CastSegment<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && Eq::eq(&self.left, &rhs.left, arena)
        && Eq::eq(&self.right, &rhs.right, arena)
    }
}

impl<'a> Eq for ClassDef<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.quote_span == rhs.quote_span
        && Eq::eq(&self.name, &rhs.name, arena)
        && Eq::eq(&self.items, &rhs.items, arena)
    }
}

impl Eq for ContinueStatement {
    fn eq(&self, rhs: &Self, _: &Arena) -> bool {
        self.span == rhs.span
        && self.label == rhs.label
    }
}

impl<'a> Eq for ElseClause<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && Eq::eq(&self.body, &rhs.body, arena)
    }
}

impl<'a> Eq for EnumDef<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.name == rhs.name
        && self.quote_span == rhs.quote_span
        && Eq::eq(&self.base_type, &rhs.base_type, arena)
        && Eq::eq(&self.variants, &rhs.variants, arena)
    }
}

impl<'a> Eq for EnumDefVariant<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.name == rhs.name
        && Eq::eq(&self.value, &rhs.value, arena)
    }
}

impl<'a> Eq for Expr<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        match (self, rhs) {
            (Expr::Lit(lhs), Expr::Lit(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::Path(lhs), Expr::Path(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::Paren(lhs), Expr::Paren(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::Tuple(lhs), Expr::Tuple(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::Array(lhs), Expr::Array(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::Call(lhs), Expr::Call(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::ArrayIndex(lhs), Expr::ArrayIndex(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::TupleIndex(lhs), Expr::TupleIndex(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::Member(lhs), Expr::Member(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::Object(lhs), Expr::Object(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::Unary(lhs), Expr::Unary(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::Binary(lhs), Expr::Binary(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::RangeBoth(lhs), Expr::RangeBoth(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::RangeFull(lhs), Expr::RangeFull(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::RangeLeft(lhs), Expr::RangeLeft(rhs)) => Eq::eq(lhs, rhs, arena),
            (Expr::RangeRight(lhs), Expr::RangeRight(rhs)) => Eq::eq(lhs, rhs, arena),
            _ => false,
        }
    }
}

impl<'a> Eq for FieldDef<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.name == rhs.name
        && self.colon_span == rhs.colon_span
        && Eq::eq(&self.r#type, &rhs.r#type, arena)
    }
}

impl<'a> Eq for FnDef<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.quote_span == rhs.quote_span
        && Eq::eq(&self.name, &rhs.name, arena)
        && Eq::eq(&self.parameters, &rhs.parameters, arena)
        && Eq::eq(&self.ret_type, &rhs.ret_type, arena)
        && Eq::eq(&self.wheres, &rhs.wheres, arena)
        && Eq::eq(&self.body, &rhs.body, arena)
    }
}

impl<'a> Eq for FnDefParameter<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.name == rhs.name
        && Eq::eq(&self.r#type, &rhs.r#type, arena)
    }
}

impl<'a> Eq for FnType<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.quote_span == rhs.quote_span
        && Eq::eq(&self.parameters, &rhs.parameters, arena)
        && Eq::eq(&self.ret_type, &rhs.ret_type, arena)
    }
}

impl<'a> Eq for FnTypeParameter<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.name == rhs.name
        && Eq::eq(&self.r#type, &rhs.r#type, arena)
    }
}

impl<'a> Eq for ForStatement<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.label == rhs.label
        && self.iter_name == rhs.iter_name
        && Eq::eq(&self.iter_expr, &rhs.iter_expr, arena)
        && Eq::eq(&self.body, &rhs.body, arena)
    }
}

impl<'a> Eq for GenericName<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.base == rhs.base
        && self.quote_span == rhs.quote_span
        && Eq::eq(&self.parameters, &rhs.parameters, arena)
    }
}

impl Eq for GenericParameter {
    fn eq(&self, rhs: &Self, _: &Arena) -> bool {
        self.span == rhs.span
        && self.name == rhs.name
    }
}

impl<'a> Eq for GenericSegment<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.base == rhs.base
        && Eq::eq(&self.parameters, &rhs.parameters, arena)
    }
}

impl<'a> Eq for IfClause<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && Eq::eq(&self.condition, &rhs.condition, arena)
        && Eq::eq(&self.body, &rhs.body, arena)
    }
}

impl<'a> Eq for IfStatement<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && Eq::eq(&self.if_clause, &rhs.if_clause, arena)
        && Eq::eq(&self.elseif_clauses, &rhs.elseif_clauses, arena)
        && Eq::eq(&self.else_clause, &rhs.else_clause, arena)
    }
}

impl<'a> Eq for Implementation<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.quote_span == rhs.quote_span
        && Eq::eq(&self.parameters, &rhs.parameters, arena)
        && Eq::eq(&self.class, &rhs.class, arena)
        && Eq::eq(&self.r#type, &rhs.r#type, arena)
        && Eq::eq(&self.wheres, &rhs.wheres, arena)
        && Eq::eq(&self.items, &rhs.items, arena)
    }
}

impl<'a> Eq for Item<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        match (self, rhs) {
            (Item::Struct(lhs), Item::Struct(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::Enum(lhs), Item::Enum(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::Fn(lhs), Item::Fn(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::Impl(lhs), Item::Impl(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::Type(lhs), Item::Type(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::Class(lhs), Item::Class(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::Block(lhs), Item::Block(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::SimpleExpr(lhs), Item::SimpleExpr(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::AssignExpr(lhs), Item::AssignExpr(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::For(lhs), Item::For(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::If(lhs), Item::If(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::Loop(lhs), Item::Loop(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::VarDecl(lhs), Item::VarDecl(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::While(lhs), Item::While(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::Use(lhs), Item::Use(rhs)) => Eq::eq(lhs, rhs, arena),
            (Item::Import(lhs), Item::Import(rhs)) => Eq::eq(lhs, rhs, arena),
            _ => false,
        }
    }
}

impl Eq for LitExpr {
    fn eq(&self, rhs: &Self, _: &Arena) -> bool {
        self.span == rhs.span
        && self.value == rhs.value
    }
}

impl<'a> Eq for LoopStatement<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.label == rhs.label
        && Eq::eq(&self.body, &rhs.body, arena)
    }
}

impl<'a> Eq for MemberExpr<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.op_span == rhs.op_span
        && self.name == rhs.name
        && Eq::eq(&self.base, &rhs.base, arena)
        && Eq::eq(&self.parameters, &rhs.parameters, arena)
    }
}

impl<'a> Eq for Module<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.file == rhs.file
        && Eq::eq(&self.items, &rhs.items, arena)
    }
}

impl Eq for ModuleStatement {
    fn eq(&self, rhs: &Self, _: &Arena) -> bool {
        self.span == rhs.span
        && self.name == rhs.name
        && self.path == rhs.path
    }
}

impl<'a> Eq for ObjectExpr<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.quote_span == rhs.quote_span
        && Eq::eq(&self.base, &rhs.base, arena)
        && Eq::eq(&self.fields, &rhs.fields, arena)
    }
}

impl<'a> Eq for ObjectExprField<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.name == rhs.name
        && Eq::eq(&self.value, &rhs.value, arena)
    }
}

impl<'a> Eq for ParenExpr<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && Eq::eq(&self.base, &rhs.base, arena)
    }
}

impl<'a> Eq for Path<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && Eq::eq(&self.segments, &rhs.segments, arena)
    }
}

impl<'a> Eq for PathSegment<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        match (self, rhs) {
            (PathSegment::Global, PathSegment::Global) => true,
            (PathSegment::Simple(lhs), PathSegment::Simple(rhs)) => Eq::eq(lhs, rhs, arena),
            (PathSegment::Cast(lhs), PathSegment::Cast(rhs)) => Eq::eq(lhs, rhs, arena),
            (PathSegment::Generic(lhs), PathSegment::Generic(rhs)) => Eq::eq(lhs, rhs, arena),
            _ => false,
        }
    }
}

impl Eq for PrimitiveType {
    fn eq(&self, rhs: &Self, _: &Arena) -> bool {
        self.span == rhs.span
        && self.base == rhs.base
    }
}

impl<'a> Eq for RangeBothExpr<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.op_span == rhs.op_span
        && Eq::eq(&self.left, &rhs.left, arena)
        && Eq::eq(&self.right, &rhs.right, arena)
    }
}

impl Eq for RangeFullExpr {
    fn eq(&self, rhs: &Self, _: &Arena) -> bool {
        self.span == rhs.span
    }
}

impl<'a> Eq for RangeLeftExpr<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && Eq::eq(&self.base, &rhs.base, arena)
    }
}

impl<'a> Eq for RangeRightExpr<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && Eq::eq(&self.base, &rhs.base, arena)
    }
}

impl<'a> Eq for RefType<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && Eq::eq(&self.base, &rhs.base, arena)
    }
}

impl<'a> Eq for ReturnStatement<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && Eq::eq(&self.value, &rhs.value, arena)
    }
}

impl<'a> Eq for SimpleExprStatement<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && Eq::eq(&self.expr, &rhs.expr, arena)
    }
}

impl Eq for SimpleSegment {
    fn eq(&self, rhs: &Self, _: &Arena) -> bool {
        self.span == rhs.span
        && self.name == rhs.name
    }
}

impl<'a> Eq for Statement<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        match (self, rhs) {
            (Statement::Struct(lhs), Statement::Struct(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::Enum(lhs), Statement::Enum(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::Fn(lhs), Statement::Fn(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::Impl(lhs), Statement::Impl(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::Type(lhs), Statement::Type(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::Class(lhs), Statement::Class(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::Block(lhs), Statement::Block(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::Break(lhs), Statement::Break(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::Continue(lhs), Statement::Continue(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::SimpleExpr(lhs), Statement::SimpleExpr(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::AssignExpr(lhs), Statement::AssignExpr(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::For(lhs), Statement::For(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::If(lhs), Statement::If(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::Loop(lhs), Statement::Loop(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::Return(lhs), Statement::Return(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::VarDecl(lhs), Statement::VarDecl(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::While(lhs), Statement::While(rhs)) => Eq::eq(lhs, rhs, arena),
            (Statement::Use(lhs), Statement::Use(rhs)) => Eq::eq(lhs, rhs, arena),
            _ => false,
        }
    }
}

impl<'a> Eq for StructDef<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && Eq::eq(&self.name, &rhs.name, arena)
        && Eq::eq(&self.fields, &rhs.fields, arena)
    }
}

impl<'a> Eq for TupleExpr<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && Eq::eq(&self.items, &rhs.items, arena)
    }
}

impl<'a> Eq for TupleIndexExpr<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.op_span == rhs.op_span
        && self.value == rhs.value
        && self.value_span == rhs.value_span
        && Eq::eq(&self.base, &rhs.base, arena)
    }
}

impl<'a> Eq for TupleType<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && Eq::eq(&self.parameters, &rhs.parameters, arena)
    }
}

impl<'a> Eq for TypeDef<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && Eq::eq(&self.name, &rhs.name, arena)
        && Eq::eq(&self.from, &rhs.from, arena)
    }
}

impl<'a> Eq for TypeList<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && Eq::eq(&self.items, &rhs.items, arena)
    }
}

impl<'a> Eq for TypeRef<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        match (self, rhs) {
            (TypeRef::Array(lhs), TypeRef::Array(rhs)) => Eq::eq(lhs, rhs, arena),
            (TypeRef::Fn(lhs), TypeRef::Fn(rhs)) => Eq::eq(lhs, rhs, arena),
            (TypeRef::Path(lhs), TypeRef::Path(rhs)) => Eq::eq(lhs, rhs, arena),
            (TypeRef::Primitive(lhs), TypeRef::Primitive(rhs)) => Eq::eq(lhs, rhs, arena),
            (TypeRef::Ref(lhs), TypeRef::Ref(rhs)) => Eq::eq(lhs, rhs, arena),
            (TypeRef::Tuple(lhs), TypeRef::Tuple(rhs)) => Eq::eq(lhs, rhs, arena),
            _ => false,
        }
    }
}

impl<'a> Eq for UnaryExpr<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.op == rhs.op
        && self.op_span == rhs.op_span
        && Eq::eq(&self.base, &rhs.base, arena)
    }
}

impl<'a> Eq for UseStatement<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.alias == rhs.alias
        && Eq::eq(&self.path, &rhs.path, arena)
    }
}

impl<'a> Eq for VarDeclStatement<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.r#const == rhs.r#const
        && self.name == rhs.name
        && Eq::eq(&self.r#type, &rhs.r#type, arena)
        && Eq::eq(&self.init_value, &rhs.init_value, arena)
    }
}

impl<'a> Eq for WhereClause<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.name == rhs.name
        && Eq::eq(&self.constraints, &rhs.constraints, arena)
    }
}

impl<'a> Eq for WhileStatement<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.label == rhs.label
        && Eq::eq(&self.condition, &rhs.condition, arena)
        && Eq::eq(&self.body, &rhs.body, arena)
    }
}
