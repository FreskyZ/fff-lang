///! --------------------------------------------------------------------------------
///! This code is auto generated by a tool $repo/scripts/ast.py
///! Changes may cause incorrect behavior and will be lost if the code is regenerated
///! --------------------------------------------------------------------------------

///! equality compare with arena

use super::*;

// this is not Visitor, because visitor visits one node, not *a pair of node*
pub trait Eq {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool;
}

// special eq
macro_rules! seq {
    (index, $lhs:expr, $rhs:expr, $arena:expr) => (
        Eq::eq($arena.get(&$lhs), $arena.get(&$rhs), $arena)
    );
    (variant, $lhs:expr, $rhs:expr, $arena:expr) => (
        Eq::eq($arena.get($lhs), $arena.get($rhs), $arena)
    );
    (option, $lhs:expr, $rhs:expr, $arena:expr) => (
        $lhs.as_ref().zip($rhs.as_ref()).map(|(lhs, rhs)| Eq::eq($arena.get(lhs), $arena.get(rhs), $arena)).unwrap_or(false)
    );
    (slice, $lhs:expr, $rhs:expr, $arena:expr) => (
        $lhs.len() == $rhs.len() && std::iter::zip($arena.get_iter(&$lhs), $arena.get_iter(&$rhs)).all(|(lhs, rhs)| Eq::eq(lhs, rhs, $arena))
    );
}

// AUTOGEN
impl<'a> Eq for ArrayExpr<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && seq!(slice, self.items, rhs.items, arena)
    }
}

impl<'a> Eq for ArrayIndexExpr<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.quote_span == rhs.quote_span
        && seq!(index, self.base, rhs.base, arena)
        && seq!(slice, self.parameters, rhs.parameters, arena)
    }
}

impl<'a> Eq for ArrayType<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && seq!(index, self.base, rhs.base, arena)
        && seq!(index, self.size, rhs.size, arena)
    }
}

impl<'a> Eq for AssignExprStatement<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.op == rhs.op
        && self.op_span == rhs.op_span
        && seq!(index, self.left, rhs.left, arena)
        && seq!(index, self.right, rhs.right, arena)
    }
}

impl<'a> Eq for BinaryExpr<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.op == rhs.op
        && self.op_span == rhs.op_span
        && seq!(index, self.left, rhs.left, arena)
        && seq!(index, self.right, rhs.right, arena)
    }
}

impl<'a> Eq for Block<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && seq!(slice, self.items, rhs.items, arena)
    }
}

impl<'a> Eq for BlockStatement<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.label == rhs.label
        && seq!(index, self.body, rhs.body, arena)
    }
}

impl Eq for BreakStatement {
    fn eq(&self, rhs: &Self, _: &Arena) -> bool {
        self.span == rhs.span
        && self.label == rhs.label
    }
}

impl<'a> Eq for CallExpr<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.quote_span == rhs.quote_span
        && seq!(index, self.base, rhs.base, arena)
        && seq!(slice, self.parameters, rhs.parameters, arena)
    }
}

impl<'a> Eq for CastSegment<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && seq!(index, self.left, rhs.left, arena)
        && seq!(index, self.right, rhs.right, arena)
    }
}

impl<'a> Eq for ClassDef<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.quote_span == rhs.quote_span
        && seq!(index, self.name, rhs.name, arena)
        && seq!(slice, self.types, rhs.types, arena)
        && seq!(slice, self.functions, rhs.functions, arena)
    }
}

impl Eq for ContinueStatement {
    fn eq(&self, rhs: &Self, _: &Arena) -> bool {
        self.span == rhs.span
        && self.label == rhs.label
    }
}

impl<'a> Eq for ElseClause<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && seq!(index, self.body, rhs.body, arena)
    }
}

impl<'a> Eq for EnumDef<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.name == rhs.name
        && self.quote_span == rhs.quote_span
        && seq!(option, self.base_type, rhs.base_type, arena)
        && seq!(slice, self.variants, rhs.variants, arena)
    }
}

impl<'a> Eq for EnumDefVariant<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.name == rhs.name
        && seq!(option, self.value, rhs.value, arena)
    }
}

impl<'a> Eq for Expr<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        match (self, rhs) {
            (Expr::Lit(lhs), Expr::Lit(rhs)) => seq!(variant, lhs, rhs, arena),
            (Expr::Path(lhs), Expr::Path(rhs)) => seq!(variant, lhs, rhs, arena),
            (Expr::Paren(lhs), Expr::Paren(rhs)) => seq!(variant, lhs, rhs, arena),
            (Expr::Tuple(lhs), Expr::Tuple(rhs)) => seq!(variant, lhs, rhs, arena),
            (Expr::Array(lhs), Expr::Array(rhs)) => seq!(variant, lhs, rhs, arena),
            (Expr::Call(lhs), Expr::Call(rhs)) => seq!(variant, lhs, rhs, arena),
            (Expr::ArrayIndex(lhs), Expr::ArrayIndex(rhs)) => seq!(variant, lhs, rhs, arena),
            (Expr::TupleIndex(lhs), Expr::TupleIndex(rhs)) => seq!(variant, lhs, rhs, arena),
            (Expr::Member(lhs), Expr::Member(rhs)) => seq!(variant, lhs, rhs, arena),
            (Expr::Object(lhs), Expr::Object(rhs)) => seq!(variant, lhs, rhs, arena),
            (Expr::Unary(lhs), Expr::Unary(rhs)) => seq!(variant, lhs, rhs, arena),
            (Expr::Binary(lhs), Expr::Binary(rhs)) => seq!(variant, lhs, rhs, arena),
            (Expr::RangeBoth(lhs), Expr::RangeBoth(rhs)) => seq!(variant, lhs, rhs, arena),
            (Expr::RangeFull(lhs), Expr::RangeFull(rhs)) => seq!(variant, lhs, rhs, arena),
            (Expr::RangeLeft(lhs), Expr::RangeLeft(rhs)) => seq!(variant, lhs, rhs, arena),
            (Expr::RangeRight(lhs), Expr::RangeRight(rhs)) => seq!(variant, lhs, rhs, arena),
            _ => false,
        }
    }
}

impl<'a> Eq for FieldDef<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.name == rhs.name
        && self.colon_span == rhs.colon_span
        && seq!(index, self.r#type, rhs.r#type, arena)
    }
}

impl<'a> Eq for FnDef<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.quote_span == rhs.quote_span
        && seq!(index, self.name, rhs.name, arena)
        && seq!(slice, self.parameters, rhs.parameters, arena)
        && seq!(option, self.ret_type, rhs.ret_type, arena)
        && seq!(slice, self.wheres, rhs.wheres, arena)
        && seq!(option, self.body, rhs.body, arena)
    }
}

impl<'a> Eq for FnDefParameter<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.name == rhs.name
        && seq!(index, self.r#type, rhs.r#type, arena)
    }
}

impl<'a> Eq for FnType<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.quote_span == rhs.quote_span
        && seq!(slice, self.parameters, rhs.parameters, arena)
        && seq!(option, self.ret_type, rhs.ret_type, arena)
    }
}

impl<'a> Eq for FnTypeParameter<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.name == rhs.name
        && seq!(index, self.r#type, rhs.r#type, arena)
    }
}

impl<'a> Eq for ForStatement<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.label == rhs.label
        && self.iter_name == rhs.iter_name
        && seq!(index, self.iter_expr, rhs.iter_expr, arena)
        && seq!(index, self.body, rhs.body, arena)
    }
}

impl<'a> Eq for GenericName<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.base == rhs.base
        && self.quote_span == rhs.quote_span
        && seq!(slice, self.parameters, rhs.parameters, arena)
    }
}

impl Eq for GenericParameter {
    fn eq(&self, rhs: &Self, _: &Arena) -> bool {
        self.span == rhs.span
        && self.name == rhs.name
    }
}

impl<'a> Eq for GenericSegment<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.base == rhs.base
        && seq!(index, self.parameters, rhs.parameters, arena)
    }
}

impl<'a> Eq for IfClause<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && seq!(index, self.condition, rhs.condition, arena)
        && seq!(index, self.body, rhs.body, arena)
    }
}

impl<'a> Eq for IfStatement<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && seq!(index, self.if_clause, rhs.if_clause, arena)
        && seq!(slice, self.elseif_clauses, rhs.elseif_clauses, arena)
        && seq!(option, self.else_clause, rhs.else_clause, arena)
    }
}

impl<'a> Eq for Implementation<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.quote_span == rhs.quote_span
        && seq!(slice, self.parameters, rhs.parameters, arena)
        && seq!(option, self.class, rhs.class, arena)
        && seq!(index, self.r#type, rhs.r#type, arena)
        && seq!(slice, self.wheres, rhs.wheres, arena)
        && seq!(slice, self.types, rhs.types, arena)
        && seq!(slice, self.functions, rhs.functions, arena)
    }
}

impl<'a> Eq for Item<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        match (self, rhs) {
            (Item::Struct(lhs), Item::Struct(rhs)) => seq!(variant, lhs, rhs, arena),
            (Item::Enum(lhs), Item::Enum(rhs)) => seq!(variant, lhs, rhs, arena),
            (Item::Fn(lhs), Item::Fn(rhs)) => seq!(variant, lhs, rhs, arena),
            (Item::Impl(lhs), Item::Impl(rhs)) => seq!(variant, lhs, rhs, arena),
            (Item::Type(lhs), Item::Type(rhs)) => seq!(variant, lhs, rhs, arena),
            (Item::Class(lhs), Item::Class(rhs)) => seq!(variant, lhs, rhs, arena),
            (Item::Block(lhs), Item::Block(rhs)) => seq!(variant, lhs, rhs, arena),
            (Item::SimpleExpr(lhs), Item::SimpleExpr(rhs)) => seq!(variant, lhs, rhs, arena),
            (Item::AssignExpr(lhs), Item::AssignExpr(rhs)) => seq!(variant, lhs, rhs, arena),
            (Item::For(lhs), Item::For(rhs)) => seq!(variant, lhs, rhs, arena),
            (Item::If(lhs), Item::If(rhs)) => seq!(variant, lhs, rhs, arena),
            (Item::Loop(lhs), Item::Loop(rhs)) => seq!(variant, lhs, rhs, arena),
            (Item::VarDecl(lhs), Item::VarDecl(rhs)) => seq!(variant, lhs, rhs, arena),
            (Item::While(lhs), Item::While(rhs)) => seq!(variant, lhs, rhs, arena),
            (Item::Use(lhs), Item::Use(rhs)) => seq!(variant, lhs, rhs, arena),
            (Item::Import(lhs), Item::Import(rhs)) => seq!(variant, lhs, rhs, arena),
            _ => false,
        }
    }
}

impl Eq for LitExpr {
    fn eq(&self, rhs: &Self, _: &Arena) -> bool {
        self.span == rhs.span
        && self.value == rhs.value
    }
}

impl<'a> Eq for LoopStatement<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.label == rhs.label
        && seq!(index, self.body, rhs.body, arena)
    }
}

impl<'a> Eq for MemberExpr<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.op_span == rhs.op_span
        && self.name == rhs.name
        && seq!(index, self.base, rhs.base, arena)
        && seq!(option, self.parameters, rhs.parameters, arena)
    }
}

impl<'a> Eq for Module<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.file == rhs.file
        && seq!(slice, self.items, rhs.items, arena)
    }
}

impl Eq for ModuleStatement {
    fn eq(&self, rhs: &Self, _: &Arena) -> bool {
        self.span == rhs.span
        && self.name == rhs.name
        && self.path == rhs.path
    }
}

impl<'a> Eq for ObjectExpr<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.quote_span == rhs.quote_span
        && seq!(index, self.base, rhs.base, arena)
        && seq!(slice, self.fields, rhs.fields, arena)
    }
}

impl<'a> Eq for ObjectExprField<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.name == rhs.name
        && seq!(index, self.value, rhs.value, arena)
    }
}

impl<'a> Eq for ParenExpr<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && seq!(index, self.base, rhs.base, arena)
    }
}

impl<'a> Eq for Path<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && seq!(slice, self.segments, rhs.segments, arena)
    }
}

impl<'a> Eq for PathSegment<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        match (self, rhs) {
            (PathSegment::Global, PathSegment::Global) => true,
            (PathSegment::Simple(lhs), PathSegment::Simple(rhs)) => seq!(variant, lhs, rhs, arena),
            (PathSegment::Cast(lhs), PathSegment::Cast(rhs)) => seq!(variant, lhs, rhs, arena),
            (PathSegment::Generic(lhs), PathSegment::Generic(rhs)) => seq!(variant, lhs, rhs, arena),
            _ => false,
        }
    }
}

impl Eq for PrimitiveType {
    fn eq(&self, rhs: &Self, _: &Arena) -> bool {
        self.span == rhs.span
        && self.base == rhs.base
    }
}

impl<'a> Eq for RangeBothExpr<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.op_span == rhs.op_span
        && seq!(index, self.left, rhs.left, arena)
        && seq!(index, self.right, rhs.right, arena)
    }
}

impl Eq for RangeFullExpr {
    fn eq(&self, rhs: &Self, _: &Arena) -> bool {
        self.span == rhs.span
    }
}

impl<'a> Eq for RangeLeftExpr<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && seq!(index, self.base, rhs.base, arena)
    }
}

impl<'a> Eq for RangeRightExpr<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && seq!(index, self.base, rhs.base, arena)
    }
}

impl<'a> Eq for RefType<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && seq!(index, self.base, rhs.base, arena)
    }
}

impl<'a> Eq for ReturnStatement<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && seq!(option, self.value, rhs.value, arena)
    }
}

impl<'a> Eq for SimpleExprStatement<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && seq!(index, self.expr, rhs.expr, arena)
    }
}

impl Eq for SimpleSegment {
    fn eq(&self, rhs: &Self, _: &Arena) -> bool {
        self.span == rhs.span
        && self.name == rhs.name
    }
}

impl<'a> Eq for Statement<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        match (self, rhs) {
            (Statement::Struct(lhs), Statement::Struct(rhs)) => seq!(variant, lhs, rhs, arena),
            (Statement::Enum(lhs), Statement::Enum(rhs)) => seq!(variant, lhs, rhs, arena),
            (Statement::Fn(lhs), Statement::Fn(rhs)) => seq!(variant, lhs, rhs, arena),
            (Statement::Impl(lhs), Statement::Impl(rhs)) => seq!(variant, lhs, rhs, arena),
            (Statement::Type(lhs), Statement::Type(rhs)) => seq!(variant, lhs, rhs, arena),
            (Statement::Class(lhs), Statement::Class(rhs)) => seq!(variant, lhs, rhs, arena),
            (Statement::Block(lhs), Statement::Block(rhs)) => seq!(variant, lhs, rhs, arena),
            (Statement::Break(lhs), Statement::Break(rhs)) => seq!(variant, lhs, rhs, arena),
            (Statement::Continue(lhs), Statement::Continue(rhs)) => seq!(variant, lhs, rhs, arena),
            (Statement::SimpleExpr(lhs), Statement::SimpleExpr(rhs)) => seq!(variant, lhs, rhs, arena),
            (Statement::AssignExpr(lhs), Statement::AssignExpr(rhs)) => seq!(variant, lhs, rhs, arena),
            (Statement::For(lhs), Statement::For(rhs)) => seq!(variant, lhs, rhs, arena),
            (Statement::If(lhs), Statement::If(rhs)) => seq!(variant, lhs, rhs, arena),
            (Statement::Loop(lhs), Statement::Loop(rhs)) => seq!(variant, lhs, rhs, arena),
            (Statement::Return(lhs), Statement::Return(rhs)) => seq!(variant, lhs, rhs, arena),
            (Statement::VarDecl(lhs), Statement::VarDecl(rhs)) => seq!(variant, lhs, rhs, arena),
            (Statement::While(lhs), Statement::While(rhs)) => seq!(variant, lhs, rhs, arena),
            (Statement::Use(lhs), Statement::Use(rhs)) => seq!(variant, lhs, rhs, arena),
            _ => false,
        }
    }
}

impl<'a> Eq for StructDef<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && seq!(index, self.name, rhs.name, arena)
        && seq!(slice, self.fields, rhs.fields, arena)
    }
}

impl<'a> Eq for TupleExpr<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && seq!(slice, self.items, rhs.items, arena)
    }
}

impl<'a> Eq for TupleIndexExpr<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.op_span == rhs.op_span
        && self.value == rhs.value
        && self.value_span == rhs.value_span
        && seq!(index, self.base, rhs.base, arena)
    }
}

impl<'a> Eq for TupleType<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && seq!(slice, self.parameters, rhs.parameters, arena)
    }
}

impl<'a> Eq for TypeDef<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && seq!(index, self.name, rhs.name, arena)
        && seq!(option, self.from, rhs.from, arena)
    }
}

impl<'a> Eq for TypeList<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && seq!(slice, self.items, rhs.items, arena)
    }
}

impl<'a> Eq for TypeRef<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        match (self, rhs) {
            (TypeRef::Array(lhs), TypeRef::Array(rhs)) => seq!(variant, lhs, rhs, arena),
            (TypeRef::Fn(lhs), TypeRef::Fn(rhs)) => seq!(variant, lhs, rhs, arena),
            (TypeRef::Path(lhs), TypeRef::Path(rhs)) => seq!(variant, lhs, rhs, arena),
            (TypeRef::Primitive(lhs), TypeRef::Primitive(rhs)) => seq!(variant, lhs, rhs, arena),
            (TypeRef::Ref(lhs), TypeRef::Ref(rhs)) => seq!(variant, lhs, rhs, arena),
            (TypeRef::Tuple(lhs), TypeRef::Tuple(rhs)) => seq!(variant, lhs, rhs, arena),
            _ => false,
        }
    }
}

impl<'a> Eq for UnaryExpr<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.op == rhs.op
        && self.op_span == rhs.op_span
        && seq!(index, self.base, rhs.base, arena)
    }
}

impl<'a> Eq for UseStatement<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.alias == rhs.alias
        && seq!(index, self.path, rhs.path, arena)
    }
}

impl<'a> Eq for VarDeclStatement<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.r#const == rhs.r#const
        && self.name == rhs.name
        && seq!(option, self.r#type, rhs.r#type, arena)
        && seq!(option, self.init_value, rhs.init_value, arena)
    }
}

impl<'a> Eq for WhereClause<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.name == rhs.name
        && seq!(slice, self.constraints, rhs.constraints, arena)
    }
}

impl<'a> Eq for WhileStatement<'a> {
    fn eq(&self, rhs: &Self, arena: &Arena) -> bool {
        self.span == rhs.span
        && self.label == rhs.label
        && seq!(index, self.condition, rhs.condition, arena)
        && seq!(index, self.body, rhs.body, arena)
    }
}
