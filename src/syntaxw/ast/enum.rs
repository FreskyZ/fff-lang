///! ---------------------------------------------------------------------------------
///! This code is auto generated by a tool $repo/scripts/ast.py
///! Changes may cause incorrect behavior and will be lost if the code is regenerated.
///! ---------------------------------------------------------------------------------

///! enum additional methods include
///! - span(arena) method with help of WithSpan trait and delegate of tagged index
///! - TagIndex::from(variant_index) method
///!   - not impl From<U> for TagIndex because it does not have
///!     any constraint and will implement for everything and will disrupt other .into() resolution
///!   - not impl From<ConcreteEnum> for TagIndex because normal usage will
///!     always look like Enum::Variant(variant_index).into(), so just use shorthand

use super::*;

pub trait WithSpan {
    fn span(&self, arena: &Arena) -> Span;
}

impl<'a, U> WithSpan for TagIndex<'a, U> where U: WithSpan {
    fn span(&self, arena: &Arena) -> Span {
        self.as_repr().as_ref().span(arena)
    }
}

// AUTOGEN
impl<'a> From<Index<'a, LitExpr>> for TagIndex<'a, Expr<'a>> {
    fn from(v: Index<'a, LitExpr>) -> Self {
        TagIndex::new(Expr::Lit(v))
    }
}

impl<'a> From<Index<'a, Path<'a>>> for TagIndex<'a, Expr<'a>> {
    fn from(v: Index<'a, Path<'a>>) -> Self {
        TagIndex::new(Expr::Path(v))
    }
}

impl<'a> From<Index<'a, ParenExpr<'a>>> for TagIndex<'a, Expr<'a>> {
    fn from(v: Index<'a, ParenExpr<'a>>) -> Self {
        TagIndex::new(Expr::Paren(v))
    }
}

impl<'a> From<Index<'a, TupleExpr<'a>>> for TagIndex<'a, Expr<'a>> {
    fn from(v: Index<'a, TupleExpr<'a>>) -> Self {
        TagIndex::new(Expr::Tuple(v))
    }
}

impl<'a> From<Index<'a, ArrayExpr<'a>>> for TagIndex<'a, Expr<'a>> {
    fn from(v: Index<'a, ArrayExpr<'a>>) -> Self {
        TagIndex::new(Expr::Array(v))
    }
}

impl<'a> From<Index<'a, CallExpr<'a>>> for TagIndex<'a, Expr<'a>> {
    fn from(v: Index<'a, CallExpr<'a>>) -> Self {
        TagIndex::new(Expr::Call(v))
    }
}

impl<'a> From<Index<'a, ArrayIndexExpr<'a>>> for TagIndex<'a, Expr<'a>> {
    fn from(v: Index<'a, ArrayIndexExpr<'a>>) -> Self {
        TagIndex::new(Expr::ArrayIndex(v))
    }
}

impl<'a> From<Index<'a, TupleIndexExpr<'a>>> for TagIndex<'a, Expr<'a>> {
    fn from(v: Index<'a, TupleIndexExpr<'a>>) -> Self {
        TagIndex::new(Expr::TupleIndex(v))
    }
}

impl<'a> From<Index<'a, MemberExpr<'a>>> for TagIndex<'a, Expr<'a>> {
    fn from(v: Index<'a, MemberExpr<'a>>) -> Self {
        TagIndex::new(Expr::Member(v))
    }
}

impl<'a> From<Index<'a, ObjectExpr<'a>>> for TagIndex<'a, Expr<'a>> {
    fn from(v: Index<'a, ObjectExpr<'a>>) -> Self {
        TagIndex::new(Expr::Object(v))
    }
}

impl<'a> From<Index<'a, UnaryExpr<'a>>> for TagIndex<'a, Expr<'a>> {
    fn from(v: Index<'a, UnaryExpr<'a>>) -> Self {
        TagIndex::new(Expr::Unary(v))
    }
}

impl<'a> From<Index<'a, BinaryExpr<'a>>> for TagIndex<'a, Expr<'a>> {
    fn from(v: Index<'a, BinaryExpr<'a>>) -> Self {
        TagIndex::new(Expr::Binary(v))
    }
}

impl<'a> From<Index<'a, RangeBothExpr<'a>>> for TagIndex<'a, Expr<'a>> {
    fn from(v: Index<'a, RangeBothExpr<'a>>) -> Self {
        TagIndex::new(Expr::RangeBoth(v))
    }
}

impl<'a> From<Index<'a, RangeFullExpr>> for TagIndex<'a, Expr<'a>> {
    fn from(v: Index<'a, RangeFullExpr>) -> Self {
        TagIndex::new(Expr::RangeFull(v))
    }
}

impl<'a> From<Index<'a, RangeLeftExpr<'a>>> for TagIndex<'a, Expr<'a>> {
    fn from(v: Index<'a, RangeLeftExpr<'a>>) -> Self {
        TagIndex::new(Expr::RangeLeft(v))
    }
}

impl<'a> From<Index<'a, RangeRightExpr<'a>>> for TagIndex<'a, Expr<'a>> {
    fn from(v: Index<'a, RangeRightExpr<'a>>) -> Self {
        TagIndex::new(Expr::RangeRight(v))
    }
}

impl<'a> From<Index<'a, StructDef<'a>>> for TagIndex<'a, Item<'a>> {
    fn from(v: Index<'a, StructDef<'a>>) -> Self {
        TagIndex::new(Item::Struct(v))
    }
}

impl<'a> From<Index<'a, EnumDef<'a>>> for TagIndex<'a, Item<'a>> {
    fn from(v: Index<'a, EnumDef<'a>>) -> Self {
        TagIndex::new(Item::Enum(v))
    }
}

impl<'a> From<Index<'a, FnDef<'a>>> for TagIndex<'a, Item<'a>> {
    fn from(v: Index<'a, FnDef<'a>>) -> Self {
        TagIndex::new(Item::Fn(v))
    }
}

impl<'a> From<Index<'a, Implementation<'a>>> for TagIndex<'a, Item<'a>> {
    fn from(v: Index<'a, Implementation<'a>>) -> Self {
        TagIndex::new(Item::Impl(v))
    }
}

impl<'a> From<Index<'a, TypeDef<'a>>> for TagIndex<'a, Item<'a>> {
    fn from(v: Index<'a, TypeDef<'a>>) -> Self {
        TagIndex::new(Item::Type(v))
    }
}

impl<'a> From<Index<'a, ClassDef<'a>>> for TagIndex<'a, Item<'a>> {
    fn from(v: Index<'a, ClassDef<'a>>) -> Self {
        TagIndex::new(Item::Class(v))
    }
}

impl<'a> From<Index<'a, BlockStatement<'a>>> for TagIndex<'a, Item<'a>> {
    fn from(v: Index<'a, BlockStatement<'a>>) -> Self {
        TagIndex::new(Item::Block(v))
    }
}

impl<'a> From<Index<'a, SimpleExprStatement<'a>>> for TagIndex<'a, Item<'a>> {
    fn from(v: Index<'a, SimpleExprStatement<'a>>) -> Self {
        TagIndex::new(Item::SimpleExpr(v))
    }
}

impl<'a> From<Index<'a, AssignExprStatement<'a>>> for TagIndex<'a, Item<'a>> {
    fn from(v: Index<'a, AssignExprStatement<'a>>) -> Self {
        TagIndex::new(Item::AssignExpr(v))
    }
}

impl<'a> From<Index<'a, ForStatement<'a>>> for TagIndex<'a, Item<'a>> {
    fn from(v: Index<'a, ForStatement<'a>>) -> Self {
        TagIndex::new(Item::For(v))
    }
}

impl<'a> From<Index<'a, IfStatement<'a>>> for TagIndex<'a, Item<'a>> {
    fn from(v: Index<'a, IfStatement<'a>>) -> Self {
        TagIndex::new(Item::If(v))
    }
}

impl<'a> From<Index<'a, LoopStatement<'a>>> for TagIndex<'a, Item<'a>> {
    fn from(v: Index<'a, LoopStatement<'a>>) -> Self {
        TagIndex::new(Item::Loop(v))
    }
}

impl<'a> From<Index<'a, VarDeclStatement<'a>>> for TagIndex<'a, Item<'a>> {
    fn from(v: Index<'a, VarDeclStatement<'a>>) -> Self {
        TagIndex::new(Item::VarDecl(v))
    }
}

impl<'a> From<Index<'a, WhileStatement<'a>>> for TagIndex<'a, Item<'a>> {
    fn from(v: Index<'a, WhileStatement<'a>>) -> Self {
        TagIndex::new(Item::While(v))
    }
}

impl<'a> From<Index<'a, UseStatement<'a>>> for TagIndex<'a, Item<'a>> {
    fn from(v: Index<'a, UseStatement<'a>>) -> Self {
        TagIndex::new(Item::Use(v))
    }
}

impl<'a> From<Index<'a, ModuleStatement>> for TagIndex<'a, Item<'a>> {
    fn from(v: Index<'a, ModuleStatement>) -> Self {
        TagIndex::new(Item::Import(v))
    }
}

impl<'a> From<Index<'a, SimpleSegment>> for TagIndex<'a, PathSegment<'a>> {
    fn from(v: Index<'a, SimpleSegment>) -> Self {
        TagIndex::new(PathSegment::Simple(v))
    }
}

impl<'a> From<Index<'a, CastSegment<'a>>> for TagIndex<'a, PathSegment<'a>> {
    fn from(v: Index<'a, CastSegment<'a>>) -> Self {
        TagIndex::new(PathSegment::Cast(v))
    }
}

impl<'a> From<Index<'a, GenericSegment<'a>>> for TagIndex<'a, PathSegment<'a>> {
    fn from(v: Index<'a, GenericSegment<'a>>) -> Self {
        TagIndex::new(PathSegment::Generic(v))
    }
}

impl<'a> From<Index<'a, StructDef<'a>>> for TagIndex<'a, Statement<'a>> {
    fn from(v: Index<'a, StructDef<'a>>) -> Self {
        TagIndex::new(Statement::Struct(v))
    }
}

impl<'a> From<Index<'a, EnumDef<'a>>> for TagIndex<'a, Statement<'a>> {
    fn from(v: Index<'a, EnumDef<'a>>) -> Self {
        TagIndex::new(Statement::Enum(v))
    }
}

impl<'a> From<Index<'a, FnDef<'a>>> for TagIndex<'a, Statement<'a>> {
    fn from(v: Index<'a, FnDef<'a>>) -> Self {
        TagIndex::new(Statement::Fn(v))
    }
}

impl<'a> From<Index<'a, Implementation<'a>>> for TagIndex<'a, Statement<'a>> {
    fn from(v: Index<'a, Implementation<'a>>) -> Self {
        TagIndex::new(Statement::Impl(v))
    }
}

impl<'a> From<Index<'a, TypeDef<'a>>> for TagIndex<'a, Statement<'a>> {
    fn from(v: Index<'a, TypeDef<'a>>) -> Self {
        TagIndex::new(Statement::Type(v))
    }
}

impl<'a> From<Index<'a, ClassDef<'a>>> for TagIndex<'a, Statement<'a>> {
    fn from(v: Index<'a, ClassDef<'a>>) -> Self {
        TagIndex::new(Statement::Class(v))
    }
}

impl<'a> From<Index<'a, BlockStatement<'a>>> for TagIndex<'a, Statement<'a>> {
    fn from(v: Index<'a, BlockStatement<'a>>) -> Self {
        TagIndex::new(Statement::Block(v))
    }
}

impl<'a> From<Index<'a, BreakStatement>> for TagIndex<'a, Statement<'a>> {
    fn from(v: Index<'a, BreakStatement>) -> Self {
        TagIndex::new(Statement::Break(v))
    }
}

impl<'a> From<Index<'a, ContinueStatement>> for TagIndex<'a, Statement<'a>> {
    fn from(v: Index<'a, ContinueStatement>) -> Self {
        TagIndex::new(Statement::Continue(v))
    }
}

impl<'a> From<Index<'a, SimpleExprStatement<'a>>> for TagIndex<'a, Statement<'a>> {
    fn from(v: Index<'a, SimpleExprStatement<'a>>) -> Self {
        TagIndex::new(Statement::SimpleExpr(v))
    }
}

impl<'a> From<Index<'a, AssignExprStatement<'a>>> for TagIndex<'a, Statement<'a>> {
    fn from(v: Index<'a, AssignExprStatement<'a>>) -> Self {
        TagIndex::new(Statement::AssignExpr(v))
    }
}

impl<'a> From<Index<'a, ForStatement<'a>>> for TagIndex<'a, Statement<'a>> {
    fn from(v: Index<'a, ForStatement<'a>>) -> Self {
        TagIndex::new(Statement::For(v))
    }
}

impl<'a> From<Index<'a, IfStatement<'a>>> for TagIndex<'a, Statement<'a>> {
    fn from(v: Index<'a, IfStatement<'a>>) -> Self {
        TagIndex::new(Statement::If(v))
    }
}

impl<'a> From<Index<'a, LoopStatement<'a>>> for TagIndex<'a, Statement<'a>> {
    fn from(v: Index<'a, LoopStatement<'a>>) -> Self {
        TagIndex::new(Statement::Loop(v))
    }
}

impl<'a> From<Index<'a, ReturnStatement<'a>>> for TagIndex<'a, Statement<'a>> {
    fn from(v: Index<'a, ReturnStatement<'a>>) -> Self {
        TagIndex::new(Statement::Return(v))
    }
}

impl<'a> From<Index<'a, VarDeclStatement<'a>>> for TagIndex<'a, Statement<'a>> {
    fn from(v: Index<'a, VarDeclStatement<'a>>) -> Self {
        TagIndex::new(Statement::VarDecl(v))
    }
}

impl<'a> From<Index<'a, WhileStatement<'a>>> for TagIndex<'a, Statement<'a>> {
    fn from(v: Index<'a, WhileStatement<'a>>) -> Self {
        TagIndex::new(Statement::While(v))
    }
}

impl<'a> From<Index<'a, UseStatement<'a>>> for TagIndex<'a, Statement<'a>> {
    fn from(v: Index<'a, UseStatement<'a>>) -> Self {
        TagIndex::new(Statement::Use(v))
    }
}

impl<'a> From<Index<'a, ArrayType<'a>>> for TagIndex<'a, TypeRef<'a>> {
    fn from(v: Index<'a, ArrayType<'a>>) -> Self {
        TagIndex::new(TypeRef::Array(v))
    }
}

impl<'a> From<Index<'a, FnType<'a>>> for TagIndex<'a, TypeRef<'a>> {
    fn from(v: Index<'a, FnType<'a>>) -> Self {
        TagIndex::new(TypeRef::Fn(v))
    }
}

impl<'a> From<Index<'a, Path<'a>>> for TagIndex<'a, TypeRef<'a>> {
    fn from(v: Index<'a, Path<'a>>) -> Self {
        TagIndex::new(TypeRef::Path(v))
    }
}

impl<'a> From<Index<'a, PrimitiveType>> for TagIndex<'a, TypeRef<'a>> {
    fn from(v: Index<'a, PrimitiveType>) -> Self {
        TagIndex::new(TypeRef::Primitive(v))
    }
}

impl<'a> From<Index<'a, RefType<'a>>> for TagIndex<'a, TypeRef<'a>> {
    fn from(v: Index<'a, RefType<'a>>) -> Self {
        TagIndex::new(TypeRef::Ref(v))
    }
}

impl<'a> From<Index<'a, TupleType<'a>>> for TagIndex<'a, TypeRef<'a>> {
    fn from(v: Index<'a, TupleType<'a>>) -> Self {
        TagIndex::new(TypeRef::Tuple(v))
    }
}

impl<'a> WithSpan for Expr<'a> {
    fn span(&self, arena: &Arena) -> Span {
        match self {
            Expr::Lit(n) => arena.get(n).span,
            Expr::Path(n) => arena.get(n).span,
            Expr::Paren(n) => arena.get(n).span,
            Expr::Tuple(n) => arena.get(n).span,
            Expr::Array(n) => arena.get(n).span,
            Expr::Call(n) => arena.get(n).span,
            Expr::ArrayIndex(n) => arena.get(n).span,
            Expr::TupleIndex(n) => arena.get(n).span,
            Expr::Member(n) => arena.get(n).span,
            Expr::Object(n) => arena.get(n).span,
            Expr::Unary(n) => arena.get(n).span,
            Expr::Binary(n) => arena.get(n).span,
            Expr::RangeBoth(n) => arena.get(n).span,
            Expr::RangeFull(n) => arena.get(n).span,
            Expr::RangeLeft(n) => arena.get(n).span,
            Expr::RangeRight(n) => arena.get(n).span,
        }
    }
}

impl<'a> WithSpan for Item<'a> {
    fn span(&self, arena: &Arena) -> Span {
        match self {
            Item::Struct(n) => arena.get(n).span,
            Item::Enum(n) => arena.get(n).span,
            Item::Fn(n) => arena.get(n).span,
            Item::Impl(n) => arena.get(n).span,
            Item::Type(n) => arena.get(n).span,
            Item::Class(n) => arena.get(n).span,
            Item::Block(n) => arena.get(n).span,
            Item::SimpleExpr(n) => arena.get(n).span,
            Item::AssignExpr(n) => arena.get(n).span,
            Item::For(n) => arena.get(n).span,
            Item::If(n) => arena.get(n).span,
            Item::Loop(n) => arena.get(n).span,
            Item::VarDecl(n) => arena.get(n).span,
            Item::While(n) => arena.get(n).span,
            Item::Use(n) => arena.get(n).span,
            Item::Import(n) => arena.get(n).span,
        }
    }
}

impl<'a> WithSpan for PathSegment<'a> {
    fn span(&self, arena: &Arena) -> Span {
        match self {
            PathSegment::Global => Span::new(0, 0),
            PathSegment::Simple(n) => arena.get(n).span,
            PathSegment::Cast(n) => arena.get(n).span,
            PathSegment::Generic(n) => arena.get(n).span,
        }
    }
}

impl<'a> WithSpan for Statement<'a> {
    fn span(&self, arena: &Arena) -> Span {
        match self {
            Statement::Struct(n) => arena.get(n).span,
            Statement::Enum(n) => arena.get(n).span,
            Statement::Fn(n) => arena.get(n).span,
            Statement::Impl(n) => arena.get(n).span,
            Statement::Type(n) => arena.get(n).span,
            Statement::Class(n) => arena.get(n).span,
            Statement::Block(n) => arena.get(n).span,
            Statement::Break(n) => arena.get(n).span,
            Statement::Continue(n) => arena.get(n).span,
            Statement::SimpleExpr(n) => arena.get(n).span,
            Statement::AssignExpr(n) => arena.get(n).span,
            Statement::For(n) => arena.get(n).span,
            Statement::If(n) => arena.get(n).span,
            Statement::Loop(n) => arena.get(n).span,
            Statement::Return(n) => arena.get(n).span,
            Statement::VarDecl(n) => arena.get(n).span,
            Statement::While(n) => arena.get(n).span,
            Statement::Use(n) => arena.get(n).span,
        }
    }
}

impl<'a> WithSpan for TypeRef<'a> {
    fn span(&self, arena: &Arena) -> Span {
        match self {
            TypeRef::Array(n) => arena.get(n).span,
            TypeRef::Fn(n) => arena.get(n).span,
            TypeRef::Path(n) => arena.get(n).span,
            TypeRef::Primitive(n) => arena.get(n).span,
            TypeRef::Ref(n) => arena.get(n).span,
            TypeRef::Tuple(n) => arena.get(n).span,
        }
    }
}
