///! ---------------------------------------------------------------------------------
///! This code is auto generated by a tool $repo/scripts/ast.py
///! Changes may cause incorrect behavior and will be lost if the code is regenerated.
///! ---------------------------------------------------------------------------------

///! debug format with arena, make index/slice transparent

use std::fmt::{self, Write};
use super::super::visit::{Visitor, Visit};
use super::noauto::EmptyResult;
use super::*;

pub struct Debug<'a, 'b, N>(&'a N, &'b Arena);

pub fn debug<'a, 'b, N: Visit>(node: &'a N, arena: &'b Arena) -> Debug<'a, 'b, N> {
    Debug(node, arena)
}

impl<'a, 'b, N> fmt::Debug for Debug<'a, 'b, N> where N: Visit {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let mut formatter = Formatter(f);
        self.0.accept(self.1, &mut formatter).into_result().map_err(|_| fmt::Error)
    }
}

struct Formatter<'f1, 'f2>(&'f1 mut fmt::Formatter<'f2>);

impl<'f1, 'f2> Formatter<'f1, 'f2> {

    fn start_struct(&mut self, name: &'static str) -> Result<&mut Self, fmt::Error> {
        self.0.write_str(name)?;
        self.0.write_str("{ ")?;
        Ok(self)
    }

    fn end_struct(&mut self) -> EmptyResult {
        self.0.write_char('}')?;
        EmptyResult(true)
    }

    // optional terminal is here
    fn field(&mut self, name: &'static str, value: impl fmt::Debug + Copy) -> Result<&mut Self, fmt::Error> {
        self.0.write_str(name)?;
        self.0.write_str(": ")?;
        write!(self.0, "{:?}", value)?;
        self.0.write_str(", ")?;
        Ok(self)
    }

    // LitValue is not Copy
    fn lit_value(&mut self, name: &'static str, value: &LitValue) -> Result<&mut Self, fmt::Error> {
        self.0.write_str(name)?;
        self.0.write_str(": ")?;
        write!(self.0, "{:?}", value)?;
        self.0.write_str(", ")?;
        Ok(self)
    }

    // NOTE: this visitor is also not walkable, because you need to insert ", field_name: " between 2 visit_* calls

    // index or enum
    fn forward<'a, 'b: 'a, N: Visit>(&mut self, name: &'static str, value: &'b N, arena: &'a Arena) -> Result<&mut Self, fmt::Error> {
        self.0.write_str(name)?;
        self.0.write_str(": ")?;
        value.accept(arena, self).into_result().map_err(|_| fmt::Error)?;
        self.0.write_str(", ")?;
        Ok(self)
    }

    // optiona index or enum
    fn optional<'a, 'b: 'a, N: Visit>(&mut self, name: &'static str, value: &'b Option<N>, arena: &'a Arena) -> Result<&mut Self, fmt::Error> {
        self.0.write_str(name)?;
        self.0.write_str(": ")?;
        if let Some(value) = value {
            value.accept(arena, self).into_result().map_err(|_| fmt::Error)?;
        } else {
            self.0.write_str("None")?;
        }
        self.0.write_str(", ")?;
        Ok(self)
    }

    fn slice<'a, 'b: 'a, N: Visit>(&mut self, name: &'static str, slice: &'b Slice<'a, N>, arena: &'a Arena) -> Result<&mut Self, fmt::Error> {
        self.0.write_str(name)?;
        self.0.write_str(": [")?;
        for item in arena.get_iter(slice) {
            item.accept(arena, self).into_result().map_err(|_| fmt::Error)?;
        }
        Ok(self)
    }

    fn variant<'a, 'b: 'a, N>(&mut self, name: &'static str, index: &'b Index<'a, N>, arena: &'a Arena) -> EmptyResult where Index<'a, N>: Visit {
        self.0.write_str(name)?;
        self.0.write_char('(')?;
        index.accept(arena, self).into_result().map_err(|_| fmt::Error)?;
        self.0.write_char(')')?;
        EmptyResult(true)
    }
}

impl<'f1, 'f2> Visitor for Formatter<'f1, 'f2> {
    type Result = EmptyResult;

    // AUTOGEN
    fn visit_array_expr<'a, 'b: 'a>(&mut self, node: &'b Index<'a, ArrayExpr<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("ArrayExpr")?
            .field("span", this.span)?
            .slice("items", &this.items, arena)?
            .end_struct()
    }

    fn visit_array_index_expr<'a, 'b: 'a>(&mut self, node: &'b Index<'a, ArrayIndexExpr<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("ArrayIndexExpr")?
            .field("span", this.span)?
            .forward("base", &this.base, arena)?
            .slice("parameters", &this.parameters, arena)?
            .field("quote_span", this.quote_span)?
            .end_struct()
    }

    fn visit_array_type<'a, 'b: 'a>(&mut self, node: &'b Index<'a, ArrayType<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("ArrayType")?
            .field("span", this.span)?
            .forward("base", &this.base, arena)?
            .forward("size", &this.size, arena)?
            .end_struct()
    }

    fn visit_assign_expr_stmt<'a, 'b: 'a>(&mut self, node: &'b Index<'a, AssignExprStatement<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("AssignExprStatement")?
            .field("span", this.span)?
            .forward("left", &this.left, arena)?
            .forward("right", &this.right, arena)?
            .field("op", this.op)?
            .field("op_span", this.op_span)?
            .end_struct()
    }

    fn visit_binary_expr<'a, 'b: 'a>(&mut self, node: &'b Index<'a, BinaryExpr<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("BinaryExpr")?
            .field("span", this.span)?
            .forward("left", &this.left, arena)?
            .forward("right", &this.right, arena)?
            .field("op", this.op)?
            .field("op_span", this.op_span)?
            .end_struct()
    }

    fn visit_block<'a, 'b: 'a>(&mut self, node: &'b Index<'a, Block<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("Block")?
            .field("span", this.span)?
            .slice("items", &this.items, arena)?
            .end_struct()
    }

    fn visit_block_stmt<'a, 'b: 'a>(&mut self, node: &'b Index<'a, BlockStatement<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("BlockStatement")?
            .field("span", this.span)?
            .field("label", this.label)?
            .forward("body", &this.body, arena)?
            .end_struct()
    }

    fn visit_break_stmt<'a, 'b: 'a>(&mut self, node: &'b Index<'a, BreakStatement>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("BreakStatement")?
            .field("span", this.span)?
            .field("label", this.label)?
            .end_struct()
    }

    fn visit_call_expr<'a, 'b: 'a>(&mut self, node: &'b Index<'a, CallExpr<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("CallExpr")?
            .field("span", this.span)?
            .forward("base", &this.base, arena)?
            .field("quote_span", this.quote_span)?
            .slice("parameters", &this.parameters, arena)?
            .end_struct()
    }

    fn visit_cast_segment<'a, 'b: 'a>(&mut self, node: &'b Index<'a, CastSegment<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("CastSegment")?
            .field("span", this.span)?
            .forward("left", &this.left, arena)?
            .forward("right", &this.right, arena)?
            .end_struct()
    }

    fn visit_class_def<'a, 'b: 'a>(&mut self, node: &'b Index<'a, ClassDef<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("ClassDef")?
            .field("span", this.span)?
            .forward("name", &this.name, arena)?
            .field("quote_span", this.quote_span)?
            .slice("items", &this.items, arena)?
            .end_struct()
    }

    fn visit_continue_stmt<'a, 'b: 'a>(&mut self, node: &'b Index<'a, ContinueStatement>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("ContinueStatement")?
            .field("span", this.span)?
            .field("label", this.label)?
            .end_struct()
    }

    fn visit_else_clause<'a, 'b: 'a>(&mut self, node: &'b Index<'a, ElseClause<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("ElseClause")?
            .field("span", this.span)?
            .forward("body", &this.body, arena)?
            .end_struct()
    }

    fn visit_enum_def<'a, 'b: 'a>(&mut self, node: &'b Index<'a, EnumDef<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("EnumDef")?
            .field("span", this.span)?
            .field("name", this.name)?
            .optional("base_type", &this.base_type, arena)?
            .field("quote_span", this.quote_span)?
            .slice("variants", &this.variants, arena)?
            .end_struct()
    }

    fn visit_enum_def_variant<'a, 'b: 'a>(&mut self, node: &'b Index<'a, EnumDefVariant<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("EnumDefVariant")?
            .field("span", this.span)?
            .field("name", this.name)?
            .optional("value", &this.value, arena)?
            .end_struct()
    }

    fn visit_expr<'a, 'b: 'a>(&mut self, node: &'b Expr<'a>, arena: &'a Arena) -> Self::Result {
        match node {
            Expr::Lit(n) => self.variant("Expr::Lit", n, arena),
            Expr::Path(n) => self.variant("Expr::Path", n, arena),
            Expr::Paren(n) => self.variant("Expr::Paren", n, arena),
            Expr::Tuple(n) => self.variant("Expr::Tuple", n, arena),
            Expr::Array(n) => self.variant("Expr::Array", n, arena),
            Expr::Call(n) => self.variant("Expr::Call", n, arena),
            Expr::ArrayIndex(n) => self.variant("Expr::ArrayIndex", n, arena),
            Expr::TupleIndex(n) => self.variant("Expr::TupleIndex", n, arena),
            Expr::Member(n) => self.variant("Expr::Member", n, arena),
            Expr::Object(n) => self.variant("Expr::Object", n, arena),
            Expr::Unary(n) => self.variant("Expr::Unary", n, arena),
            Expr::Binary(n) => self.variant("Expr::Binary", n, arena),
            Expr::RangeBoth(n) => self.variant("Expr::RangeBoth", n, arena),
            Expr::RangeFull(n) => self.variant("Expr::RangeFull", n, arena),
            Expr::RangeLeft(n) => self.variant("Expr::RangeLeft", n, arena),
            Expr::RangeRight(n) => self.variant("Expr::RangeRight", n, arena),
        }
    }

    fn visit_field_def<'a, 'b: 'a>(&mut self, node: &'b Index<'a, FieldDef<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("FieldDef")?
            .field("span", this.span)?
            .field("name", this.name)?
            .field("colon_span", this.colon_span)?
            .forward("r#type", &this.r#type, arena)?
            .end_struct()
    }

    fn visit_fn_def<'a, 'b: 'a>(&mut self, node: &'b Index<'a, FnDef<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("FnDef")?
            .field("span", this.span)?
            .forward("name", &this.name, arena)?
            .field("quote_span", this.quote_span)?
            .slice("parameters", &this.parameters, arena)?
            .optional("ret_type", &this.ret_type, arena)?
            .slice("wheres", &this.wheres, arena)?
            .optional("body", &this.body, arena)?
            .end_struct()
    }

    fn visit_fn_def_parameter<'a, 'b: 'a>(&mut self, node: &'b Index<'a, FnDefParameter<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("FnDefParameter")?
            .field("span", this.span)?
            .field("name", this.name)?
            .forward("r#type", &this.r#type, arena)?
            .end_struct()
    }

    fn visit_fn_type<'a, 'b: 'a>(&mut self, node: &'b Index<'a, FnType<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("FnType")?
            .field("span", this.span)?
            .field("quote_span", this.quote_span)?
            .slice("parameters", &this.parameters, arena)?
            .optional("ret_type", &this.ret_type, arena)?
            .end_struct()
    }

    fn visit_fn_type_parameter<'a, 'b: 'a>(&mut self, node: &'b Index<'a, FnTypeParameter<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("FnTypeParameter")?
            .field("span", this.span)?
            .field("name", this.name)?
            .forward("r#type", &this.r#type, arena)?
            .end_struct()
    }

    fn visit_for_stmt<'a, 'b: 'a>(&mut self, node: &'b Index<'a, ForStatement<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("ForStatement")?
            .field("span", this.span)?
            .field("label", this.label)?
            .field("iter_name", this.iter_name)?
            .forward("iter_expr", &this.iter_expr, arena)?
            .forward("body", &this.body, arena)?
            .end_struct()
    }

    fn visit_generic_name<'a, 'b: 'a>(&mut self, node: &'b Index<'a, GenericName<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("GenericName")?
            .field("span", this.span)?
            .field("base", this.base)?
            .field("quote_span", this.quote_span)?
            .slice("parameters", &this.parameters, arena)?
            .end_struct()
    }

    fn visit_generic_parameter<'a, 'b: 'a>(&mut self, node: &'b Index<'a, GenericParameter>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("GenericParameter")?
            .field("span", this.span)?
            .field("name", this.name)?
            .end_struct()
    }

    fn visit_generic_segment<'a, 'b: 'a>(&mut self, node: &'b Index<'a, GenericSegment<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("GenericSegment")?
            .field("span", this.span)?
            .field("base", this.base)?
            .forward("parameters", &this.parameters, arena)?
            .end_struct()
    }

    fn visit_if_clause<'a, 'b: 'a>(&mut self, node: &'b Index<'a, IfClause<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("IfClause")?
            .field("span", this.span)?
            .forward("condition", &this.condition, arena)?
            .forward("body", &this.body, arena)?
            .end_struct()
    }

    fn visit_if_stmt<'a, 'b: 'a>(&mut self, node: &'b Index<'a, IfStatement<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("IfStatement")?
            .field("span", this.span)?
            .forward("if_clause", &this.if_clause, arena)?
            .slice("elseif_clauses", &this.elseif_clauses, arena)?
            .optional("else_clause", &this.else_clause, arena)?
            .end_struct()
    }

    fn visit_impl_block<'a, 'b: 'a>(&mut self, node: &'b Index<'a, Implementation<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("Implementation")?
            .field("span", this.span)?
            .slice("parameters", &this.parameters, arena)?
            .optional("class", &this.class, arena)?
            .forward("r#type", &this.r#type, arena)?
            .slice("wheres", &this.wheres, arena)?
            .field("quote_span", this.quote_span)?
            .slice("items", &this.items, arena)?
            .end_struct()
    }

    fn visit_item<'a, 'b: 'a>(&mut self, node: &'b Item<'a>, arena: &'a Arena) -> Self::Result {
        match node {
            Item::Struct(n) => self.variant("Item::Struct", n, arena),
            Item::Enum(n) => self.variant("Item::Enum", n, arena),
            Item::Fn(n) => self.variant("Item::Fn", n, arena),
            Item::Impl(n) => self.variant("Item::Impl", n, arena),
            Item::Type(n) => self.variant("Item::Type", n, arena),
            Item::Class(n) => self.variant("Item::Class", n, arena),
            Item::Block(n) => self.variant("Item::Block", n, arena),
            Item::SimpleExpr(n) => self.variant("Item::SimpleExpr", n, arena),
            Item::AssignExpr(n) => self.variant("Item::AssignExpr", n, arena),
            Item::For(n) => self.variant("Item::For", n, arena),
            Item::If(n) => self.variant("Item::If", n, arena),
            Item::Loop(n) => self.variant("Item::Loop", n, arena),
            Item::VarDecl(n) => self.variant("Item::VarDecl", n, arena),
            Item::While(n) => self.variant("Item::While", n, arena),
            Item::Use(n) => self.variant("Item::Use", n, arena),
            Item::Import(n) => self.variant("Item::Import", n, arena),
        }
    }

    fn visit_lit_expr<'a, 'b: 'a>(&mut self, node: &'b Index<'a, LitExpr>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("LitExpr")?
            .field("span", this.span)?
            .lit_value("value", &this.value)?
            .end_struct()
    }

    fn visit_loop_stmt<'a, 'b: 'a>(&mut self, node: &'b Index<'a, LoopStatement<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("LoopStatement")?
            .field("span", this.span)?
            .field("label", this.label)?
            .forward("body", &this.body, arena)?
            .end_struct()
    }

    fn visit_member_expr<'a, 'b: 'a>(&mut self, node: &'b Index<'a, MemberExpr<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("MemberExpr")?
            .field("span", this.span)?
            .forward("base", &this.base, arena)?
            .field("op_span", this.op_span)?
            .field("name", this.name)?
            .optional("parameters", &this.parameters, arena)?
            .end_struct()
    }

    fn visit_module<'a, 'b: 'a>(&mut self, node: &'b Index<'a, Module<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("Module")?
            .field("file", this.file)?
            .slice("items", &this.items, arena)?
            .end_struct()
    }

    fn visit_module_stmt<'a, 'b: 'a>(&mut self, node: &'b Index<'a, ModuleStatement>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("ModuleStatement")?
            .field("span", this.span)?
            .field("name", this.name)?
            .field("path", this.path)?
            .end_struct()
    }

    fn visit_object_expr<'a, 'b: 'a>(&mut self, node: &'b Index<'a, ObjectExpr<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("ObjectExpr")?
            .field("span", this.span)?
            .forward("base", &this.base, arena)?
            .field("quote_span", this.quote_span)?
            .slice("fields", &this.fields, arena)?
            .end_struct()
    }

    fn visit_object_expr_field<'a, 'b: 'a>(&mut self, node: &'b Index<'a, ObjectExprField<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("ObjectExprField")?
            .field("span", this.span)?
            .field("name", this.name)?
            .forward("value", &this.value, arena)?
            .end_struct()
    }

    fn visit_paren_expr<'a, 'b: 'a>(&mut self, node: &'b Index<'a, ParenExpr<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("ParenExpr")?
            .field("span", this.span)?
            .forward("base", &this.base, arena)?
            .end_struct()
    }

    fn visit_path<'a, 'b: 'a>(&mut self, node: &'b Index<'a, Path<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("Path")?
            .field("span", this.span)?
            .slice("segments", &this.segments, arena)?
            .end_struct()
    }

    fn visit_path_segment<'a, 'b: 'a>(&mut self, node: &'b PathSegment<'a>, arena: &'a Arena) -> Self::Result {
        match node {
            PathSegment::Global => EmptyResult(self.0.write_str("PathSegment::Global").is_ok()),
            PathSegment::Simple(n) => self.variant("PathSegment::Simple", n, arena),
            PathSegment::Cast(n) => self.variant("PathSegment::Cast", n, arena),
            PathSegment::Generic(n) => self.variant("PathSegment::Generic", n, arena),
        }
    }

    fn visit_primitive_type<'a, 'b: 'a>(&mut self, node: &'b Index<'a, PrimitiveType>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("PrimitiveType")?
            .field("span", this.span)?
            .field("base", this.base)?
            .end_struct()
    }

    fn visit_range_both_expr<'a, 'b: 'a>(&mut self, node: &'b Index<'a, RangeBothExpr<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("RangeBothExpr")?
            .field("span", this.span)?
            .forward("left", &this.left, arena)?
            .field("op_span", this.op_span)?
            .forward("right", &this.right, arena)?
            .end_struct()
    }

    fn visit_range_full_expr<'a, 'b: 'a>(&mut self, node: &'b Index<'a, RangeFullExpr>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("RangeFullExpr")?
            .field("span", this.span)?
            .end_struct()
    }

    fn visit_range_left_expr<'a, 'b: 'a>(&mut self, node: &'b Index<'a, RangeLeftExpr<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("RangeLeftExpr")?
            .field("span", this.span)?
            .forward("base", &this.base, arena)?
            .end_struct()
    }

    fn visit_range_right_expr<'a, 'b: 'a>(&mut self, node: &'b Index<'a, RangeRightExpr<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("RangeRightExpr")?
            .field("span", this.span)?
            .forward("base", &this.base, arena)?
            .end_struct()
    }

    fn visit_ref_type<'a, 'b: 'a>(&mut self, node: &'b Index<'a, RefType<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("RefType")?
            .field("span", this.span)?
            .forward("base", &this.base, arena)?
            .end_struct()
    }

    fn visit_ret_stmt<'a, 'b: 'a>(&mut self, node: &'b Index<'a, ReturnStatement<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("ReturnStatement")?
            .field("span", this.span)?
            .optional("value", &this.value, arena)?
            .end_struct()
    }

    fn visit_simple_expr_stmt<'a, 'b: 'a>(&mut self, node: &'b Index<'a, SimpleExprStatement<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("SimpleExprStatement")?
            .field("span", this.span)?
            .forward("expr", &this.expr, arena)?
            .end_struct()
    }

    fn visit_simple_segment<'a, 'b: 'a>(&mut self, node: &'b Index<'a, SimpleSegment>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("SimpleSegment")?
            .field("span", this.span)?
            .field("name", this.name)?
            .end_struct()
    }

    fn visit_stmt<'a, 'b: 'a>(&mut self, node: &'b Statement<'a>, arena: &'a Arena) -> Self::Result {
        match node {
            Statement::Struct(n) => self.variant("Statement::Struct", n, arena),
            Statement::Enum(n) => self.variant("Statement::Enum", n, arena),
            Statement::Fn(n) => self.variant("Statement::Fn", n, arena),
            Statement::Impl(n) => self.variant("Statement::Impl", n, arena),
            Statement::Type(n) => self.variant("Statement::Type", n, arena),
            Statement::Class(n) => self.variant("Statement::Class", n, arena),
            Statement::Block(n) => self.variant("Statement::Block", n, arena),
            Statement::Break(n) => self.variant("Statement::Break", n, arena),
            Statement::Continue(n) => self.variant("Statement::Continue", n, arena),
            Statement::SimpleExpr(n) => self.variant("Statement::SimpleExpr", n, arena),
            Statement::AssignExpr(n) => self.variant("Statement::AssignExpr", n, arena),
            Statement::For(n) => self.variant("Statement::For", n, arena),
            Statement::If(n) => self.variant("Statement::If", n, arena),
            Statement::Loop(n) => self.variant("Statement::Loop", n, arena),
            Statement::Return(n) => self.variant("Statement::Return", n, arena),
            Statement::VarDecl(n) => self.variant("Statement::VarDecl", n, arena),
            Statement::While(n) => self.variant("Statement::While", n, arena),
            Statement::Use(n) => self.variant("Statement::Use", n, arena),
        }
    }

    fn visit_struct_def<'a, 'b: 'a>(&mut self, node: &'b Index<'a, StructDef<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("StructDef")?
            .field("span", this.span)?
            .forward("name", &this.name, arena)?
            .slice("fields", &this.fields, arena)?
            .end_struct()
    }

    fn visit_tuple_expr<'a, 'b: 'a>(&mut self, node: &'b Index<'a, TupleExpr<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("TupleExpr")?
            .field("span", this.span)?
            .slice("items", &this.items, arena)?
            .end_struct()
    }

    fn visit_tuple_index_expr<'a, 'b: 'a>(&mut self, node: &'b Index<'a, TupleIndexExpr<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("TupleIndexExpr")?
            .field("span", this.span)?
            .forward("base", &this.base, arena)?
            .field("op_span", this.op_span)?
            .field("value", this.value)?
            .field("value_span", this.value_span)?
            .end_struct()
    }

    fn visit_tuple_type<'a, 'b: 'a>(&mut self, node: &'b Index<'a, TupleType<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("TupleType")?
            .field("span", this.span)?
            .slice("parameters", &this.parameters, arena)?
            .end_struct()
    }

    fn visit_type_def<'a, 'b: 'a>(&mut self, node: &'b Index<'a, TypeDef<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("TypeDef")?
            .field("span", this.span)?
            .forward("name", &this.name, arena)?
            .optional("from", &this.from, arena)?
            .end_struct()
    }

    fn visit_type_list<'a, 'b: 'a>(&mut self, node: &'b Index<'a, TypeList<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("TypeList")?
            .field("span", this.span)?
            .slice("items", &this.items, arena)?
            .end_struct()
    }

    fn visit_type_ref<'a, 'b: 'a>(&mut self, node: &'b TypeRef<'a>, arena: &'a Arena) -> Self::Result {
        match node {
            TypeRef::Array(n) => self.variant("TypeRef::Array", n, arena),
            TypeRef::Fn(n) => self.variant("TypeRef::Fn", n, arena),
            TypeRef::Path(n) => self.variant("TypeRef::Path", n, arena),
            TypeRef::Primitive(n) => self.variant("TypeRef::Primitive", n, arena),
            TypeRef::Ref(n) => self.variant("TypeRef::Ref", n, arena),
            TypeRef::Tuple(n) => self.variant("TypeRef::Tuple", n, arena),
        }
    }

    fn visit_unary_expr<'a, 'b: 'a>(&mut self, node: &'b Index<'a, UnaryExpr<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("UnaryExpr")?
            .field("span", this.span)?
            .forward("base", &this.base, arena)?
            .field("op", this.op)?
            .field("op_span", this.op_span)?
            .end_struct()
    }

    fn visit_use_stmt<'a, 'b: 'a>(&mut self, node: &'b Index<'a, UseStatement<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("UseStatement")?
            .field("span", this.span)?
            .forward("path", &this.path, arena)?
            .field("alias", this.alias)?
            .end_struct()
    }

    fn visit_var_decl_stmt<'a, 'b: 'a>(&mut self, node: &'b Index<'a, VarDeclStatement<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("VarDeclStatement")?
            .field("span", this.span)?
            .field("r#const", this.r#const)?
            .field("name", this.name)?
            .optional("r#type", &this.r#type, arena)?
            .optional("init_value", &this.init_value, arena)?
            .end_struct()
    }

    fn visit_where_clause<'a, 'b: 'a>(&mut self, node: &'b Index<'a, WhereClause<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("WhereClause")?
            .field("span", this.span)?
            .field("name", this.name)?
            .slice("constraints", &this.constraints, arena)?
            .end_struct()
    }

    fn visit_while_stmt<'a, 'b: 'a>(&mut self, node: &'b Index<'a, WhileStatement<'a>>, arena: &'a Arena) -> Self::Result {
        let this = arena.get(node);
        self.start_struct("WhileStatement")?
            .field("span", this.span)?
            .field("label", this.label)?
            .forward("condition", &this.condition, arena)?
            .forward("body", &this.body, arena)?
            .end_struct()
    }
}
