///! ---------------------------------------------------------------------------------
///! This code is auto generated by a tool $repo/scripts/ast.py
///! Changes may cause incorrect behavior and will be lost if the code is regenerated.
///! ---------------------------------------------------------------------------------

///! impl Visit for each node

use super::super::visit::{Visit, Visitor};
use super::*;

impl<'a> Visit for Index<'a, ArrayExpr<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_array_expr(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        for item in arena.get_iter(&this.items) {
            v.visit_expr(item, arena)?;
        }
        Default::default()
    }
}

impl<'a> Visit for Index<'a, ArrayIndexExpr<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_array_index_expr(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_expr(&this.base, arena)?;
        for parameter in arena.get_iter(&this.parameters) {
            v.visit_expr(parameter, arena)?;
        }
        Default::default()
    }
}

impl<'a> Visit for Index<'a, ArrayType<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_array_type(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_type_ref(&this.base, arena)?;
        v.visit_expr(&this.size, arena)
    }
}

impl<'a> Visit for Index<'a, AssignExprStatement<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_assign_expr_stmt(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_expr(&this.left, arena)?;
        v.visit_expr(&this.right, arena)
    }
}

impl<'a> Visit for Index<'a, BinaryExpr<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_binary_expr(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_expr(&this.left, arena)?;
        v.visit_expr(&this.right, arena)
    }
}

impl<'a> Visit for Index<'a, Block<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_block(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        for item in arena.get_iter(&this.items) {
            v.visit_stmt(item, arena)?;
        }
        Default::default()
    }
}

impl<'a> Visit for Index<'a, BlockStatement<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_block_stmt(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_block(&this.body, arena)
    }
}

impl<'a> Visit for Index<'a, BreakStatement> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_break_stmt(self, arena)
    }
}

impl<'a> Visit for Index<'a, CallExpr<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_call_expr(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_expr(&this.base, arena)?;
        for parameter in arena.get_iter(&this.parameters) {
            v.visit_expr(parameter, arena)?;
        }
        Default::default()
    }
}

impl<'a> Visit for Index<'a, CastSegment<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_cast_segment(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_type_ref(&this.left, arena)?;
        v.visit_type_ref(&this.right, arena)
    }
}

impl<'a> Visit for Index<'a, ClassDef<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_class_def(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_generic_name(&this.name, arena)?;
        for item in arena.get_iter(&this.items) {
            v.visit_item(item, arena)?;
        }
        Default::default()
    }
}

impl<'a> Visit for Index<'a, ContinueStatement> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_continue_stmt(self, arena)
    }
}

impl<'a> Visit for Index<'a, ElseClause<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_else_clause(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_block(&this.body, arena)
    }
}

impl<'a> Visit for Index<'a, EnumDef<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_enum_def(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        if let Some(base_type) = &this.base_type {
            v.visit_primitive_type(base_type, arena)?;
        }
        for variant in arena.get_iter(&this.variants) {
            v.visit_enum_def_variant(variant, arena)?;
        }
        Default::default()
    }
}

impl<'a> Visit for Index<'a, EnumDefVariant<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_enum_def_variant(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        if let Some(value) = &this.value {
            v.visit_expr(value, arena)?;
        }
        Default::default()
    }
}

impl<'a> Visit for Expr<'a> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_expr(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        match self {
            Expr::Lit(n) => v.visit_lit_expr(n, arena),
            Expr::Path(n) => v.visit_path(n, arena),
            Expr::Paren(n) => v.visit_paren_expr(n, arena),
            Expr::Tuple(n) => v.visit_tuple_expr(n, arena),
            Expr::Array(n) => v.visit_array_expr(n, arena),
            Expr::Call(n) => v.visit_call_expr(n, arena),
            Expr::ArrayIndex(n) => v.visit_array_index_expr(n, arena),
            Expr::TupleIndex(n) => v.visit_tuple_index_expr(n, arena),
            Expr::Member(n) => v.visit_member_expr(n, arena),
            Expr::Object(n) => v.visit_object_expr(n, arena),
            Expr::Unary(n) => v.visit_unary_expr(n, arena),
            Expr::Binary(n) => v.visit_binary_expr(n, arena),
            Expr::RangeBoth(n) => v.visit_range_both_expr(n, arena),
            Expr::RangeFull(n) => v.visit_range_full_expr(n, arena),
            Expr::RangeLeft(n) => v.visit_range_left_expr(n, arena),
            Expr::RangeRight(n) => v.visit_range_right_expr(n, arena),
        }
    }
}

impl<'a> Visit for Index<'a, FieldDef<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_field_def(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_type_ref(&this.r#type, arena)
    }
}

impl<'a> Visit for Index<'a, FnDef<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_fn_def(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_generic_name(&this.name, arena)?;
        for parameter in arena.get_iter(&this.parameters) {
            v.visit_fn_def_parameter(parameter, arena)?;
        }
        if let Some(ret_type) = &this.ret_type {
            v.visit_type_ref(ret_type, arena)?;
        }
        for r#where in arena.get_iter(&this.wheres) {
            v.visit_where_clause(r#where, arena)?;
        }
        if let Some(body) = &this.body {
            v.visit_block(body, arena)?;
        }
        Default::default()
    }
}

impl<'a> Visit for Index<'a, FnDefParameter<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_fn_def_parameter(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_type_ref(&this.r#type, arena)
    }
}

impl<'a> Visit for Index<'a, FnType<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_fn_type(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        for parameter in arena.get_iter(&this.parameters) {
            v.visit_fn_type_parameter(parameter, arena)?;
        }
        if let Some(ret_type) = &this.ret_type {
            v.visit_type_ref(ret_type, arena)?;
        }
        Default::default()
    }
}

impl<'a> Visit for Index<'a, FnTypeParameter<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_fn_type_parameter(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_type_ref(&this.r#type, arena)
    }
}

impl<'a> Visit for Index<'a, ForStatement<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_for_stmt(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_expr(&this.iter_expr, arena)?;
        v.visit_block(&this.body, arena)
    }
}

impl<'a> Visit for Index<'a, GenericName<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_generic_name(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        for parameter in arena.get_iter(&this.parameters) {
            v.visit_generic_parameter(parameter, arena)?;
        }
        Default::default()
    }
}

impl<'a> Visit for Index<'a, GenericParameter> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_generic_parameter(self, arena)
    }
}

impl<'a> Visit for Index<'a, GenericSegment<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_generic_segment(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_type_list(&this.parameters, arena)
    }
}

impl<'a> Visit for Index<'a, IfClause<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_if_clause(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_expr(&this.condition, arena)?;
        v.visit_block(&this.body, arena)
    }
}

impl<'a> Visit for Index<'a, IfStatement<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_if_stmt(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_if_clause(&this.if_clause, arena)?;
        for elseif_clause in arena.get_iter(&this.elseif_clauses) {
            v.visit_if_clause(elseif_clause, arena)?;
        }
        if let Some(else_clause) = &this.else_clause {
            v.visit_else_clause(else_clause, arena)?;
        }
        Default::default()
    }
}

impl<'a> Visit for Index<'a, Implementation<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_impl_block(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        for parameter in arena.get_iter(&this.parameters) {
            v.visit_generic_parameter(parameter, arena)?;
        }
        if let Some(class) = &this.class {
            v.visit_type_ref(class, arena)?;
        }
        v.visit_type_ref(&this.r#type, arena)?;
        for r#where in arena.get_iter(&this.wheres) {
            v.visit_where_clause(r#where, arena)?;
        }
        for item in arena.get_iter(&this.items) {
            v.visit_item(item, arena)?;
        }
        Default::default()
    }
}

impl<'a> Visit for Item<'a> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_item(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        match self {
            Item::Struct(n) => v.visit_struct_def(n, arena),
            Item::Enum(n) => v.visit_enum_def(n, arena),
            Item::Fn(n) => v.visit_fn_def(n, arena),
            Item::Impl(n) => v.visit_impl_block(n, arena),
            Item::Type(n) => v.visit_type_def(n, arena),
            Item::Class(n) => v.visit_class_def(n, arena),
            Item::Block(n) => v.visit_block_stmt(n, arena),
            Item::SimpleExpr(n) => v.visit_simple_expr_stmt(n, arena),
            Item::AssignExpr(n) => v.visit_assign_expr_stmt(n, arena),
            Item::For(n) => v.visit_for_stmt(n, arena),
            Item::If(n) => v.visit_if_stmt(n, arena),
            Item::Loop(n) => v.visit_loop_stmt(n, arena),
            Item::VarDecl(n) => v.visit_var_decl_stmt(n, arena),
            Item::While(n) => v.visit_while_stmt(n, arena),
            Item::Use(n) => v.visit_use_stmt(n, arena),
            Item::Import(n) => v.visit_module_stmt(n, arena),
        }
    }
}

impl<'a> Visit for Index<'a, LitExpr> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_lit_expr(self, arena)
    }
}

impl<'a> Visit for Index<'a, LoopStatement<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_loop_stmt(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_block(&this.body, arena)
    }
}

impl<'a> Visit for Index<'a, MemberExpr<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_member_expr(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_expr(&this.base, arena)?;
        if let Some(parameters) = &this.parameters {
            v.visit_type_list(parameters, arena)?;
        }
        Default::default()
    }
}

impl<'a> Visit for Index<'a, Module<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_module(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        for item in arena.get_iter(&this.items) {
            v.visit_item(item, arena)?;
        }
        Default::default()
    }
}

impl<'a> Visit for Index<'a, ModuleStatement> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_module_stmt(self, arena)
    }
}

impl<'a> Visit for Index<'a, ObjectExpr<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_object_expr(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_expr(&this.base, arena)?;
        for field in arena.get_iter(&this.fields) {
            v.visit_object_expr_field(field, arena)?;
        }
        Default::default()
    }
}

impl<'a> Visit for Index<'a, ObjectExprField<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_object_expr_field(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_expr(&this.value, arena)
    }
}

impl<'a> Visit for Index<'a, ParenExpr<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_paren_expr(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_expr(&this.base, arena)
    }
}

impl<'a> Visit for Index<'a, Path<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_path(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        for segment in arena.get_iter(&this.segments) {
            v.visit_path_segment(segment, arena)?;
        }
        Default::default()
    }
}

impl<'a> Visit for PathSegment<'a> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_path_segment(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        match self {
            PathSegment::Global => Default::default(),
            PathSegment::Simple(n) => v.visit_simple_segment(n, arena),
            PathSegment::Cast(n) => v.visit_cast_segment(n, arena),
            PathSegment::Generic(n) => v.visit_generic_segment(n, arena),
        }
    }
}

impl<'a> Visit for Index<'a, PrimitiveType> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_primitive_type(self, arena)
    }
}

impl<'a> Visit for Index<'a, RangeBothExpr<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_range_both_expr(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_expr(&this.left, arena)?;
        v.visit_expr(&this.right, arena)
    }
}

impl<'a> Visit for Index<'a, RangeFullExpr> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_range_full_expr(self, arena)
    }
}

impl<'a> Visit for Index<'a, RangeLeftExpr<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_range_left_expr(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_expr(&this.base, arena)
    }
}

impl<'a> Visit for Index<'a, RangeRightExpr<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_range_right_expr(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_expr(&this.base, arena)
    }
}

impl<'a> Visit for Index<'a, RefType<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_ref_type(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_type_ref(&this.base, arena)
    }
}

impl<'a> Visit for Index<'a, ReturnStatement<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_ret_stmt(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        if let Some(value) = &this.value {
            v.visit_expr(value, arena)?;
        }
        Default::default()
    }
}

impl<'a> Visit for Index<'a, SimpleExprStatement<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_simple_expr_stmt(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_expr(&this.expr, arena)
    }
}

impl<'a> Visit for Index<'a, SimpleSegment> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_simple_segment(self, arena)
    }
}

impl<'a> Visit for Statement<'a> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_stmt(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        match self {
            Statement::Struct(n) => v.visit_struct_def(n, arena),
            Statement::Enum(n) => v.visit_enum_def(n, arena),
            Statement::Fn(n) => v.visit_fn_def(n, arena),
            Statement::Impl(n) => v.visit_impl_block(n, arena),
            Statement::Type(n) => v.visit_type_def(n, arena),
            Statement::Class(n) => v.visit_class_def(n, arena),
            Statement::Block(n) => v.visit_block_stmt(n, arena),
            Statement::Break(n) => v.visit_break_stmt(n, arena),
            Statement::Continue(n) => v.visit_continue_stmt(n, arena),
            Statement::SimpleExpr(n) => v.visit_simple_expr_stmt(n, arena),
            Statement::AssignExpr(n) => v.visit_assign_expr_stmt(n, arena),
            Statement::For(n) => v.visit_for_stmt(n, arena),
            Statement::If(n) => v.visit_if_stmt(n, arena),
            Statement::Loop(n) => v.visit_loop_stmt(n, arena),
            Statement::Return(n) => v.visit_ret_stmt(n, arena),
            Statement::VarDecl(n) => v.visit_var_decl_stmt(n, arena),
            Statement::While(n) => v.visit_while_stmt(n, arena),
            Statement::Use(n) => v.visit_use_stmt(n, arena),
        }
    }
}

impl<'a> Visit for Index<'a, StructDef<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_struct_def(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_generic_name(&this.name, arena)?;
        for field in arena.get_iter(&this.fields) {
            v.visit_field_def(field, arena)?;
        }
        Default::default()
    }
}

impl<'a> Visit for Index<'a, TupleExpr<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_tuple_expr(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        for item in arena.get_iter(&this.items) {
            v.visit_expr(item, arena)?;
        }
        Default::default()
    }
}

impl<'a> Visit for Index<'a, TupleIndexExpr<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_tuple_index_expr(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_expr(&this.base, arena)
    }
}

impl<'a> Visit for Index<'a, TupleType<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_tuple_type(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        for parameter in arena.get_iter(&this.parameters) {
            v.visit_type_ref(parameter, arena)?;
        }
        Default::default()
    }
}

impl<'a> Visit for Index<'a, TypeDef<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_type_def(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_generic_name(&this.name, arena)?;
        if let Some(from) = &this.from {
            v.visit_type_ref(from, arena)?;
        }
        Default::default()
    }
}

impl<'a> Visit for Index<'a, TypeList<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_type_list(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        for item in arena.get_iter(&this.items) {
            v.visit_type_ref(item, arena)?;
        }
        Default::default()
    }
}

impl<'a> Visit for TypeRef<'a> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_type_ref(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        match self {
            TypeRef::Array(n) => v.visit_array_type(n, arena),
            TypeRef::Fn(n) => v.visit_fn_type(n, arena),
            TypeRef::Path(n) => v.visit_path(n, arena),
            TypeRef::Primitive(n) => v.visit_primitive_type(n, arena),
            TypeRef::Ref(n) => v.visit_ref_type(n, arena),
            TypeRef::Tuple(n) => v.visit_tuple_type(n, arena),
        }
    }
}

impl<'a> Visit for Index<'a, UnaryExpr<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_unary_expr(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_expr(&this.base, arena)
    }
}

impl<'a> Visit for Index<'a, UseStatement<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_use_stmt(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_path(&this.path, arena)
    }
}

impl<'a> Visit for Index<'a, VarDeclStatement<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_var_decl_stmt(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        if let Some(r#type) = &this.r#type {
            v.visit_type_ref(r#type, arena)?;
        }
        if let Some(init_value) = &this.init_value {
            v.visit_expr(init_value, arena)?;
        }
        Default::default()
    }
}

impl<'a> Visit for Index<'a, WhereClause<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_where_clause(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        for constraint in arena.get_iter(&this.constraints) {
            v.visit_type_ref(constraint, arena)?;
        }
        Default::default()
    }
}

impl<'a> Visit for Index<'a, WhileStatement<'a>> {
    fn accept<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        v.visit_while_stmt(self, arena)
    }
    fn walk<V: Visitor>(&self, arena: &Arena, v: &mut V) -> V::Result {
        let this = arena.get(self);
        v.visit_expr(&this.condition, arena)?;
        v.visit_block(&this.body, arena)
    }
}
