///! --------------------------------------------------------------------------------
///! This code is auto generated by a tool $repo/scripts/ast.py
///! Changes may cause incorrect behavior and will be lost if the code is regenerated
///! --------------------------------------------------------------------------------

///! visitor and visitable trait

// visitor visits node
// - each visit method visits specific node type and do different things 
//   to collect information (or change, by VisitorMut), after that, Visit::walk should be called to let
//   node itselfguide visitor to child nodes, this decouples visitor implementation with tree structure
// - on the other hand, Visit::accept implementation should call this node's matching visit method 
//   without dothing any other things, only then can methods accepting arbitrary V: Visit perform visit operation
// - according to this design
//   - default visit implementation walks self
//   - default walk implementation does nothing
//   - no default accept implementation
// return type is try for easily break from visiting process if any error happens or result already found, etc.

use std::ops::Try;
use crate::common::arena::Arena;
use super::ast::*;

pub trait Visit: Sized {

    fn walk<V: Visitor>(&self, _arena: &Arena, _visitor: &mut V) -> V::Result {
        Default::default()
    }

    fn accept<V: Visitor>(&self, _arena: &Arena, _visitor: &mut V) -> V::Result;
}

pub trait Visitor: Sized {
    // it is associate type not generic becuase
    // 1. it is not very reasonable to implement visitor for one type multiple times
    // 2. it is very not reasonable to distinguish different implementation by return type
    type Result: Default + Try;

    // AUTOGEN
    fn visit_array_expr<'a, 'b: 'a>(&mut self, node: &'b ArrayExpr<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_array_index_expr<'a, 'b: 'a>(&mut self, node: &'b ArrayIndexExpr<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_array_type<'a, 'b: 'a>(&mut self, node: &'b ArrayType<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_assign_expr_stmt<'a, 'b: 'a>(&mut self, node: &'b AssignExprStatement<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_binary_expr<'a, 'b: 'a>(&mut self, node: &'b BinaryExpr<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_block<'a, 'b: 'a>(&mut self, node: &'b Block<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_block_stmt<'a, 'b: 'a>(&mut self, node: &'b BlockStatement<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_break_stmt<'a, 'b: 'a>(&mut self, node: &'b BreakStatement, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_call_expr<'a, 'b: 'a>(&mut self, node: &'b CallExpr<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_cast_segment<'a, 'b: 'a>(&mut self, node: &'b CastSegment<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_class_def<'a, 'b: 'a>(&mut self, node: &'b ClassDef<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_continue_stmt<'a, 'b: 'a>(&mut self, node: &'b ContinueStatement, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_else_clause<'a, 'b: 'a>(&mut self, node: &'b ElseClause<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_enum_def<'a, 'b: 'a>(&mut self, node: &'b EnumDef<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_enum_def_variant<'a, 'b: 'a>(&mut self, node: &'b EnumDefVariant<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_expr<'a, 'b: 'a>(&mut self, node: &'b Expr<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_field_def<'a, 'b: 'a>(&mut self, node: &'b FieldDef<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_fn_def<'a, 'b: 'a>(&mut self, node: &'b FnDef<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_fn_def_parameter<'a, 'b: 'a>(&mut self, node: &'b FnDefParameter<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_fn_type<'a, 'b: 'a>(&mut self, node: &'b FnType<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_fn_type_parameter<'a, 'b: 'a>(&mut self, node: &'b FnTypeParameter<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_for_stmt<'a, 'b: 'a>(&mut self, node: &'b ForStatement<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_generic_name<'a, 'b: 'a>(&mut self, node: &'b GenericName<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_generic_parameter<'a, 'b: 'a>(&mut self, node: &'b GenericParameter, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_generic_segment<'a, 'b: 'a>(&mut self, node: &'b GenericSegment<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_if_clause<'a, 'b: 'a>(&mut self, node: &'b IfClause<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_if_stmt<'a, 'b: 'a>(&mut self, node: &'b IfStatement<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_impl_block<'a, 'b: 'a>(&mut self, node: &'b Implementation<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_item<'a, 'b: 'a>(&mut self, node: &'b Item<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_lit_expr<'a, 'b: 'a>(&mut self, node: &'b LitExpr, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_loop_stmt<'a, 'b: 'a>(&mut self, node: &'b LoopStatement<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_member_expr<'a, 'b: 'a>(&mut self, node: &'b MemberExpr<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_module<'a, 'b: 'a>(&mut self, node: &'b Module<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_module_stmt<'a, 'b: 'a>(&mut self, node: &'b ModuleStatement, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_object_expr<'a, 'b: 'a>(&mut self, node: &'b ObjectExpr<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_object_expr_field<'a, 'b: 'a>(&mut self, node: &'b ObjectExprField<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_paren_expr<'a, 'b: 'a>(&mut self, node: &'b ParenExpr<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_path<'a, 'b: 'a>(&mut self, node: &'b Path<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_path_segment<'a, 'b: 'a>(&mut self, node: &'b PathSegment<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_primitive_type<'a, 'b: 'a>(&mut self, node: &'b PrimitiveType, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_range_both_expr<'a, 'b: 'a>(&mut self, node: &'b RangeBothExpr<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_range_full_expr<'a, 'b: 'a>(&mut self, node: &'b RangeFullExpr, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_range_left_expr<'a, 'b: 'a>(&mut self, node: &'b RangeLeftExpr<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_range_right_expr<'a, 'b: 'a>(&mut self, node: &'b RangeRightExpr<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_ref_type<'a, 'b: 'a>(&mut self, node: &'b RefType<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_ret_stmt<'a, 'b: 'a>(&mut self, node: &'b ReturnStatement<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_simple_expr_stmt<'a, 'b: 'a>(&mut self, node: &'b SimpleExprStatement<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_simple_segment<'a, 'b: 'a>(&mut self, node: &'b SimpleSegment, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_stmt<'a, 'b: 'a>(&mut self, node: &'b Statement<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_struct_def<'a, 'b: 'a>(&mut self, node: &'b StructDef<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_tuple_expr<'a, 'b: 'a>(&mut self, node: &'b TupleExpr<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_tuple_index_expr<'a, 'b: 'a>(&mut self, node: &'b TupleIndexExpr<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_tuple_type<'a, 'b: 'a>(&mut self, node: &'b TupleType<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_type_def<'a, 'b: 'a>(&mut self, node: &'b TypeDef<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_type_list<'a, 'b: 'a>(&mut self, node: &'b TypeList<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_type_ref<'a, 'b: 'a>(&mut self, node: &'b TypeRef<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_unary_expr<'a, 'b: 'a>(&mut self, node: &'b UnaryExpr<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_use_stmt<'a, 'b: 'a>(&mut self, node: &'b UseStatement<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_var_decl_stmt<'a, 'b: 'a>(&mut self, node: &'b VarDeclStatement<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_where_clause<'a, 'b: 'a>(&mut self, node: &'b WhereClause<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
    fn visit_while_stmt<'a, 'b: 'a>(&mut self, node: &'b WhileStatement<'a>, arena: &'a Arena) -> Self::Result { node.walk(arena, self) }
}
