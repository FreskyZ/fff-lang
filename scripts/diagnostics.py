#!python3

# diagnostic strings declaration, generate macro for them to allow usage
# self.diagnostics.emit(strings::error_message_name) or
# self.diagnostics.emit(strings::error_message_name_with_param!(param1, param2))
# instead of format!("{}: {}", strings::SomeString, some_other_value)

# patch token.py
# I literal really completely don't understand why my module is preferred when import statement is in stdlib's code
# I completely don't understand again why if __name__ == __main__ is missing other file's global statement is executed but this block need copy
import sys
__import__('token')
mytoken = sys.modules.pop('token')
sys.modules['mytoken'] = mytoken
import importlib.util
import_spec = importlib.util.spec_from_file_location('token', '/usr/lib/python3.8/token.py')
std_token = importlib.util.module_from_spec(import_spec)
import_spec.loader.exec_module(std_token)
sys.modules['token'] = std_token

import re

INPUT_FILE = 'scripts/diagnostics.txt'
OUTPUT_FILE = 'src/diagnostics/strings.g.rs'

def load(input_file):
    RE = re.compile(r'const (?P<name>[\w\s]+) = "(?P<content>.*)";')

    results = []
    for line, row in enumerate(map(str.strip, open(input_file).readlines())):
        if not len(row) or row[0:2] == '//':
            continue
        match = RE.match(row)
        name = match.group('name').replace(' ', '_')
        content = match.group('content')
        count = content.count('{}') + content.count('{:?}')
        results.append((name, content, count))
    return results

def header():
    b = ''
    b += '#![allow(non_upper_case_globals)]\n'
    b += '///! ---------------------------------------------------------------------------------\n'
    b += '///! This code is auto generated by a tool $repo/scripts/diagnostics.py\n'
    b += '///! Changes may cause incorrect behavior and will be lost if the code is regenerated.\n'
    b += '///! ---------------------------------------------------------------------------------\n'
    b += '\n'
    return b

def generate(b, strings):

    for name, content, count in strings:
        if count == 0:
            b += f'pub const {name}: &str = "{content}";\n'

    b += '\n'
    for name, content, count in strings:
        if count:
            b += f'macro_rules! {name} {{ ($p1:expr'
            for i in range(2, count + 1):
                b += f', $p{i}:expr'
            b += f') => (format!("{content}", $p1'
            for i in range(2, count + 1):
                b += f', $p{i}'
            b += ')) }\n'

    b += '\n'
    for name, content, count in strings:
        if count:
            b += f'pub(crate) use {name};\n'

    return b

if __name__ == '__main__':
    strings = load(INPUT_FILE)

    print(f'{len(strings)} strings')
    with open(OUTPUT_FILE, 'w') as file:
        b = header()
        b = generate(b, strings)
        file.write(b)
